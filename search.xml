<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ctypes使用指南]]></title>
    <url>%2F2017%2F09%2F17%2Fctypes%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[ctypes 简介从Python2.5开始引入。ctypes是Python的外部函数库。它提供了C兼容的数据类型，并且允许调用动态链接库/共享库中的函数。它可以将这些库包装起来给Python使用。 ctypes 入门本入门中的代码使用doctest确保可用。不过一些代码在linux/windows/mac os x中的行为可能略有差异，这在其doctest的注释中有所表示。少数代码示例引用了ctypes的c_int类型。这个类型是32bit系统中c_long类型的别名。所以你在期待c_int而显示c_long时不必疑惑，他们是一样的。 载入动态链接库ctypes导出了 cdll，在windows上还有 windll 和 oledll 对象用于载入动态链接库。载入动态链接库可以直接存取其属性。 cdll 载入导出函数符合cdecl调用规范的库，而 windll 载入导出函数符合 stdcall 调用规范的库， oledll 也使用 stdcall 调用规范，并假设函数返回Windows的HRESULT错误码。错误码用于在出错时自动抛出WindowsError这个Python异常。如下是Windows的例子，主意msvcrt是MS标准C库，包含了大部分标准C函数，并且使用cdecl调用规范: 1234567&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; print windll.kernel32&lt;WinDLL &apos;kernel32&apos;, handle ... at ...&gt;&gt;&gt;&gt; print cdll.msvcrt&lt;CDLL &apos;msvcrt&apos;, handle ... at ...&gt;&gt;&gt;&gt; libc=cdll.msvcrt&gt;&gt;&gt; Windows通常使用”.dll”作为动态链接库的扩展名。Linux上需要指定包含扩展名的文件名来载入动态库，所以属性存取方式就失效了。你可以使用 LoadLibrary 方法，或者创建CDLL的实例来载入: 123456&gt;&gt;&gt; cdll.LoadLibrary(&quot;libc.so.6&quot;)&lt;CDLL &apos;libc.so.6&apos;, handle ... at ...&gt;&gt;&gt;&gt; libc==CDLL(&quot;libc.so.6&quot;)&gt;&gt;&gt; libc&lt;CDLL &apos;libc.so.6&apos;, handle ... at ...&gt;&gt;&gt;&gt; 从载入的动态链接库中访问函数函数是作为dll对象的属性来存取的: 123456789101112&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; libc.printf&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; print windll.kernel32.GetModuleHandleA&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; print windll.kernel32.MyOwnFunctionTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;ctypes.py&quot;, line 239, in __getattr__ func = _StdcallFuncPtr(name,self)AttributeError: function &apos;MyOwnFunction&apos; not found&gt;&gt;&gt; 注意win32系统动态链接库，如kernel32和user32经常同时导出ANSI和UNICODE版本的函数。UNICODE版本的会在名字末尾加”W”，而ANSI版本的加上”A”。Win32版本的 GetModuleHandle 函数，返回给定模块名的句柄，有如下C原型，还有一个宏用于暴露其中一个作为 GetModuleHandle ，依赖于UNICODE定义与否: 1234/* ANSI version */HMODULE GetModuleHandleA(LPCSTR lpModuleName);/* UNICODE version */HMODULE GetModuleHandleW(LPCWSTR lpModuleName); windll 并不会自动选择调用某个版本，所以你必须指定要调用的，传递的时候也要指定正确的字符串参数类型。有时动态链接库导出函数并不是有效的Python标识符，例如 “??2@YAPAXI@Z” 。这种情况下，你必须使用getattr 获取函数: 123&gt;&gt;&gt; getattr(cdll.msvcrt,&quot;??2@YAPAXI@Z&quot;)&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; 在Windows上，有些动态链接库导出函数不是用名字，而是用序号(ordinal)。这些函数通过索引存取: 123456789&gt;&gt;&gt; cdll.kernel32[1]&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; cdll.kernel32[0]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;ctypes.py&quot;, line 310, in __getitem__ func = _StdcallFuncPtr(name,self)AttributeError: function ordinal 0 not found&gt;&gt;&gt; 调用函数你可以像正常的Python函数一样调用这些函数。这里用 time() 函数示例，返回Unix epoch系统时间，和GetModuleHandleA() 函数，返回win32模块句柄。这个例子调用函数时附带NULL指针(None作为NULL指针): 12345&gt;&gt;&gt; print libc.time(None)1150640792&gt;&gt;&gt; print hex(windll.kernel32.GetModuleHandleA(None))0x1d000000&gt;&gt;&gt; 在调用函数时，如果使用了错误的参数数量和调用规范时，ctypes尝试保护调用。不幸的是该功能仅在Windows上有用。它通过检查函数返回栈来实现，所以尽管发生了错误，但是函数还是调用了: 12345678&gt;&gt;&gt; windll.kernel32.GetModuleHandleA()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with not enough argument (4 bytes missing)&gt;&gt;&gt; windll.kernel.GetModuleHandleA(0,0)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with too many argument (4 bytes in excess) 这在你使用了错误的调用规范时同样会发生: 1234567891011&gt;&gt;&gt; cdll.kernel32.GetModuleHandleA(None) # doctest: +WINDOWSTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with not enough arguments (4 bytes missing)&gt;&gt;&gt;&gt;&gt;&gt; windll.msvcrt.printf(&quot;spam&quot;) # doctest: +WINDOWSTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with too many arguments (4 bytes in excess)&gt;&gt;&gt; 想要找到正确的调用规范，你必须查看C头文件或者函数的文档。在Windows，ctypes使用win32结构异常处理，避免无保护的挂掉: 1234&gt;&gt;&gt; windll.kernel32.GetModuleHandleA(32)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?WindowsError: exception: access violation reading 0x00000020 尽管如此，仍然有很多方法用ctypes挂掉Python，所以你必须很小心的使用。None、整数、长整数、字节串和unicode字符串是可以作为本地Python对象直接传递给函数调用的。None是作为C的NULL指针，字 节串和unicode字符串作为内存块指针传递(char 或 wchar_t)。Python整数和长整数作为平台相关的C类型传递。在调用更多的函数之前，必须了解关于ctypes数据类型的知识。 基本数据类型ctypes定义了一系列基本C数据类型： ctypes 类型 C类型 Python 类型 c_char char 1个字符的字符串 c_wchar wchar_t 1个字符的unicode字符串 c_byte char int/long c_ubyte unsigned char int/long c_short short int/long c_ushort unsigned short int/long c_int int int/long c_uint unsigned int int/long c_long long int/long c_ulong unsigned long int/long c_longlong __int64 或 long long int/long c_ulonglong unsigned __int64 或 unsigned long long int/long c_float float float c_double double float c_char_p char * (NUL 结尾字符串) string 或 None c_wchar_p wchar_t * (NUL 结尾字符串) unicode 或 None c_void_p void * int/long 或 None 所有这些类型都可以通过调用可选传输初始化值方式指定值: 123456&gt;&gt;&gt; c_int()c_long(0)&gt;&gt;&gt; c_char_p(&quot;Hello, world&quot;)c_char_p(&apos;Hello, world&apos;)&gt;&gt;&gt; c_ushort(-3)c_ushort(65533) 这些类型都是可变的，其值也是随后可变的: 123456789&gt;&gt;&gt; i=c_int(42)&gt;&gt;&gt; print ic_long(42)&gt;&gt;&gt; print i.value42&gt;&gt;&gt; i.value=-99&gt;&gt;&gt; print i.value-99&gt;&gt;&gt; 对指针类型 c_char_p/c_wchar_p/c_void_p 的赋值将会改变其指向的内存区域地址，而不是改变内存块的值(当然了，因为Python字符串是只读的): 12345678910&gt;&gt;&gt; s=&quot;Hello, world&quot;&gt;&gt;&gt; c_s=c_char_p(s)&gt;&gt;&gt; print c_sc_char_p(&apos;Hello, world&apos;)&gt;&gt;&gt; c_s.value=&quot;Hi, there&quot;&gt;&gt;&gt; print c_sc_char_p(&apos;Hi, there&apos;)&gt;&gt;&gt; print s #第一个字符串没有改变Hello, world&gt;&gt;&gt; 必须小心的是，不要传递这些的指针给可变内存。如果你需要可变内存块，ctypes提供了create_string_buffer() 函数。当前内存块可以存取或改变，如果你想要将其作为NUL结尾字符串方式，使用值的方法: 12345678910111213141516&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; p = create_string_buffer(3) # create a 3 byte buffer, initialized to NUL bytes&gt;&gt;&gt; print sizeof(p), repr(p.raw)3 &apos;\x00\x00\x00&apos;&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;) # create a buffer containing a NUL terminated string&gt;&gt;&gt; print sizeof(p), repr(p.raw)6 &apos;Hello\x00&apos;&gt;&gt;&gt; print repr(p.value)&apos;Hello&apos;&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;, 10) # create a 10 byte buffer&gt;&gt;&gt; print sizeof(p), repr(p.raw)10 &apos;Hello\x00\x00\x00\x00\x00&apos;&gt;&gt;&gt; p.value = &quot;Hi&quot;&gt;&gt;&gt; print sizeof(p), repr(p.raw)10 &apos;Hi\x00lo\x00\x00\x00\x00\x00&apos;&gt;&gt;&gt; create_string_buffer() 函数已经替换了 c_buffer() 函数(仍然作为别名存在)，有如 c_string() 函数以前，只是出现在以前的版本中。想要创建包含unicode字符(对应C类型wchar_t)的可变内存块，使用create_unicode_buffer() 函数。 调用函数，继续需要注意的是，printf打印到真实的标准输出，而不是 sys.stdout ，所以这些例子仅在控制台模式有效，而不是IDLE或PythonWin: 123456789101112131415&gt;&gt;&gt; printf=libc.printf&gt;&gt;&gt; printf(&quot;Hello, %s\n&quot;,&quot;World!&quot;)Hello, World!14&gt;&gt;&gt; printf(&quot;Hello, %S&quot;, u&quot;World!&quot;)Hello, World!13&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, 42)42 bottles of beer19&gt;&gt;&gt; printf(&quot;%f bottles of beer\n&quot;, 42.5)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ArgumentError: argument 2: exceptions.TypeError: Don&apos;t know how to convert parameter 2&gt;&gt;&gt; 如前面所说，除了整数、字符串和unicode字符串以外的Python类型必须使用ctypes类型做包装，所以他们可以转换为必须的C数据类型: 123&gt;&gt;&gt; printf(&quot;An int %d, a double %f\n&quot;,1234,c_double(3.14))An int 1234, a double 3.1400001049&gt;&gt;&gt; 使用自定义数据类型调用函数你可以使用自定义ctypes参数转换，允许你自己的类作为函数参数。ctypes寻找对象的 _asparameter 属性，并将其作为函数参数。当然，必须是整数、字符串或unicode 123456789&gt;&gt;&gt; class Bottles(object):... def __init__(self, number):... self._as_parameter_ = number...&gt;&gt;&gt; bottles = Bottles(42)&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, bottles)42 bottles of beer19&gt;&gt;&gt; 如果你不想存储实例的数据到 _asparameter 实例变量，你可以定义一个属性确保数据有效。 指定必须的参数类型(函数原型)可以通过指定函数的 argtypes 属性来指定函数的参数类型。argtypes必须是一个C数据类型序列(printf函数在这里不是个好例子，因为它需要依赖于格式化字符串的可变数量和多种类型的参数，反过来说倒是很适合于练手): 1234&gt;&gt;&gt; printf.argtypes=[c_char_p,c_char_p,c_int,c_double]&gt;&gt;&gt; printf(&quot;String &apos;%s&apos;, Int %d, Double %f\n&quot;,&quot;Hi&quot;,10,2.2)String &apos;Hi&apos;, Int 10, Double 2.200000&gt;&gt;&gt; 指定不兼容的参数类型，和尝试转换参数到到无效类型会出错: 1234567&gt;&gt;&gt; printf(&quot;%d %d %d&quot;, 1, 2, 3)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ArgumentError: argument 2: exceptions.TypeError: wrong type&gt;&gt;&gt; printf(&quot;%s %d %f&quot;, &quot;X&quot;, 2, 3)X 2 3.00000012&gt;&gt;&gt; 如果你自定义的类要传递给函数调用，必须实现 from_param 类方法，才能在argtypes序列中使用。from_param 类方法接收Python对象传递到函数调用，需要做类型检查或者其他确保对象可以被接受的工作，然后返回对象本身， _asparameter 属性，或者你想要传递给C函数的参数。再次说明，返回结果必须是整数、字符串、unicode、ctypes实例，或者任何有 _asparameter 属性的东西。 返回类型缺省情况假设函数返回C的int类型。其他返回类型可以通过设置函数的 restype 属性来实现。这里是一个更高级的例子，它使用strchr函数，需要一个字符串指针和一个字符，返回字符串的指针: 123456789&gt;&gt;&gt; strchr = libc.strchr&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;)) # doctest: +SKIP8059983&gt;&gt;&gt; strchr.restype = c_char_p # c_char_p is a pointer to a string&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;))&apos;def&apos;&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, ord(&quot;x&quot;))None&gt;&gt;&gt; 如果你想要上面的 ord(“x”) 调用，你可以设置argtypes属性，而第二个参数的Python字符串会转换成C字符: 12345678910111213&gt;&gt;&gt; strchr.restype = c_char_p&gt;&gt;&gt; strchr.argtypes = [c_char_p, c_char]&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)&apos;def&apos;&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;def&quot;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ArgumentError: argument 2: exceptions.TypeError: one character string expected&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, &quot;x&quot;)None&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)&apos;def&apos;&gt;&gt;&gt; 你还可以使用Python的可调用对象(函数或者类的例子)作为restype属性，如果外语函数返回整数。这时在C函数调用结束后会使用其返回的 整数调用这个Python可调用对象，而返回值作为函数调用的返回值。相当于对C函数返回值做了包装。这对于检查错误码而抛出异常的情况非常有用: 12345678910111213141516&gt;&gt;&gt; GetModuleHandle = windll.kernel32.GetModuleHandleA # doctest: +WINDOWS&gt;&gt;&gt; def ValidHandle(value):... if value == 0:... raise WinError()... return value...&gt;&gt;&gt;&gt;&gt;&gt; GetModuleHandle.restype = ValidHandle # doctest: +WINDOWS&gt;&gt;&gt; GetModuleHandle(None) # doctest: +WINDOWS486539264&gt;&gt;&gt; GetModuleHandle(&quot;something silly&quot;) # doctest: +WINDOWSTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 3, in ValidHandleWindowsError: [Errno 126] The specified module could not be found.&gt;&gt;&gt; 这里的 WinError 是一个函数，会调用Windows的 FormatMessage() API来获取错误码的字符串描述，并且返回异常。 WinError 接受可选的错误码参数，如果没有指定则调用 GetLastError() 获取。需要注意的是强大的错误检查机制是通过 errcheck 属性实现的。具体查看手册了解细节。 传递指针(或者传递参数引用)有时C函数需要一个指针指向的数据作为参数，还有可能是想向里面写的位置，或者数据太大不适合传递。这也叫做传递参数引用。 ctypes导出 byref() 函数用于传递参数引用。同样也可以用于指针函数，尽管指针对象可以做很多工作，但是如果你并不需要在Python中使用指针对象的话，使用 byref() 会更快: 1234567891011&gt;&gt;&gt; i = c_int()&gt;&gt;&gt; f = c_float()&gt;&gt;&gt; s = create_string_buffer(&apos;\000&apos; * 32)&gt;&gt;&gt; print i.value, f.value, repr(s.value)0 0.0 &apos;&apos;&gt;&gt;&gt; libc.sscanf(&quot;1 3.14 Hello&quot;, &quot;%d %f %s&quot;,... byref(i), byref(f), s)3&gt;&gt;&gt; print i.value, f.value, repr(s.value)1 3.1400001049 &apos;Hello&apos;&gt;&gt;&gt; 结构和联合结构和联合必须继承自ctypes模块的 Structure 和 Union 类。每个子类必须定义 fields 属性，该属性必须是2元素元组的列表，包含字段名和字段类型。 字段类型必须是ctypes类型，例如 c_int ，或者其他派生的ctypes类型：结构、联合、数组、指针。 这里有个POINT结构体的简单例子，包含两个整数叫做x和y，同时展示了如何构造结构体: 12345678910111213141516&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class POINT(Structure):... _fields_ = [(&quot;x&quot;, c_int),... (&quot;y&quot;, c_int)]...&gt;&gt;&gt; point = POINT(10, 20)&gt;&gt;&gt; print point.x, point.y10 20&gt;&gt;&gt; point = POINT(y=5)&gt;&gt;&gt; print point.x, point.y0 5&gt;&gt;&gt; POINT(1, 2, 3)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: too many initializers&gt;&gt;&gt; 你还可以构造更多复杂的结构体。结构体可以自包含作为一个字段类型。这里是一个RECT结构体，它包含了两个POINT结构体分别名为upperleft和lowerright： 12345678910&gt;&gt;&gt; class RECT(Structure):... _fields_ = [(&quot;upperleft&quot;, POINT),... (&quot;lowerright&quot;, POINT)]...&gt;&gt;&gt; rc = RECT(point)&gt;&gt;&gt; print rc.upperleft.x, rc.upperleft.y0 5&gt;&gt;&gt; print rc.lowerright.x, rc.lowerright.y0 0&gt;&gt;&gt; 嵌套结构体可以通过下面多种方法初始化： 12&gt;&gt;&gt; r = RECT(POINT(1, 2), POINT(3, 4))&gt;&gt;&gt; r = RECT((1, 2), (3, 4)) 域描述可以检索到类，这对调试有很大的帮助，因为它们可以提供到有用的信息： 12345&gt;&gt;&gt; print POINT.x&lt;Field type=c_long, ofs=0, size=4&gt;&gt;&gt;&gt; print POINT.y&lt;Field type=c_long, ofs=4, size=4&gt;&gt;&gt;&gt; 结构/联合对齐和字节序默认情况下结构体和联合的对齐使用C编译器相同的方式。这可以通过 pack 类属性来重载其行为。这必须设置一个正数指定字段的最大对齐。这个功能与MSVC中的 #pragma pack(n) 功能一样。 ctypes中的结构体和联合使用本地字节序。想要用非本地字节序，可以使用 BigEndianStructure 、LittleEndianStructure 、 BigEndianUnion 、 LittleEndianUnion 基类。这些类无法包含指针字段。 结构与联合中的位字段创建结构与联合体时，可以包含位字段。只有整型域才可以使用位字段，位宽可以在fields元组的第三个选项中指定： 123456789&gt;&gt;&gt; class Int(Structure):... _fields_ = [(&quot;first_16&quot;, c_int, 16),... (&quot;second_16&quot;, c_int, 16)]...&gt;&gt;&gt; print Int.first_16&lt;Field type=c_long, ofs=0:0, bits=16&gt;&gt;&gt;&gt; print Int.second_16&lt;Field type=c_long, ofs=0:16, bits=16&gt;&gt;&gt;&gt; 数组数组就是序列，包含固定数量(fixed number of)的相同类型的实例。推荐的创建数组类型的方式是使用正数和乘号应用到类型: 1TenPointsArrayType=POINT*10 这里有个巧妙的例子，一个结构体包含一个字段有4个POINT: 123456789101112&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class POINT(Structure):... _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)...&gt;&gt;&gt; class MyStruct(Structure):... _fields_ = [(&quot;a&quot;, c_int),... (&quot;b&quot;, c_float),... (&quot;point_array&quot;, POINT * 4)]&gt;&gt;&gt;&gt;&gt;&gt; print len(MyStruct().point_array)4&gt;&gt;&gt; 可以通过下面的办法高效访问数组： 123arr = TenPointsArrayType()for pt in arr: print pt.x, pt.y 上面的代码打印一行结果0 0，因为数组数据初始化为0。可以通过下面的办法显式初始化： 123456789&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; TenIntegers = c_int * 10&gt;&gt;&gt; ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)&gt;&gt;&gt; print ii&lt;c_long_Array_10 object at 0x...&gt;&gt;&gt;&gt; for i in ii: print i,...1 2 3 4 5 6 7 8 9 10&gt;&gt;&gt; 指针指针实例使用 pointer() 函数: 1234&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; i=c_int(42)&gt;&gt;&gt; pi=pointer(i)&gt;&gt;&gt; 指针实例有一个 contents 属性返回指针指向的内容对象，例如上面的例子: 123&gt;&gt;&gt; pi.contentsc_long(42)&gt;&gt;&gt; 注意ctypes没有OOR(Original Object Return原始对象返回)，他在你请求一个属性时构造一个新的、等同的对象: 12345&gt;&gt;&gt; pi.contents is iFalse&gt;&gt;&gt; pi.contents is pi.contentsFalse&gt;&gt;&gt; 给指针的contents属性赋值一个新的c_int实例会改变指针指向内容的内存地址： 12345&gt;&gt;&gt; i = c_int(99)&gt;&gt;&gt; pi.contents = i&gt;&gt;&gt; pi.contentsc_long(99)&gt;&gt;&gt; 指针实例可以通过整数下标访问： 123&gt;&gt;&gt; pi[0]99&gt;&gt;&gt; 也可以通过下标访问的方式来改变指针指向的内容： 123456&gt;&gt;&gt; print ic_long(99)&gt;&gt;&gt; pi[0] = 22&gt;&gt;&gt; print ic_long(22)&gt;&gt;&gt; 你也可以使用非0下标访问，但你必须知道你在做什么，比如在C语言：你可以访问或改变任意的内存地址。一般情况下，你仅可以在收到一个C函数返回来的指针，并且你知道它是指向了一个数组时才可以使用这个特性。 指针函数不仅创建了指针实例，它还会先创建指针类型。这些就是指针函数POINTER的工作，它可以接受任何ctypes的类型，并返回一个新的指针： 12345678910&gt;&gt;&gt; PI = POINTER(c_int)&gt;&gt;&gt; PI&lt;class &apos;ctypes.LP_c_long&apos;&gt;&gt;&gt;&gt; PI(42)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?TypeError: expected c_long instead of int&gt;&gt;&gt; PI(c_int(42))&lt;ctypes.LP_c_long object at 0x...&gt;&gt;&gt;&gt; NULL指针具有默认的布尔值False： 1234&gt;&gt;&gt; null_ptr = POINTER(c_int)()&gt;&gt;&gt; print bool(null_ptr)False&gt;&gt;&gt; 当访问或给NULL指针赋值时，会引发python类型检查异常： 1234567891011&gt;&gt;&gt; null_ptr[0]Traceback (most recent call last): ....ValueError: NULL pointer access&gt;&gt;&gt;&gt;&gt;&gt; null_ptr[0] = 1234Traceback (most recent call last): ....ValueError: NULL pointer access&gt;&gt;&gt; 类型转换通常情况下，ctypes会做严格的类型检查。这意味着，如果形参有一个POINTER(c_int)指针指向一个函数或者结构体的成员域类型，那么实参只能接受相同类型的实例。但这个规则在ctypes处理其他对象时也有例外。比如，你可以传递兼容的数据类型来代替指针类型。所以，对于POINTER(c_int)指针类型来说，可以使用c_int数据来代替： 12345678910111213&gt;&gt;&gt; class Bar(Structure):... _fields_ = [(&quot;count&quot;, c_int), (&quot;values&quot;, POINTER(c_int))]...&gt;&gt;&gt; bar = Bar()&gt;&gt;&gt; bar.values = (c_int * 3)(1, 2, 3)&gt;&gt;&gt; bar.count = 3&gt;&gt;&gt; for i in range(bar.count):... print bar.values[i]...123&gt;&gt;&gt; 可以通过给指针的values属性赋值为None来设置NULL指针： 12&gt;&gt;&gt; bar.values = None&gt;&gt;&gt; 在C语言，你可以通过强制类型转换的方法来转换不兼容的类型。ctypes也提供了一个转换函数让你可以使用相同的方式进行类型转换。上面定义的Bar结构体中，它的value域可以支持POINTER(c_int)指针或者c_int数组，但不支持其他类型： 12345&gt;&gt;&gt; bar.values = (c_byte * 4)()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long instance&gt;&gt;&gt; 在这种情况下，转换函数就方便多了。 转换函数可以将一个能转换成ctypes指针的实例转换成另外一个ctypes指针类型。转换函数需要两个参数，第一个是能够转换成指针类型的cytpes实例类型，第二个是ctypes指针类型。它返回第二个参数类型的实例，并且这个实例与第一个参数共用同一块内存： 1234&gt;&gt;&gt; a = (c_byte * 4)()&gt;&gt;&gt; cast(a, POINTER(c_int))&lt;ctypes.LP_c_long object at ...&gt;&gt;&gt;&gt; 所以，Bar结构的values域可以这样通过类型转换来赋值： 12345&gt;&gt;&gt; bar = Bar()&gt;&gt;&gt; bar.values = cast((c_byte * 4)(), POINTER(c_int))&gt;&gt;&gt; print bar.values[0]0&gt;&gt;&gt; 不完全的类型不完全的类型包含结构体，联合体或者类型未指定的数组。在C语言中，它们可以这样先声明后定义： 123456struct cell; /* forward declaration */struct &#123; char *name; struct cell *next;&#125; cell; 直接这样转换成ctypes代码将会无效： 123456789&gt;&gt;&gt; class cell(Structure):... _fields_ = [(&quot;name&quot;, c_char_p),... (&quot;next&quot;, POINTER(cell))]...Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 2, in cellNameError: name &apos;cell&apos; is not defined&gt;&gt;&gt; 因为新类cell在类本身定义时是无效的。在ctypes，我们可以先定义cell类，然后再给它的fields属性赋值： 1234567&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class cell(Structure):... pass...&gt;&gt;&gt; cell._fields_ = [(&quot;name&quot;, c_char_p),... (&quot;next&quot;, POINTER(cell))]&gt;&gt;&gt; 让我们试一下效果。我们创建两个cell的实例，然后让他们互相指向对方，然后尝试访问指针链表几次： 12345678910111213&gt;&gt;&gt; c1 = cell()&gt;&gt;&gt; c1.name = &quot;foo&quot;&gt;&gt;&gt; c2 = cell()&gt;&gt;&gt; c2.name = &quot;bar&quot;&gt;&gt;&gt; c1.next = pointer(c2)&gt;&gt;&gt; c2.next = pointer(c1)&gt;&gt;&gt; p = c1&gt;&gt;&gt; for i in range(8):... print p.name,... p = p.next[0]...foo bar foo bar foo bar foo bar&gt;&gt;&gt; 回调函数ctypes允许从python回调中创建c回调函数指针。这个常常被称为回调函数。 首先，你必须为回调函数创建一个类，这个类知道调用协议，函数返回值类型，函数接受的参数个数及类型。 CFUNCTYPE工厂函数使用普通cdecl调用协议来为回调函数创建类型。并且，在Windows平台，WINFUNCTYPE工厂函数使用stdcall调用协议来为回调函数创建类型。 这两个工厂函数在调用时，参数表都是使用返回值作为第一个参数，而将回调函数所需要的参数作为剩下的参数。 在这里我将使用一个c标准库里的快排函数作为演示例子，快排是一个借助回调函数进行排序的函数。快排将会用到下面的整型数组： 12345&gt;&gt;&gt; IntArray5 = c_int * 5&gt;&gt;&gt; ia = IntArray5(5, 1, 7, 33, 99)&gt;&gt;&gt; qsort = libc.qsort&gt;&gt;&gt; qsort.restype = None&gt;&gt;&gt; 快排调用时需要一个待排序的原始数据指针，数组元素个数，单个元素的大小，以及一个被称为回调的比较函数指针。回调函数形参表需要两个待比较元素类型的指针，它的返回值为，当第一个数据小于第二个时返回负整数，两个数据相等时返回0，其他情况返回正整数。 所以，我们例子所需要的回调函数形参表是两个整型指针，它返回一个整数。首先我们用工厂函数创建回调函数的类型： 12&gt;&gt;&gt; CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))&gt;&gt;&gt; 在真正实现回调函数之前，我们简单打印获取到的参数，然后返回0（一步一步来） 12345&gt;&gt;&gt; def py_cmp_func(a, b):... print &quot;py_cmp_func&quot;, a, b... return 0...&gt;&gt;&gt; 创建C回调函数： 12&gt;&gt;&gt; cmp_func = CMPFUNC(py_cmp_func)&gt;&gt;&gt; 然后运行一下： 123456789101112&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +WINDOWSpy_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;&gt;&gt;&gt; 我们已经知道怎么访问指针指向的内容了，所以让我们重新定义一下回调函数： 123456&gt;&gt;&gt; def py_cmp_func(a, b):... print &quot;py_cmp_func&quot;, a[0], b[0]... return 0...&gt;&gt;&gt; cmp_func = CMPFUNC(py_cmp_func)&gt;&gt;&gt; 这是我们在Windows上跑到的结果： 123456789101112&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +WINDOWSpy_cmp_func 7 1py_cmp_func 33 1py_cmp_func 99 1py_cmp_func 5 1py_cmp_func 7 5py_cmp_func 33 5py_cmp_func 99 5py_cmp_func 7 99py_cmp_func 33 99py_cmp_func 7 33&gt;&gt;&gt; 有趣的是，在linux上排序函数运行更高效，它仅需要更少的比较的次数： 1234567&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +LINUXpy_cmp_func 5 1py_cmp_func 33 99py_cmp_func 7 33py_cmp_func 5 7py_cmp_func 1 7&gt;&gt;&gt; 嗯，我们将要完成了！最后一步是要真正去对两个数据进行比较并且返回一个有用的结果： 12345&gt;&gt;&gt; def py_cmp_func(a, b):... print &quot;py_cmp_func&quot;, a[0], b[0]... return a[0] - b[0]...&gt;&gt;&gt; 最后在Windows上运行的结果： 123456789101112&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) # doctest: +WINDOWSpy_cmp_func 33 7py_cmp_func 99 33py_cmp_func 5 99py_cmp_func 1 99py_cmp_func 33 7py_cmp_func 1 33py_cmp_func 5 33py_cmp_func 5 7py_cmp_func 1 7py_cmp_func 5 1&gt;&gt;&gt; 然后下面是linux上的结果: 1234567&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) # doctest: +LINUXpy_cmp_func 5 1py_cmp_func 33 99py_cmp_func 7 33py_cmp_func 1 7py_cmp_func 5 7&gt;&gt;&gt; 很有趣地看到，Windows的快排比在linux版本的快排比较的次数多！ 我们可以简单检查一下排序结果： 1234&gt;&gt;&gt; for i in ia: print i,...1 5 7 33 99&gt;&gt;&gt; 回调函数的重要提示： 确保你在C代码的使用生命周期里保持引用CFUNCTYPE对象。ctypes并不会帮你做这样的事情，如果你没有做保证，它们就会被垃圾回收，然后当你调用这个回调函数时将会导致程序崩溃。 访问动态链接库导出的值有时候，一个动态链接库不仅提供了函数，它还提供了变量。一个例子是，在Python自身库里使用了Py_OptimizeFlag标志变量，这个整型变量被设置为0，1，或者2，它依赖于python在启动时指定的-O或者-OO标志。ctypes可以这样使用in_dll的类方法访问变量值。pythonapi是一个预定义符号可以访问Python C api： 1234&gt;&gt;&gt; opt_flag = c_int.in_dll(pythonapi, &quot;Py_OptimizeFlag&quot;)&gt;&gt;&gt; print opt_flagc_long(0)&gt;&gt;&gt; 如果解析器使用-O命令启动，例子就会打印c_long(1)，或者c_long(2)如果指定-OO参数。 Python的导出指针PyImport_FrozenModules也是一个扩展的例子展示指针的访问使用办法。 根据Python docs文档：这个指针初始化指向一组”struct _frozen`”记录，以一个成员全部都是NULL或者0作为结束标志。当导入一个静态模块，它就会在这张表里面搜索。第三方代码可以利用此技巧提供一个静态模块的动态创建集合。 所以熟悉这个指针证明还是挺有用的。为了限制例子的大小，我们仅展示这个表如果通过ctypes来访问。 12345678&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt;&gt;&gt;&gt; class struct_frozen(Structure):... _fields_ = [(&quot;name&quot;, c_char_p),... (&quot;code&quot;, POINTER(c_ubyte)),... (&quot;size&quot;, c_int)]...&gt;&gt;&gt; 我们已经定义struct_frozen的数据结构类型，所以我们可以获得指向这张表的指针： 123&gt;&gt;&gt; FrozenTable = POINTER(struct_frozen)&gt;&gt;&gt; table = FrozenTable.in_dll(pythonapi, &quot;PyImport_FrozenModules&quot;)&gt;&gt;&gt; 由于此表是一个struct_frozen记录的数据指针，所以我们可以迭代遍历它，不过我们必须保证结束我们的循环，因为此指针没有指明大小。迟早它会因为非法访问而导致崩溃，所以当我们访问到NULL实体时，最好结束循环： 12345678910&gt;&gt;&gt; for item in table:... print item.name, item.size... if item.name is None:... break...__hello__ 104__phello__ -104__phello__.spam 104None 0&gt;&gt;&gt; 事实上，标准Python有一个并不怎么出名的静态模块和一个静态包（相对于其他成员来说），它仅用于测试。试试用import hello吧。 意料之外在ctypes，有些坑可能你没想到。 思考下面的例子： 1234567891011121314151617&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class POINT(Structure):... _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)...&gt;&gt;&gt; class RECT(Structure):... _fields_ = (&quot;a&quot;, POINT), (&quot;b&quot;, POINT)...&gt;&gt;&gt; p1 = POINT(1, 2)&gt;&gt;&gt; p2 = POINT(3, 4)&gt;&gt;&gt; rc = RECT(p1, p2)&gt;&gt;&gt; print rc.a.x, rc.a.y, rc.b.x, rc.b.y1 2 3 4&gt;&gt;&gt; # now swap the two points&gt;&gt;&gt; rc.a, rc.b = rc.b, rc.a&gt;&gt;&gt; print rc.a.x, rc.a.y, rc.b.x, rc.b.y3 4 3 4&gt;&gt;&gt; 嗯，我们当然期望最后一名打印3 4 1 2。到底发生了什么事？这里是上面rc.a, rc.b = rc.b, rc.a这一行的步骤： 1234&gt;&gt;&gt; temp0, temp1 = rc.b, rc.a&gt;&gt;&gt; rc.a = temp0&gt;&gt;&gt; rc.b = temp1&gt;&gt;&gt; 注意，temp0和temp1都是使用了上述rc对象的内部缓存块对象。所以当执行rc.a = temp0时，拷贝了temp0的缓冲内容给rc的缓冲。依次地，又改为temp1的内容。所以最后一句rc.b = temp1并没有想像中那样的效果。记住，检索结构体，联合体及数组并不是使用它们的拷贝，而是检索一个访问顶级对象相关缓冲区的封装对象。 另外一个意想不到的例子是： 1234567&gt;&gt;&gt; s = c_char_p()&gt;&gt;&gt; s.value = &quot;abc def ghi&quot;&gt;&gt;&gt; s.value&apos;abc def ghi&apos;&gt;&gt;&gt; s.value is s.valueFalse&gt;&gt;&gt; 为什么这里打印False？ctypes实例是一些包含内存块加上一些内容内存访问描述信息的对象。存储一个Python对象在内存块并不是存储对象本身，取而代之存储的是对象的内容。每次访问内容时都会构造一个新的Python对象！ 可变大小的数据类型ctypes提供了可变数组与结构体的支持（在0.9.9.7版本增加）。 resize函数可以调整一个已经存在的ctypes对象的内存缓冲大小。这个函数以ctypes对象为第一个参数，以需要调整后的字节大小为第二个参数。重新调整的内存块大小不能小于原生对象类型的内存块大小，若你这么做，则会抛出ValueError： 12345678910111213&gt;&gt;&gt; short_array = (c_short * 4)()&gt;&gt;&gt; print sizeof(short_array)8&gt;&gt;&gt; resize(short_array, 4)Traceback (most recent call last): ...ValueError: minimum size is 8&gt;&gt;&gt; resize(short_array, 32)&gt;&gt;&gt; sizeof(short_array)32&gt;&gt;&gt; sizeof(type(short_array))8&gt;&gt;&gt; 这看起来不错，但怎么访问这个数据增加的元素呢？由于type方法仍然只知道有4个元素，当访问其他元素时我们会得到错误： 1234567&gt;&gt;&gt; short_array[:][0, 0, 0, 0]&gt;&gt;&gt; short_array[7]Traceback (most recent call last): ...IndexError: invalid index&gt;&gt;&gt; ctypes中另外一种使用可变数据类型的方法是使用Python的动态语言特性，具体问题具体分析，当已经知道需要的数据大小时，才（重）定义数据类型。 bug, todo和未完成的东西没有实现枚举类型。你自己使用c_int作为基类就可以简单实现它。 没有实现long double类型。 参考资料 http://starship.python.net/crew/theller/ctypes/tutorial.html#bugs-todo-and-non-implemented-things本文档翻译的文章。 http://gashero.iteye.com/blog/519837本文档主要借鉴参考的文章。 http://www.isnowfy.com/introduction-to-python-c-extension/简单列举了各种python的c扩展办法。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>ctypes</tag>
        <tag>Cross language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocol Buffers 使用教程]]></title>
    <url>%2F2017%2F08%2F05%2FProtocol-Buffers-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述什么是 protocol buffers?ProtocolBuffer 是用于结构化数据串行化的灵活、高效、自动的方法，类似 XML，不 过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码 来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。 他们如何工作你首先需要在一个.proto 文件中定义你需要做串行化的数据结构信息。每个 ProtocolBuffer 信息是一小段逻辑记录，包含一系列的键值对。这里有个非常简单的.proto 文件定义了个人信息: 12345678910111213141516message Person &#123; required string name=1; required int32 id=2; optional string email=3; enum PhoneType &#123; MOBILE=0; HOME=1; WORK=2; &#125; message PhoneNumber &#123; required string number=1; optional PhoneType type=2 [default=HOME]; &#125; repeated PhoneNumber phone=4;&#125; 如你所见，消息格式很简单，每个消息类型拥有一个或多个特定的数字字段，每个字 段拥有一个名字和一个值类型。值类型可以是数字(整数或浮点)、布尔型、字符串、原始字 节或者其他 ProtocolBuffer 类型，还允许数据结构的分级。你可以指定可选字段，必选字 段和重复字段。你可以在protocolbuffers/docs/proto找到更多关于如何 编写 .proto 文件的信息。 一旦你定义了自己的报文格式(message)，你就可以运行ProtocolBuffer编译器，将你 的.proto 文件编译成特定语言的类。这些类提供了简单的方法访问每个字段(像是 query() 和 set_query() )，像是访问类的方法一样将结构串行化或反串行化。例如你可以选择 C++ 语言，运行编译如上的协议文件生成类叫做 Person 。随后你就可以在应用中使用这个类来 串行化的读取报文信息。你可以这么写代码: 12345Person person;person.set_name(&quot;John Doe&quot;);person.set_id(1234); person.set_email(&quot;jdoe@example.com&quot;);fstream.output(&quot;myfile&quot;,ios::out | ios::binary);person.SerializeToOstream(&amp;output); 然后，你可以读取报文中的数据: 12345fstream input(&quot;myfile&quot;,ios::in | ios:binary);Person person;person.ParseFromIstream(&amp;input);cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.email() &lt;&lt; endl; 你可以在不影响向后兼容的情况下随意给数据结构增加字段，旧有的数据会忽略新的字段。所以如果使用 ProtocolBuffer 作为通信协议，你可以无须担心破坏现有代码的情况下扩展协议。 你可以在 API 参考overview中找 到完整的参考，而关于 ProtocolBuffer 的报文格式编码则可以在encoding中找到。 为什么不使用 xml?ProtocolBuffer 拥有多项比 XML 更高级的串行化结构数据的特性，ProtocolBuffer: 更简单小3-10倍快20-100倍更少的歧义可以方便的生成数据存取类例如，让我们看看如何在 XML 中建模 Person 的 name 和 email 字段: 1234&lt;person&gt;&lt;name&gt;John Doe&lt;/name&gt;&lt;email&gt;jdoe@example.com&lt;/email&gt;&lt;/person&gt; 对应的 ProtocolBuffer 报文则如下: 1234person &#123; name: &quot;John Doe&quot; email: &quot;jdoe@example.com&quot;&#125; 当这个报文编码encoding到 ProtocolBuffer 的二进制格式时(上面的文本 仅用于调试和编辑)，它只需要28字节和100-200ns 的解析时间。而 XML 的版本需要69字节(除 去空白)和5000-10000ns 的解析时间。 当然，操作 ProtocolBuffer 也很简单: 12cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.email() &lt;&lt; endl; 而 XML 的你需要: 123456cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.getElementsByTagName(&quot;name&quot;)-&gt;item(0)-&gt;innerText() &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.getElementsByTagName(&quot;email&quot;)-&gt;item(0)-&gt;innerText() &lt;&lt; endl; 当然，ProtocolBuffer 并不是在任何时候都比 XML 更合适，例如 ProtocolBuffer 无法 对一个基于标记文本的文档建模(比如 HTML)，因为你根本没法方便的在文本中插入结构。 另外，XML 是便于人类阅读和编辑的，而 ProtocolBuffer 则不是。还有 XML 是自解释的， 而 ProtocolBuffer 仅在你拥有报文格式定义的.proto 文件时才有意义。 如何开始?下载包，包含了 Java、Python、 C++的 ProtocolBuffer 编译器，用于生成你需要的 IO 类。构建和安装你的编译器，跟随 README 的指令就可以做到。 一旦你安装好了，就可以跟着编程指导来选择语言- 随后就是使用 ProtocolBuffer 创建一个简单的应用了。 一点历史ProtocolBuffers 最初是在 Google 开发的，用以解决索引服务器的请求、响应协议。 在使用 ProtocolBuffers 之前，有一种格式用以处理请求和响应数据的编码和解码，并且支 持多种版本的协议。而这最终导致了丑陋的代码，比如:12345678if (version==3) &#123; ...&#125; else if (version&gt;4) &#123; if (version==5) &#123; ... &#125; ...&#125; 通信协议因此变得越来越复杂，因为开发者必须确保，发出请求的人和接受请求的人必 须同时兼容，并且在一方开始使用新协议时，另外一方也要可以接受。ProtocolBuffers 设计用于解决这一类问题: 很方便引入新字段，而中间服务器可以忽略这些字段，直接传递过去而无需理解所有的 字段。 格式可以自描述，并且可以在多种语言中使用(C++、Java 等) 然而用户仍然需要手写解析代码。 随着系统的演化，他需要一些其他的功能: 自动生成编码和解码代码，而无需自己编写解析器。 除了用于简短的 RPC(Remote Procedure Call)请求，人们使用 ProtocolBuffer来做数据存储格式(例如 BitTable)。 RPC服务器接口可以作为 .proto 文件来描述，而通过 ProtocolBuffer的编译器生成存根(stub)类供用户实现服务器接口。 ProtocolBuffers 现在已经是 Google 的混合语言数据标准了，现在已经正在使用的有 超过48,162种报文格式定义和超过12,183个 .proto 文件。他们用于 RPC 系统和持续数据存 储系统。 环境安装下载官方下载网站 安装12345tar -zxvf protobuf-2.5.0.tar.gzcd protobuf-2.5.0./configure --prefix=$INSTALL_DIRmakemake install 更详细的安装步骤请参考源码目录下的 README.txt。 安装完后在INSTALL_DIR目录下生成三个目录: 1bin include lib bin目录下是protoc工具，用于将你的.proto 文件编译成相应目标语言的编解码代码。include和lib目录是protoc工具所依赖的头文件与库环境。 利用protoc工具编译成目标语言编译前，先准备你的.proto 文件，这里暂时以源码目录下的 examples/addressbook.proto 文件为例。 protoc 用法: 1Usage: ./protoc [OPTION] PROTO_FILES 详情请使用 1./protoc --help 开始将你的.protoc 文件编译成目标语言编解码文件: 12mkdir c java python./protoc --proto_path=./ --cpp_out=c/ --java_out=java/ --python_out=python/ addressbook.proto 官方的 protoc 工具仅支持C++/java/python三种语言，如果你使用其他语言，比如 c#，php，你可以使用其他第三方工具。命令简介: 1./protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto 其中: 123--proto_path:.proto 所在的路径--cpp_out:生成 C++代码的路径--java_out:生成 java 代码的路径--python_out:生成 python 代码的路径 Python如何使用protocol buffers安装 python 的 pb 库:在 protobuf 源码目录下可以找到一个目录python，没错，你需要进入此目录安装python的pb库。 12cd protobuf-2.5.0/python$PYTHONHOME/bin/python setup.py install --prefix=$PYTHONHOME 使用–prefix 选项指定你 python 的安装目录，然后静待安装完成。以下是安装时常见的错误: 安装提示 error: package directory ‘google/protobuf/compiler’ does not exist 解决办法： 执行mkdir google/protobuf/compiler 创建compiler目录即可。 TBD 安装完 python 的 pb 库后，你就可以在源码的 examples 目录中，使用 add_person.py 和 list_people.py 来测试如何使用 pb 序列化与反序列化了。序列化与反序列化的相关接口 分别为 SerializeToString()和 ParseFromString()。 更多 python 相关的 api 请看protocol-buffers/docs/reference/python/index。 其他语言如何使用protocol buffersTBD 语言指导消息定义在.proto 文件里面用 Protocol Buffers 消息类型进行定义，每一个 Protocol Buffers消息是信息的一条小的逻辑记录，里面包含一系列名称-值对。下面是一个简单的.proto 文件: 12345message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;&#125; 字段类型可以是基本类型，例如整形、浮点型，值类型可以是其他的 Protocol Buffers 的消息类型，这样你可以用分层的方式定义你的数据结构。 分配字段Tag(标记)每个字段必须有一个唯一的标记，这个标记在序列化时会作为字段的标识出现在序 列化后的二进制数据中。一旦该消息用于生产，字段的 tag 就不能修改了。标记的值小 于15时序列化编码为一个字节，大于15会用到两个以上的字节。 指定字段的规则消息的字段可以具有以下类型的属性: required: 消息中必须包含一个该字段的值 optional: 可选字段，消息中可以有0个或一个该字段的值 repeated: 重复字段，消息中可以有0个或多个该字段的值 选择字段规则的建议你可以在你的消息格式里面添加新的域，而不用考虑向后兼容性，老的二进制流在 解析的时候可以简单的忽略掉新增的域。因此如果你使用 Protocol Buffers 作为你数据 格式的通信协议时，你可以扩展你的协议，而不用担心破坏现有的代码。对于 required，尽可能的少用，若一个字段开始时指定为 required，则以后就不能 修改为 optional。建议将字段设置都设置为 optional 类型，这样字段的 required 规则可以放在业务代码中进行处理。 增加更多的消息类型在单个 .proto 文件里可以定义多种消息类型: 123456789message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;&#125;message SearchResponse &#123; ...&#125; 注释.proto 文件使用 C/C++的注释风格: 12345message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; // Which page number do we want? optional int32 result_per_page = 3; // Number of results to return per page.&#125; 数值类型下表列举了 pb 协议数据类型与 C++/Java/Python 语言的类型对应关系: .proto Type Notes C++ Type Java Type Python Type[2] double double double float float float float float int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int int int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 long int/long[3] uint32 Uses variable-length encoding. uint32 int[1] int/long[3] uint64 Uses variable-length encoding. uint64 long[1] int/long[3] sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long[3] fixed32 Always four bytes. More efficient than uint32 if values are often greater than 228. uint32 int[1] int fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 256. uint64 long[1] int/long[3] sfixed32 Always four bytes. int32 int int sfixed64 Always eight bytes. int64 long int/long[3] bool bool boolean boolean string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode[4] bytes May contain any arbitrary sequence of bytes. string ByteString str 你可以在protocol-buffers/docs/encoding找到这些类型在 pb 序列化时是如何被编码的。 [1] 在 Java, unsigned 32-bit and 64-bit integers 都是使用最高位表示符号位，而无符号位部分是一样的。 [2] 所有情况下，赋值操作会触发类型检查以保证可用性。 [3] 64-bit or unsigned 32-bit integers 会被解码为 long 类型，但如果在赋值时使用 int 类型的话，解码后可以是 int 类型。任何情况下，值必须与被赋值时一样。见[2]。 [4] Python strings 类型在解码后是 unicode 类型，但如果原始字符串是 ASCII 编码的话也可能是 str 类型。 可选字段规则与默认值一个消息字段可以使用 optional 规则来限定，表示该字段是可选类型，即该消息可以 包含该字段也可以不包含该字段。当一个消息被解析时，如果序列化数据没有包含 optional 字段，则该字段会使用默认值来代替。默认值可以显式指定如下: 1optional int32 result_per_page = 3 [default = 10]; 如果没有显式指定默认值，则使用数据类型的默认值来代替:比如，字符串类型的默认值是空字符串，布尔类型的默认值是 false，数字类型的默认值是0，枚举类 型的默认值是第一个被定义的枚举值。 枚举类型使用 enum 关键字定义枚举类型，比如你想定义一个叫 Corpus 的枚举类型: 123456789101112131415message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3 [default = 10]; enum Corpus &#123; UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; &#125; optional Corpus corpus = 4 [default = UNIVERSAL];&#125; 使用其他消息类型你可以使用其他的消息类型来定义你的消息字段，以构成各种复合类型，比如 SearchResponse 消息里定义了一个 Result 消息类型的字段: 123456789message SearchResponse &#123; repeated Result result = 1;&#125;message Result &#123; required string url = 1; optional string title = 2; repeated string snippets = 3;&#125; 另外，你还可以使用 import 语句导入其他.proto 文件定义的消息类型。 包含路径的 import: 1import &quot;myproject/other_protos.proto&quot;; 不包含路径的 import: 12import public &quot;new.proto&quot;;import &quot;other.proto&quot;; 当使用 public 域 import 时，编译器会去 -I/–proto_path 标志指定的路径去查找，如果没有指定此标志，它会去编译器目录索引。通常情况下，建议你使用 –proto_path 指 定为项目的根路径，并且使用全名（包含命名空间或包名）import。 命名风格良好的命名风格让你的.proto 文件更加易读。 消息以及字段名称使用 CamelCase 方式命名消息名称，使用下划线分隔的名字来命名消息的字段，例如: 123message SongServerRequest &#123; required string song_name = 1;&#125; 枚举类型使用 CamelCase 方式命名消息名称，例如 PhoneType 使用大写字母+下划线来命名枚举值，例如: 12345enum PhoneType &#123; TYPE_MOBILE = 0; TYPE_HOME = 1; TYPE_WORK = 2;&#125; 服务如果你的.proto 文件定义了 RPC 服务，你可以使用 CamelCase 的方式命名你的服务名与RPC 方法名: 123service FooService &#123; rpc GetSomething(FooRequest) returns (FooResponse);&#125; 编码原理本节主要介绍 protocol buffer 消息转换成二进制格式的原理。如果仅需要了解怎么使 用 protocol buffers，你可以无需理解这些原理，但了解这些能帮助你理解 protocol buffers 对编码后数据大小的影响。 一个简单的消息下面是一个简单的消息定义: 123message Test1 &#123; required int32 a = 1;&#125; 若你创建了一个 Test1的消息，然后 a 赋值为150，序列化后，你会发现消息被编码为 下面3个字节: 108 96 01 看起来非常小巧与数字化，但它代表什么意义?继续看下去，好戏还在后头…… 变长整型(varint)为了理解 protocol buffer 的编码原理，你首先需要理解 varint 的概念。Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小 的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。注意，采用 Varint 表示法，大的数字则需要更多个 byte 来表示。从统计的角度来说，一般不会所有消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。Varint 中的每个 byte 的最高位 most significant bit (msb) 有特殊的含义，如果 该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示:1010 1100 0000 0010，以下是它的解码过程: 首先按照字节分组: 11010 1100 0000 0010 去掉 msb 1010 1100 000 0010 将字节反向排列 1000 0010 010 1100 重新组合成字节 1000 001 0010 1100 → 100101100=300 消息结构一个 protocol buffer 消息是一系列的键-值对。序列化后的二进制消息仅使用字段数字为 key。当消息被编码后，键值对被组织成一个字节流。消息在解码后，解析器能够忽略不认识 的字段。按照这样的方式，旧程序能够忽略不认识的新增字段。最后，”key”实际上是由两个值组成的，其中一个是.proto 文件的字段数字标号，另外一个是 wire types，这样才 能提供足够的信息去找到接下来数据的长度。下面是可用的wire types: Type Meaning Used For 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimited string, bytes, embedded messages, packed repeated fields 3 Start group groups (deprecated) 4 End group groups (deprecated) 5 32-bit fixed32, sfixed32, float 每个消息流的 key 都是一个 varint 类型，它的值为(field_number &lt;&lt; 3) | wire_type 。换句话说，最后三位用于保存 wire type 。 比如 key 是08，去掉 msb 位后如下: 1000 1000 则field_number 和 wire type 分别为: 12field_number=0001wire_type=000 更多的值类型带符号整数在前面的例子中，所有的 protocol buffer 类型都是 wire type 0的 varints 类型。然 而，带符号整数 (sint32 and sint64)与标准的整型(int32 and int64)在编码时有很大的 区别。如果你使用 int32 或者 int64来表示一个负数，结果需要10个字节，因为它会被认为 是一个非常大的无符号整数。为此，对带符号整数使用 ZigZag 编码会更高效。ZigZag 编码用无符号数来表示有符号数字，正数和负数交错，这就是 zigzag 这个词 的含义了。使用 zigzag 编码时，与0距离越近，编码时使用的值越小，从统计意义层面来看， 这样编码更高效，因为数据通信中绝对值小的数据交互占的比例要高。下面是 ZigZag 的编 码表: Signed Original Encoded As 0 0 -1 1 1 2 -2 3 2147483647 4294967294 -2147483648 4294967295 换句话说，每个值 n 都使用以下方式编码: 12sint32:(n &lt;&lt; 1) ^ (n &gt;&gt; 31)sint34:(n &lt;&lt; 1) ^ (n &gt;&gt; 63) 注意到第二个位移部分(n &gt;&gt; 31)实际上是算术位移，所以若 n 是正数，算术位移后得到的数全部位都是0，若 n 是负数，算术位移后得到的数全部位都是1。 当 sint32或 sint64被解析时，它的值会被解码回原始的带符号数。 非 varint 数非 varint 的数据类型就非常简单了， double 和 fixed64是 wire type 1，它会告诉解 析器期望的是一个固定的64位数据块;类似的，float 和 fixed32是 wire type 5，它会告 诉解析器期望的是一个固定的32位数据块。无论何种情况，值都是以 little-endian 小端对 齐的字节顺序方式存储。 字符串wire type 2 (length-delimited) 意思是它的值先使用一个 varint 来表示编码后的 数据大小，而接下来就是相应长度的编码数据了。 123message Test2 &#123; required string b = 2;&#125; 设置 b 的值为”testing”，你会得到下面编码: 112 07 74 65 73 74 69 6e 67 分析 key，首先第一个字节12为: 10001 0010 msb 为0，表示 key 仅用一个字节表示，去掉 msb: 1001 0010 根据 key 的解码办法，得到: 12field_number = 0010 = 2wire_type = 010 = 2 分析第二个字节07，根据 varint 编码可知数据长度为7，然后紧跟后面的7个字节则为 “testing”。 嵌套消息下面 Test3是一个嵌套消息: 1234567message Test1 &#123; required int32 a = 1;&#125;message Test3 &#123; required Test1 c = 3;&#125; 如果将 Test1的 a 字段赋值为150，则得到下面的编码: 11a 03 08 96 01 还记得编码原理刚开始提到的“一个简单的消息”吗?后面3个字节是否似曾相识？而Test3是嵌套消息，它的 wire type = 2，请参照该类型的编码办法即可解码。 可选与重复元素Optional 可选字段optional 可选元素在消息编码时可以有0或者1个键值对。 Repeated 重复字段Repeated 字段序列化时，序列化的结果中包含0个或多个 key-value，每个 key-value 都包含字段的 tag。PB2.1.0版本中提供了另外一种 Repeated 字段，即带有[packed=true]属性的 Repeated 字段，这种字段又称为:packedrepeated field。packed repeated field 字段序列化时，有0个或多个元素，并且所有的 元素打包在一个 key-value 中，key-value 的类型采用 wire type 2 (length-delimited)，每个元素不需要提供各自的 tag。下面是一个例子: 123message Test4 &#123; repeated int32 d = 4 [packed=true];&#125; 序列化字节码: 1234522 // tag (field number 4, wire type 2)06 // payload size (6 bytes)03 // first element (varint 3)8E 02 // second element (varint 270)9E A7 05 // third element (varint 86942) 相关序列化与反序列化技术的性能比较本章节内容摘自thrift-protobuf-compare。作者提到，数值并非一切，仅供参考，实际上测试结果会受硬件，测试用例等影响。 总耗时(包括对象创建，序列化与反序列化): 序列化时间(每次序列化的时间，包括对象创建时间): 反序列化时间: 序列化大小: 对象创建时间: 从上面的数据来看，protocol buffers 在序列化与反序列化性能及序列化后的数据大 小方面都不有错的表现。 参考资料 https://developers.google.com/protocol-buffers/Protocol-buffers 的官方介绍，本教程的主要参考资料。 http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/Protocol Buffers 原理的中文介绍。 http://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking#Object_Creation_Time Protocol Buffers 与其他相关技术的性能对比。 http://www.cppblog.com/liquidx/archive/2009/06/23/88366.html http://blog.csdn.net/hguisu/article/details/20721109]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>PB</tag>
        <tag>Protocol Buffers</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The background of this blog]]></title>
    <url>%2F2017%2F07%2F23%2FThe-background-of-this-blog%2F</url>
    <content type="text"><![CDATA[欢迎浏览本博客。作为第一篇非技术类的文章，可能没什么干货分享，但总感觉应该写点什么。好吧，就谈谈开博背景！ 自由。本人喜欢自由的写作，在其他博客平台，总有各种各样的限制，比如审核。自己的博客，样式随便改。 简洁。喜欢MarkDown的简洁，也喜欢简洁的博客主题。 分享。无他，写博客就为了分享。当然，这也是大家相互学习的一种有效途径。 精彩。人生在世，不过短短几十年，我们不是什么伟人，但这可以记录我们的精彩。 战斗吧，兄弟！]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hello World</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
