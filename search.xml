<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RTMP协议规范_1.0]]></title>
    <url>%2F2017%2F11%2F19%2FRTMP%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83-1-0%2F</url>
    <content type="text"><![CDATA[译注本文档主要翻译于rtmp specification 1.0。 绝大部分使用直译，小部分使用意译。专有名词基本不翻译，既保留规范的原意，又不会感觉翻译起来怪怪的。 IntroductionAdobe’s Real Time Messaging Protocol (RTMP)通过一个可靠的流传输通道提供双向的消息复用服务，流传输通道类似于 TCP [RFC0793]，目的是在通信双方之间并行传输带有关联时间信息的音视频流和数据消息。实现通常按不同类型的消息分配不同的优先级，从而在传输带宽受限时可以影响消息在底层流传输通道的入队顺序。本文档描述了实时消息传递协议的语法和操作。 Terminology本文档中的关键词，”MUST”、”MUST NOT”、”REQUIRED”、”SHALL”、”SHALL NOT”、“SHOULD”、”SHOULD NOT”、”RECOMMENDED”、”NOTRECOMMENDED”、”MAY”和”OPTIONAL”，都在[RFC2119]中解释描述。 ContributorsRajesh Mallipeddi，Adobe System 原成员，起草了本文档原始规范，并提供大部分的原始内容。Mohit Srivastava，Adobe System 成员，推动了本规范的发展。 DefinitionsPayload：包含在一个包中的数据，比如音频采样数据或者视频压缩数据。有效载荷的格式和解释超出了本文档的范围。Packet：一个数据包由固定头 header 和 payload 数据组成。一些底层的协议可能需要定义该数据包的封装。Port：传输协议用来区分在一个给定的主机内的多个目的地的抽象。TCP/IP协议使用小正整数来识别端口。OSI 传输层使用的传输选择器（TSEL）相当于端口。Transport address：网络地址和端口的组合用来识别一个传输层级别的端点，比如一个IP 地址和TCP 端口。包从源Transport address 传输到目标的Transportaddress。Message stream：消息流的逻辑传输通道。Message stream ID：每个消息都有一个与它相关联的 ID，以确定它的流在哪个消息流中。Chunk：一段消息。消息被拆分成小的部分并且它们在网络发出去之前被转换。Chunk stream：允许在一个特定方向上 chunk 流动的通信的逻辑通道。chunkstream 可以从客户端传输到服务器或者反过来传输。Chunk stream ID：每一块 chunk 都有一个与它关联的 ID，以标识它所在的chunk stream。Multiplexing：使单独的音频/视频数据转换成一个连贯的音频/视频流的过程，使得有可能同时传输多个视频和音频。DeMultiplexing：多路传输的反向过程，其中交错的音频和视频数据被组装成原始的音频和视频数据。Remote Procedure Call (RPC)：允许客户端或服务器在对等端调用子程序或过程的请求。Metadata：关于数据的描述。视频的元数据包括视频名称、持续时间、创作日期等。Application Instance：服务器上的应用程序实例，客户端连接通过它来发送连接请求。Action Message Format (AMF)：一个紧凑的二进制格式，用于序列化的ActionScript 对象图。AMF 有两种版本：AMF 0 [AMF0]和 AMF 3 [AMF3]。 Byte Order, Alignment, and Time Format所有的整型字段都使用网络字节序传输，字节 0 为第一个字节，第 0 位在一个字或字段中是最重要的位。这种字节顺序俗称为大端模式。这种传输顺序在 IP 协议[RFC0791]中详细描述。如果没有另外说明，本文档中的数字常量都是十进制。除非另有规定，RTMP 的所有数据都是字节对齐的；例如，一个 16 位的字段可能在一个奇数的字节偏移上。该位置如果指定填充，则填充字节值应该为零。时间戳在 RTMP 是作为一个相对于未知时期的毫秒整数。通常，每个流将以时间戳 0 作为开始，但这不是必需的，只要两端在时间基准能达成一致即可。注意，这意味着任何在多个流的同步（尤其是独立的主机）需要一些 RTMP 之外的机制协助。因为时间戳是 32 位长，他们每过 49 天，17 小时，2 分钟，47.296 秒就会轮转。因为数据流允许连续地，甚至可能多年不断地运行，一个 RTMP 应用在处理时间戳时应该使用序列号算法[RFC1982]，并且应该能够环绕式处理。 例如， 一个应用程序假定所有相邻的时间戳在 2 ^ 31 - 1 毫秒内都是彼此相邻的，所以10000 在 4000000000 后面，3000000000 在 4000000000 的前面。相对之前提到的时间戳，时间戳增量也可以表示为无符号整数的毫秒。时间戳增量可能是 24 或 32 位长。 RTMP Chunk Stream本节详述实时消息协议块流（RTMP 流块）。它为更高层次的多媒体流协议提供了复用和打包服务。虽然 RTMP 块流设计工作于实时消息协议（第 6 节），但它可以处理任何发送一个消息流的协议。每个消息包含时间戳和 payload 类型识别。RTMP ChunkStream 和 RTMP 是适合多种音视频应用，包括一对一和一对多的直播点播服务， 交互式视频会议应用。当使用一个可靠的传输协议如 TCP [RFC0793]，RTMP Chunk Stream 提供有保障的，按时间戳顺序的，端到端的，跨多个流的所有消息传输。RTMP Chunk Stream 不提供任何优先级控制或类似的形式，但可以通过更高级别的协议提供这样的优先级顺序。例如，基于每一个消息的发送或确认时间，一个实时视频服务器可能会选择放弃一个缓慢的客户端视频消息，以确保音频消息是及时收到的。RTMP Chunk Stream 包括自带的协议控制信息，并且还为更高级别的协议嵌入用户控制消息提供了一种机制。 Message Format消息可以分割成多个 chunk 的格式，以支持取决于一个更高级别协议的复用。然而，消息格式应该包含用于创建 chunk 的以下字段。Timestamp：消息的时间戳。这个字段可以传输 4 个字节。Length：消息 payload 的长度。如果消息头不能省略，它应该包括在该长度中。此字段在 chunk header 中占用 3 个字节。Type Id：一系列的类型 ID 被保留用于协议控制消息。这些传播信息的消息通过 RTMP Chunk Stream 协议和高层协议处理。所有其他类型的 ID 对高级别的协议是可用的，并被 RTMP Chunk Stream 视为不透明数值。事实上，在 RTMP Chunk Stream 中没有要求这些值被用来作为一个类型；所有（非协议）消息可能是同一类型，或应用程序可以使用此字段来区分同步轨道而不是类型。此字段占用 chunk header 中的 1 个字节。Message Stream ID：消息流 ID 可以是任意的值。同一 Chunk Stream 上的不同的多路复用消息流是基于它们的消息流 ID 进行多路解码的。除此之外，据RTMP Chunk Stream 而言，这是一个不透明的值。这个字段以小端格式在 chunk header 中占用 4 个字节。 HandshakeRTMP 连接以握手为开始。握手不同于协议的其余部分，它由三个静态大小的 chunk，而不是由可变大小的带有头的 chunk 组成。客户端（已启动连接的端点）和服务器每方都分别发送相同的三个 chunk。为了方便表达，当由客户端发送时，这些 chunk 将被命名为 C0，C1 和 C2；当由服务器发送时，它们被命名为 S0，S1，S2。 Handshake Sequence握手开始，客户端发送 C0，C1 chunk。客户端必须等到 S1 收到之后才能发送 C2。客户端必须等到 S2 收到之后才能发送其他数据。 服务器必须等到 C0 或可能 C1 收到之后才能发送 S0 和 S1。服务器必须等到 C1 收到之后才能发送 S2。服务器必须等到 C2 收到之后才能发送其他数据。 C0 and S0 FormatC0 和 S0 包是一个单字节，视为一个单一的 8 位整数字段：以下是 C0/S0 包的字段：Version（8 位）：在 C0，此字段标识客户端所请求的 RTMP 协议版本。在S0，此字段标识服务器选择的 RTMP 协议版本。本规范定义的版本号为 3。值0-2 由先前专有产品使用，现已弃用；4-31 留待将来实现；32-255 不允许使用（以区分 RTMP 和文本协议，因为它总是以一个可打印字符为开始）。当识别不出客户端请求的版本时，服务器应该响应版本号 3。客户端可能会选择降级到版本3，或放弃握手。 C1 and S1 FormatC1 和 S1 包都是 1536 个字节长，包括以下字段：Time （4 字节）：本字段包含一个时间戳，这应该作为未来从这个端点发出的所有块的时间基准。这可能是 0 ， 或一些任意的值。为了同步多个chunkstream，此端点可能要发送其他 chunkstream 的时间戳的当前值。Zero（4 个字节）：这个字段必须都是 0。Random data （1528 个字节）：此字段可以包含任何任意值。由于每个端点必须区分它发起的握手的应答和对端发起的握手，这个数据应该发送足够随机的东西。但不需要加密的安全性，甚至不需要动态值。 C2 and S2 FormatC2 和 S2 包都是 1536 个字节长，几乎是 S1 和 C1 的复制（分别地），它们包括以下字段： Time（4 个字节）：该字段必须包含对方包内的发送时间戳，它分别在 S1（ 对 于 C2） 或 C1（ 对 于 S2） 。Time2（4 个字节）：该字段必须包含对方前面的包（S1 或 C1）被读取的时间戳。Random echo（1528 个字节）：该字段必须包含对方发送的包（S1 或 C1） 的随机数字段，分别在 S1（对于 C2）和 C1（对于 S2）。每个端都可以使用 time 和 time2 字段与当前时间戳作为连接的带宽和/或延迟的快速评估，但这不太可能有用。 Handshake Diagram 下面介绍握手图中所提到的状态：Uninitialized：协议版本号在这个阶段中发送。客户端和服务器都是未初始化。该客户端在 C0 包发送协议版本号。如果服务器支持该版本，它将应答 S0 和 S1。如果没有，服务器响采取适当的行为应答。在 RTMP，这个动作是终止连接。Version Sent：在未初始化状态之后，客户端和服务器都处在发送版本号的状态。客户端正在等待包 S1，而服务器等待包 C1。在收到期待的包之后，客户端发送数据包 C2 而服务器发送数据包 S2。然后状态就变成 Ack Sent。Ack Sent：客户端和服务端分别等待 S2 和 C2。Handshake Done：客户端和服务器可以交换消息的状态。 Chunking在握手之后，连接多路复用一个或多个 chunk stream。每个 chunk stream 都从一个消息流中传送一个类型的消息。创建的每个 chunk 都有一个与它关联的唯一标识，称为块流标识（chunk stream ID）。chunk 在网络上传输。在传输的过程中，每一个 chunk 必须在下一个 chunk 之前全部发送。在接收端，chunk 被组装成基于 chunk stream ID 的消息。chunk 允许更高层协议上的大消息分解成较小的信息，例如防止大的优先级低的消息（如视频）阻塞小的高优先级的消息（如音频或控制）。chunk 也让小消息以较小的开销被发送，因为 chunk header 包含压缩指示的信息，否则将被包含在消息本身。chunk 大小是可配置的。它可以使用 chunk 大小控制消息来设置（第 5.4.1 节）。较大的 chunk 大小降低了处理器的使用率，但也导致更大的写入，在连接带宽较低时，可以延迟其他内容。较小的 chunk 不适合高比特率的流。chunk 大小在每个方向上都是独立维护的。 Chunk Format每一个 chunk 都包含头部和数据。头本身有三个部分： Basic Header（1 到 3 个字节）：此字段对 chunk stream ID 和 chunk type 进行编码。chunk type 决定 message header 的编码格式。它的长度完全取决于 chunk stream ID，这是一个可变长度的字段。Message Header（0，3，7 或者 1 个字节）：该字段对发送的消息进行编码（无论是在整体还是部分）。长度可以用 chunk header 中指定的 chunk type 来确定。Extended Timestamp（0 或者 4 个字节）：这个字段在一定情况下出现，取决于 Chunk Message header 中编码的时间戳或时间戳差量。更多信息见 5.3.1.3 节。Chunk Data（变长大小）：此 chunk 的有效负载，大小不超过配置的最大块大小。 Chunk Basic HeaderChunk Basic Header 编码 chunk stream ID 和 chunk 类型（按下图 FMT 字段表示）。chunk 类型决定已编码的消息头的格式。Chunk Basic Header 字段可能是 1，2，或 3 个字节，这取决于 chunk stream ID。一个实现应该使用可以保存 ID 的最小表示（按需编码）。该协议使用 3-65599 的 ID 支持多达 65597 个流。0，1，和 2 的 ID 是保留值。值 0 表示 2 字节的形式，并且 ID 在 64-319 的范围（第二字节+64）。值 1 表示 3 字节的形式，并且 ID 在 64-65599 的范围（第三字节×256+第二个字节+64）。值范围为 3-63 代表完整的 chunk stream ID。值为 2 的 chunk stream ID 是为低层协议控制信息和指令保留。位 0-5（最重要的）在 Chunk Basic Header 中代表 chunk stream ID。chunk stream ID 2-63 可在这个字段用 1 字节的版本编码。 chunk stream ID 64-319 可以在此头部用 2 字节的形式编码。ID 的计算方法为（第二个字节+64）。 chunk stream ID 64-65599 可以在此字段用 3 字节版本编码。ID 的计算方法为（第三字节*256+第二字节+64）。 cs id（6 个字节）：本字段包含 chunk stream ID，值从 2-36。值 0 和 1 表示此字段的 2 或 3 字节版本。fmt（2 个字节）：该字段标识“chunk message header”所使用的四种格式之一。每个 chunk 类型的“chunk message header”在下一节中解释。cs id - 64（8 或者 16 个字节）：此字段包含 chunk stream ID 减去 64 的值。例如，ID 365 将由 cs id 为 1，和这里（cs id - 64）的一个 16 位的 301 表示。chunk stream ID 值 64-319 可以由 2 或 3 字节形式的头表示。 Chunk Message Header有四种不同格式的 chunk message header，由在 chunk basic header 的“fmt” 字段决定。一个实现应该使用可能为每个 chunk message header 的最紧凑的表示。 Type 0类型0 的chunk header 是11 个字节长。这种类型必须使用在一个chunk stream的开始，必要时，流时间戳可以后退（例如，由于回退定位）。 timestamp（3 个字节）：对于一个类型 0 的 chunk，消息的绝对时间戳就在这里发送。如果时间戳大于或等于 16777215（十六进制 0xFFFFFF），该字段必须为 16777215，表明扩展时间戳（Extended Timestamp）字段编码的出现，以能够编码完整的 32 位时间戳。否则，这个字段应该是整个时间戳。 Type 1类型 1 的 chunk header 是 7 个字节长。不包含 message stream ID；此 chunk 采用与前面的 chunk 相同的流 ID。具有可变大小的消息的流（例如，许多视频格式）应该使用这个格式作为第一个之后的每一个新消息的第一个 chunk。 Type 2类型 2 的 chunk header 是 3 个字节长。既不包含流 ID，也不包含消息长度， 该 chunk 与前面的 chunk 具有相同的流 ID 和消息长度。具有常量大小的消息流 （例如，一些音频和数据格式）应该使用这个格式作为第一个之后的每一个消息的第一个 chunk。 Type 3类型 3 的 chunk 没有消息头。流 ID、消息长度和时间戳增量字段都不存在； 这种类型的 chunk 采用与前面 chunk 相同的 Chunk Stream ID。当一个独立的消息被分成 chunk，除了第一个 chunk 之外，所有的消息 chunk 应该使用这种类型。参考实例 2（5.3.2.2 节）。一个由完全相同大小，流 ID 和时空消息组成的流在类型 2 的 chunk 之后应该都使用该类型的 chunk。参考实例 1（5.3.2.1 节）。如果第一消息和第二消息的差量与第一个消息的时间戳是相同的，然后类型 3 的chunk 可以立即跟随类型 0 的 chunk，因为无需一个类型 2 的 chunk 表示该差量。如果一个类型 3 的 chunk 跟随着类型 0 的 chunk，然后类型 3 的 chunk 的时间戳差量与类型 0 的 chunk 的时间戳相同。 Common Header Fieldschunk message header 中每个字段的描述：timestamp delta（3 个字节）：对于类型 1 或类型 2 的 chunk，前面 chunk 的时间戳和当前 chunk 之间的区别就在此发送。如果差量大于或等于 16777215（十六进制 0xFFFFFF），该字段必须为 16777215，表明 Extended Timestamp 字段的出现，以编码整个 32 位的时间戳。否则，这个字段应该是整个时间戳。message length（3 个字节）：对于一个类型 0 或类型 1 的 chunk，消息的长度在此发送。请注意，这通常与 chunk payload 的大小是不一样的。chunk payload 的长度是除了最后一个 chunk 的所有 chunk 的最大大小，剩余部分（对于小消息来说，可能是整个长度）就是最后 chunk 的大小。message type id（1 个字节）：对于类型 0 或类型 1 的 chunk，消息的类型在此发送。message stream id（4 个字节）：对于一个类型 0 的 chunk，它存储的是 message stream ID。Message stream ID 以小端格式存储。通常情况下，相同 chunk stream 中的所有消息都来自于同一个 message stream。虽然将 message stream 多路分离成相同的 chunk stream 是可能的，但它的效果比头部压缩的要差。然而，如果一个 message stream 关闭而另一个随后打开，但决没有理由说一个现有的 chunk stream 不能通过发送一个新的类型 0 的 chunk 以被重用。 Extended TimestampExtended Timestamp 字段是用来编码大于 16777215（0xFFFFFF）的时间戳或时间戳增量；也就是说，它是对于类型 0，1 或者 2 的 chunk 中 24 位的时间或时间戳增量满足不了的情况而设计的。这个字段编码完整的 32 位时间或时间戳增量。这个字段的出现表示对于 16777215（0xFFFFFF）的情况，设置类型 0 的chunk 的时间戳或者类型 1、类型 2 的 chunk 的时间戳增量。当最近相同 chunk stream ID 的类型 0，1，或 2 的 chunk 指示存在 extended timestamp 字段时，这个字段在类型 3 的 chunk 中出现。 ExamplesExample 1这个例子显示了一个简单的音频信息流。这个例子演示了信息的冗余。下一个表格演示了在该流中产生的chunk。从消息3起，数据传输优化了。过了这一点之后 ，每个消息（头）只有1个字节的开销。 Example 2此示例说明了一个消息因为太长，以至于无法适用一个128字节的chunk，从而被分解成多个chunk。这里是产生的chunk：Chunk 1的头数据指定了整个消息是307个字节。从两个例子中注意到，类型3的chunk可以用在两种不同的方式中。第一种是指定消息的继续。第二种是指定一个新的消息的开始，它的头可以来自于现有的状态数据。 Protocol Control MessagesRTMP Chunk Stream使用消息类型ID 1，2，3，5，和6来做协议控制消息。这些消息包含了RTMP Chunk Stream协议所需的信息。这些协议控制消息必须有message stream ID 0（被称为控制流），并以chunk stream ID 2被发送。协议控制信息一经被收到后立马生效，它们的时间戳是被忽略的。 Set Chunk Size (1)协议控制消息1，Set Chunk Size，用于通知对端一个新的最大chunk大小。最大chunk大小默认为128字节，但客户端或服务器可以更改此值，并使用此消息更新其对端的状态。例如，假设一个客户端要发送131个字节的音频数据，并且chunk大小为128字节。在这种情况下，客户端可以将此消息发送到服务器，通知它，chunk大小现在为131个字节。然后，客户端可以在一个chunk中发送该音频数据。最大chunk大小应该至少有128个字节，并且必须至少是1个字节。最大chunk大小是独立于每个方向保持的。0：这个位必须是0。chunk size（31个字节）：此字段保存了新的最大chunk大小，以字节为单位，它将用于所有的发送端的后续chunk，直到进一步通知。有效大小为1到2147483647（0x7FFFFFFF），包括2147483647本身；然而，所有大小大于16777215（0xFFFFFF）是等价的，因为没有chunk大于一个消息，没有消息大于16777215个字节。 Abort Message (2)协议控制消息2，Abort Message，用于通知对端，如果它是等待chunk来完成一个消息，然后丢弃在一个chunk stream上收到的部分消息。该端接收chunk stream ID作为该协议消息的payload。应用程序可以在关闭时发送此消息，以指示不需要进一步处理消息。chunk stream ID（32位）：这个字段保存了当前将被丢弃消息的chunk stream ID。 Acknowledgement (3)客户端或服务器必须在接收到等于窗口大小的字节后向对端发送一个acknowledgment确认。窗口大小是发送端没有从接收端接收到确认前发送的最大字节数。此消息指定了序列号，它是到目前为止接收到的字节数。sequence number（32个字节）：这个字段保存到目前为止接收到的字节数。 Window Acknowledgement Size (5)客户端或服务器发送此消息通知对方发送Acknowledgement之间的窗口大小。该发送端希望在它发送了窗口大小的字节数之后，从对端收到Acknowledgement。自上次Acknowledgement发送后，接收端接收指定的字节数后必须发送一个Acknowledgement（第5.4.3节），否则如果Acknowledgement还没有被发送，会话得从新开始。 Set Peer Bandwidth (6)客户端或服务器发送此消息以限制其对端的输出带宽。该端收到此消息后，通过限制未确认数据的发送量以达到输出带宽限制的目的，直到数据量达到此消息指定的窗口大小为止。该端收到此消息后，如果窗口大小与发送端上次发送该消息的不一样，它应该应答一个Window Acknowledgement Size的消息。Limit Type是下列值之一：0 - Hard：该端应该限制它的输出带宽，直到指定的窗口大小为止。1 - Soft：无论哪一个的窗口更小，该端应该限制它的输出带宽直到此消息指定的窗口大小为止或者直到该限制已经有效果为止。2 - Dynamic：如果前一个是硬限制类型，那么此消息被认为是硬限制类型，否则忽略此消息。 RTMP Message Formats此节说明RTMP消息的格式。它基于使用更低级的传输层网络在实体之间传输，例如RTMP Chunk Stream。虽然RTMP被设计于用RTMP Chunk Stream工作，但它可以使用任何其他的传输协议发送消息。RTMP Chunk Stream和RTMP是适合多种音视频应用，包括一对一和一对多的直播点播服务，交互式视频会议应用。 RTMP Message Format服务器和客户端通过网络发送RTMP消息来彼此通信。该消息可以包括音频、视频、数据或任何其他消息。RTMP消息有两部分，一个头部和有效载荷。 Message Header消息头包含以下部分：Message Type：1个字节字段以表示消息类型。范围1-6的ID类型被保留用作协议控制消息。Length：3个字节的字段，表示payload的字节大小。它被制定为大端格式。Timestamp：4个字节的字段，它包含该消息的时间戳。这4个字节以大端字节序封包。Message Stream Id：3个字节的字段，标识消息流。这几个字节被制定为大端格式。 Message Payload消息的另一部分是有效负载payload，这是消息中包含的实际数据。例如，它可以是一些音频采样或压缩的视频数据。payload的格式和解释超出了本文档的范围。 User Control Messages (4)RTMP使用ID为4的消息类型作为用户控制消息。这些消息包含了RTMP streaming层使用到的信息。ID 1，2，3，5和6的协议消息被用于RTMP Chunk Stream协议（第5.4节）。用户控制信息应该使用message stream ID 0（称为控制流），当基于RTMP Chunk Stream发送时，它被用chunk stream ID 2来发送。用户控制信息在流中被收到时立马生效；它们的时间戳被忽略。客户端或服务器发送此消息以通知对端用户控件事件。此消息传输事件类型Event type和事件数据Event data。前2个字节的消息数据用于标识事件类型。事件类型之后就是事件数据。事件数据字段的大小是可变的。然而，在消息通过RTMP Chunk Stream层传输的情况下，最大chunk大小（第5.4.1节）应该足够大，以让这些消息放在一个chunk中。事件类型和事件数据在第7.1.7节中列举。 RTMP Command Messages本节介绍了服务器和客户端之间相互通信的不同类型的消息和命令。服务器和客户端之间交换的不同类型的消息包括用于发送音频数据的音频消息audio messages、用于发送视频数据的视频消息video messages、用于发送任何用户数据的数据消息data messages、共享对象消息shared object messages和命令消息command messages。共享对象消息提供了一个通用的方式来管理多个客户端和一个服务器之间的分布式数据。命令消息携带在客户端和服务器之间的AMF编码命令。客户端或服务器可以使用命令消息请求基于流的远程过程调用（RPC）与对方交流。 Types of Messages服务器和客户端通过网络上的消息互相通信。该消息可以是任何类型，其中包括音频消息、视频消息、命令消息、共享对象消息、数据消息和用户控制消息。 Command Message (20, 17)命令消息携带客户端和服务器之间的AMF编码命令。这些消息为AMF0编码分配消息类型值20，为AMF3 编码分配消息类型值17。这些消息被发送到对端执行一些操作，如连接，创建流、发布、播放，暂停。命令消息类型于状态和结果等，被用来通知发送者的请求命令状态。命令消息由命令名称command name、事务标识transaction ID和包含相关参数的命令对象command object组成。客户端或服务器可以使用命令消息请求基于流的远程过程调用（RPC）与对方交流。 Data Message (18, 15)客户端或服务器通过此消息发送元数据或任何用户数据给对端。元数据包括数据（音频，视频等）的详细信息，如创建时间，持续时间，主题等。这些消息为AMF0和AMF3分别被分配消息类型值18和15。 Shared Object Message (19, 16)共享对象是一个在跨多个客户端，实例等同步的Flash对象（名称-值对的集合）。消息类型19（对于AMF0）和16（对于AMF3）被保留用作共享对象事件shared object events。每个消息可以包含多个事件。下面是支持的事件类型： 事件 描述 Use(=1) 客户端发送此事件通知服务器一个名为共享对象的创建。 Release(=2) 当在客户端删除共享对象时，客户端将此事件发送到服务器上。 Request Change(=3) 客户端发送此事件以请求更改与共享对象命名参数关联的值。 Change (=4) 服务器发送此事件通知除了正在发起请求之外的所有客户端命名参数值的变化。 Success (=5) 如果请求被受理，服务器发送此事件给正在请求的客户端，以响应RequestChange事件。 SendMessage(=6) 客户端将此事件发送到服务器以广播一个消息。在接收此事件时，服务器向所有客户端广播消息，包括该发送者。 Status (=7) 服务器发送此事件以通知客户端相关的错误状况。 Clear (=8) 服务器将此事件发送给客户端，以清除共享对象。服务器还发送清除共享对象。服务器还发送此事件响应客户端在连接时发送的使用事件Use event。 Remove (=9) 服务器发送此事件让客户端删除一个插槽。 Request Remove(=10) 客户端发送此事件让服务器删除一个插槽。 Use Success(=11) 成功连接时，服务器将此事件发送给客户端。 Audio Message (8)客户端或服务器通过发送此消息发送音频数据到对端。消息类型值8被保留用作音频消息。 Video Message (9)客户端或服务器通过发送此消息发送视频数据到对端。消息类型值9被保留用作视频消息。 Aggregate Message (22)一个聚合消息是一个单一的包含了一系列RTMP子消息的消息，它们的格式在6.1节描述。消息类型22用于聚合消息。聚合消息的stream ID优先于聚合体内子消息的stream ID。聚合消息和第一子消息的时间戳之间的差异是时间偏移，它被用于将子消息的时间戳归一化成流的时标。偏移量被加到每个子消息的时间戳，以变成归一化后的流时间。第一次子消息的时间戳应该与聚合消息的时间戳相同，所以偏移量应为0。后面的指针包含在它头部中前一消息的大小。它被包含以匹配FLV文件格式并用于向后定位。使用聚合消息有几个性能优势： chunk stream可以在一个chunk中至多发送一个完整的消息。因此，增加chunk的大小并且使用聚合消息减少了chunk发送的数量。 子消息可以连续存储在内存中。当产生系统调用在网络上发送数据时，它更有效的。 User Control Message Events客户端和服务器发送此消息把用户控制事件通知对端。有关该消息的格式，请参考第6.2节。以下是支持的用户控制事件： 事件 描述 Stream Begin (=0) 服务器发送此事件通知客户端流已成为功能，并可用于通信。默认情况下，在从客户端成功收到应用程序连接命令后，此事件以ID 0来发送。 Stream EOF (=1) 服务器发送此事件通知客户端该流请求的数据回放结束了。若不发出额外的命令，就没有更多的数据被发送了。客户端丢弃该流收到的消息。该4个字节的事件数据代表哪个stream ID的流播放已结束。 StreamDry (=2) 服务器发送此事件通知客户端，在流上没有更多的数据。如果服务器在一段时间内没有检测到任何的消息，它可以通知订阅的客户端流是结束的。该4个字节的事件数据代表结束流的stream ID。 SetBufferLength (=3) 客户端发送此事件通知服务器用于缓冲从流过来的任何数据的缓冲区大小（以毫秒为单位）。此事件在服务器开始处理流之前被发送。事件数据的前4个字节表示stream ID，而下面4个字节代表每毫秒缓冲区的长度。 StreamIsRecorded (=4) 服务器发送此事件来通知客户端，该流是一个记录流。4个字节的事件数据代表记录流的stream ID。 PingRequest (=6) 服务器发送此事件来测试客户端是否是可到达的。事件数据是4个字节的时间戳，代表当服务器发出命令时，本地服务器的时间。客户收到PingRequest时响应PingResponse。 PingResponse (=7) 客户端向服务器发送此事件响应ping请求。事件数据是当收到PingRequest时的4个字节时间戳。 Types of Commands客户端和服务器交换AMF编码的命令。发送者发送一个命令消息，该命令消息包含命令名称command name、事务标识transaction ID和相关参数的命令对象command object。例如，连接命令包含“app”参数，它告诉服务器该客户端要连接的应用程序名称。接收端处理命令并使用相同的transaction ID回应。响应字符串要么是_result，要么是_error，要么是方法名method name，例如，方法名是verifyClient或contactExternalServer。命令字符串_result或_error表示一个应答。transaction ID指示应答相关的重要命令。它与在IMAP等多种协议的标签tag是相同的。命令字符串中的方法名表示发送端正在试图在接收端运行一个方法。下面类型的对象用于发送各种命令：NetConnection：一个服务器和客户端之间的连接的一个更高级别表示的对象。NetStream：一个表示发送音频流、视频流和其他相关数据的信道对象。我们还发送如播放，暂停等控制数据流的命令。 NetConnection CommandsNetConnection管理客户端和服务器之间的双向连接。此外，它为异步远程方法调用提供了支持。下面的命令可以在NetConnection上发送： connect call close createStream Connect客户端向服务器发送连接命令，请求连接到服务器应用程序实例。从客户端到服务器的命令结构如下： 字段名 类型 描述 Command Name String 命令名称，设置为“connect”。 Transaction ID Number 通常设置为1。 Command Object Object 包含名称-值对的命令对象。 Optional User Arguments Object 任何可选的信息。 以下是连接命令对象中使用的名称-值对的描述： 属性 类型 描述 样例值 app String 客户端要连接的服务器应用程序名 testapp flashver String Flash Player的版本号。它与ApplicationScript中getversion()方法返回的字符串是一样的。 FMSc/1.0 swfUrl String 发起连接的SWF源文件的URL file://C:/FlvPlayer.swf tcUrl String 服务器URL。它具有以下的格式。protocol://servername:port/appName/appInstance rtmp://localhost:1935/testapp/instance1 fpad Boolean 如果使用代理，值为true。 true或者false audioCodecs Number 指示客户端支持的音频编码。 SUPPORT_SND_MP3 videoCodecs Number 指示支持什么视频编码。 SUPPORT_VID_SORENSON videoFunction Number 指示支持什么专用的视频方法。 SUPPORT_VID_CLIENT_SEEK pageUrl String SWF文件从哪里加载的网页URL。 http://somehost/sample.html objectEncoding Number AMF编码方法。 AMF3 audioCodecs属性的标志值： 编解码标志 用法 值 SUPPORT_SND_NONE 原始音频，无压缩 0x0001 SUPPORT_SND_ADPCM ADPCM压缩 0x0002 SUPPORT_SND_MP3 mp3压缩 0x0004 SUPPORT_SND_INTEL 未使用 0x0008 SUPPORT_SND_UNUSED 未使用 0x0010 SUPPORT_SND_NELLY8 8-kHz采样速率的NellyMoser压缩 0x0020 SUPPORT_SND_NELLY NellyMoser压缩（5，11，22，和44 kHz采样速率） 0x0040 SUPPORT_SND_G711A G711A声音压缩（仅Flash Media Server支持） 0x0080 SUPPORT_SND_G711U G711U声音压缩（仅Flash Media Server支持） 0x0100 SUPPORT_SND_NELLY16 16-kHz采样速率的NellyMoser压缩 0x0200 SUPPORT_SND_AAC 高级音频编码（AAC）编解码 0x0400 SUPPORT_SND_SPEEX Speex音频 0x0800 SUPPORT_SND_ALL 所有RTMP支持的音频编解码 0x0FFF videoCodecs属性的标志值： 编解码标志 用法 值 SUPPORT_VID_UNUSED 废弃值 0x0001 SUPPORT_VID_JPEG 废弃值 0x0002 SUPPORT_VID_SORENSON Sorenson Flash视频 0x0004 SUPPORT_VID_HOMEBREW V1屏幕共享 0x0008 SUPPORT_VID_VP6 (On2) On2视频（Flash 8+） 0x0010 SUPPORT_VID_VP6ALPHA(On2 with alpha channel) 带有alpha通道的On2视频 0x0020 SUPPORT_VID_HOMEBREWV(screensharing v2) 屏幕共享版本2（Flash 8+） 0x0040 SUPPORT_VID_H264 H264视频 0x0080 SUPPORT_VID_ALL 所有的RTMP支持的视频编解码 0x00FF videoFunction属性的标志值： 方法标志 用法 值 SUPPORT_VID_CLIENT_SEEK 指示客户端可以进行帧精确控制查找 1 对象编码属性的值： 编码类型 用法 值 AMF0 AMF0对象编码，Flash 6及更新版本支持 0 AMF1 来自于Flash 9的AMF3编码（AS3） 3 从服务器到客户端的命令结构如下所示： 字段名 类型 描述 Command Name String _result或者_error；表示响应是否为结果或者错误。 Transaction ID Number 对于connect的应答来说，Transaction ID是1 Properties Object 该连接的描述属性（fmsver等）的名称-值对。 Information Object 来自于服务器的描述应答的名称-值对。“code”，“level”，“description”是这些信息的几个名称。 在该命令执行期间的消息流程是： 客户端发送connect命令给服务器，请求与服务器应用程序实例连接。 在收到connect命令之后，服务器给客户端发送“Window Acknowledgement Size”的协议消息。服务器也会连接connect命令提到的应用程序。 服务器给客户端发送“Set Peer Bandwidth”协议消息。 在处理“Set Peer Bandwidth”协议消息之后，客户端给服务器发送“Window Acknowledgement Size”的协议消息。 服务器给客户端发送另一个类型的协议消息，用户控制消息（StreamBegin）。 服务器发送result命令消息通知客户端该连接的状态（成功或失败）。该命令指定transaction ID（对于connect命令来说，它总是等于1）。该消息也会指定一些属性，如Flash Media Server的版本（字符串）。另外，它指定了其他连接应答相关的信息，比如级别（字符串），编码（字符串），描述（字符串），对象编码（数字）等。 CallNetConnection对象的调用方法在接收端运行远程过程调用（RPC）。RPC调用的名称作为该call命令的参数传递。发送端到接收端的命令结构如下所示： 字符名 类型 描述 Procedure Name String 远程过程调用的名称。 Transaction ID Number 如果需要一个应答，我们给出一个transaction Id。否则，我们传一个0的值。 Command Object Object 如果存在任何的命令信息，它就会被设置，否则，它被设置为null类型。 Optional Arguments Object 任何将要提供的可选参数。 应答的命令结构如下所示： 字段名 类型 描述 Command Name String 命令名称。 Transaction ID Number 命令的ID，标识它属于哪个应答的。 Command Object Object 如果存在任何的命令信息，它就会被设置，否则，它被设置为null类型。 Response Object 该调用方法的应答。 createStream客户端发送命令到服务器创建消息通信的逻辑通道。发布的音频、视频和元数据通过使用createStream命令创建的流通道传输。NetConnection是默认的通信通道，它的stream ID为0。协议和少量命令消息，包括createStream，使用该默认的通信通道。客户端到服务端的命令结构如下所示： 字段名 类型 描述 Command Name String 命令名称。设置为“createStream”。 Transaction ID Number 命令的会话ID。 Command Object Object 如果存在任何的命令信息，它就会被设置，否则，它被设置为null类型。 服务器到客户端的命令结构如下所示： 字段名 类型 描述 Command Name String _result或者_error；表示响应是否为结果或者错误。 Transaction ID Number 命令的ID，标识它属于哪个应答的。 Command Object Object 如果存在任何的命令信息，它就会被设置，否则，它被设置为null类型。 Stream ID Number 该返回值要么是stream ID，要么是一个错误信息对象。 NetStream CommandsNetStream定义了音频，视频和数据信息流可以在连通客户端到服务器的NetConnection上流通的通道。一个NetConnection对象可以支持多种数据流的多个NetStream。以下命令可以在NetStream上从客户端发送到服务器： play play2 deleteStream closeStream receiveAudio receiveVideo publish seek pause 服务器使用“onStatus”命令给客户端发送NetStream状态更新： 字段名 类型 描述 Command Name String 命令名“onStatus”。 Transaction ID Number Transaction ID设置为0。 Command Object Null onStatus消息没有命令对象。 Info Object Object 一个AMF对象至少有下面3种属性：“level”（字符串）：此消息的级别，“warning”、“status”或者“error”其中之一；“code”（ 字符串）：消息代码，比如“NetStream.Play.Start”；“description”（字符串）：一个可读的消息描述。Info对象可能包含其他适合编码的属性。 play客户端将此命令发送到服务器播放流。也可以多次使用此命令创建一个播放列表。如果你想创建一个在不同直播或录制流之间切换的动态播放列表，调用play不止一次并传递false以每次都重置。相反，如果你想立即播放指定的流，传递true以重置清除任何其他播放队列的流。从客户端到服务端的命令结构如下所示： 字段名 类型 描述 Command Name String 命令的名称，设置为“play”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Stream Name String 播放流的名称。如果要播放视频（FLV）文件，指定不带文件扩展名（比如，“sample”）的流名称。如果要回放MP3或者ID3标签，你必须要流名称前加上mp3:的前缀（比如，“mp3:sample”）。如果要播放H.264/AAC文件，你必须在流名称前加上mp4:的前缀，并且指定文件名后缀。比如，要播放文件sample.m4v，指定“mp4:sample.m4v”。 Start Number 一个可选的参数，指定以秒为单位的起始时间。默认值为-2，意思是，该订阅者第一次尝试播放流名称字段指定的直播流。如果该名称的直播流没有被找到，它会播放同名的录播流。如果没有该名称的录播流，该订阅者等到该名称的直播流可用时再播放。如果你在Start字段中传递-1，那么只有流名称字段指定的直播流才会被播放。如果你在Start字段传递0或者一个正数，一个在流名称字段指定的录播流会被播放，起始时间是Start字段指定的时间。如果找不到该记录流，播放列表的下一个条目会被播放。 Duration Number 一个可选的参数，指定以秒为单位的回放时间段。默认值是-1。-1值意味着，直播流被播放直到它不可用，或者录播流被播放直到结束。如果你传递0，它会播放录播流中Start字段指定开始时间的一帧。它假定Start字段的值大于等于0。如果你指定一个正数，它会播放Duration字段指定该段时间的直播流。之后，它能够播放Duration字段指定该段时间的录播流。（如果流在Duration字段指定的时间前结束，回放随着流的结束而结束。）如果你传递一个不同于-1的负数，它会把该值解析为-1。 Reset Boolean 一个可选的布尔值或数字，它指定是否清除之前的所有播放列表。 在该命令执行期间的消息流程是： 客户端在收到来自于服务器的createStream命令的成功结果后，发送play命令。 在收到play命令的同时，服务器发送一个协议消息设置chunk的大小。 服务器发送另一个协议消息（用户控制）指定“StreamIsRecorded”的事件，并且在该消息中带上stream ID。该消息在头2个字节带上事件类型并且在最后4个字节包含stream ID。 服务器发送另一个协议消息（用户控制）指定“StreamBegin”事件，以向客户端指示流的开始。 如果客户端发送的play命令成功的话，该服务器发送一个onStatus的命令消息NetStream.Play.Start和NetStream.Play.Reset。只有客户端发送的play命令带有reset标志时，服务器才会发送NetStream.Play.Reset。如果要播放的流没在被找到，服务器发送NetStream.Play.StreamNotFound的onStatus消息回应。 之后，服务器发送音频和视频数据在客户端播放。 play2不同于play命令，play2可以切换一个不同的码率而不改变播放内容的时间轴。服务器为客户端可以在play2中请求的所有支持的码率维护多个字段。客户端到服务器的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“play2”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Parameters Object 一个AMF编码的对象，它的属性是描述flash.net.NetStreamPlayOptions ActionScript对象的公有属性。 NetStreamPlayOptions对象的公共属性在ActionScript 3语言参考手册中描述。该命令的消息流程如下图所示： deleteStream当NetStream对象将要被销毁时，它发送该deleteStream命令。客户端到服务器的命令结构如下所示： 字段名 类型 描述 Command Name String 命令的名称，设置为“deleteStream”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Stream ID Number 在服务器上销毁流的ID。 该服务器不需要发送任何应答。 receiveAudioNetStream发送receiveAudio消息通知服务器是否发送或不发送音频到客户端。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“receiveAudio”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Bool Flag Boolean true或者false表示是否接收音频。 如果receiveAudio命令发送带有flase的bool flag，服务器不发送任何响应。如果这个标志被设置为true，服务器应答NetStream.Seek.Notify和NetStream.Play.Start的状态消息。 receiveVideoNetStream发送receiveVideo消息通知服务器是否发送或不发送视频到客户端。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“receiveVideo”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Bool Flag Boolean true或者false表示是否接收视频。 如果receiveVideo命令发送带有flase的bool flag，服务器不发送任何响应。如果这个标志被设置为true，服务器应答NetStream.Seek.Notify和NetStream.Play.Start的状态消息。 publish客户端发送publish命令将已命名的流发布到服务器上。使用这个名称，任何客户端都可以播放此流，并接收已发布的音频、视频和数据消息。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“publish”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Publishing Name String 发布流的名称。 Publishing Type String 发布的类型。设置为“live”，“record”或者“append”。record：该流已被发布并且数据被记录到一个新的文件。该文件存储在服务器的一个包含服务器应用程序目录的子目录。如果文件已经存在，则它被覆盖。append：流已经被发布，并且该数据被追加到一个文件。如果找不到文件，则创建它。live：直播数据被发布，而没有记录到文件。 服务器应答onStatus命令，以标记发布的开始。 seek客户端发送seek命令以定位媒体文件内或者播放列表的某个位置（以毫秒为单位）。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“seek”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 milliSeconds Number 定位到播放列表的毫秒数。 当定位成功，服务器发送NetStream.Seek.Notify的状态消息。失败的时候，它返回一个_error的消息。 pause客户端发送pause命令以告诉服务器暂停或者开始播放。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“pause”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Pause/Unpause Flag Boolean true或者false，以表示暂停或者恢复播放。 milliSeconds Number 毫秒数，在流的哪个位置被暂停或者恢复播放的。当流被暂停，这就是客户端的当前流的时间。当播放被恢复，该服务器仅会发送带有大于此值的时间戳的消息。 当流被暂停，服务器发送一个NetStream.Pause.Notify的状态消息。当一个流变成未暂停状态，NetStream.Unpause.Notify被发送。失败的时候，它返回一个_error的消息。 Message Exchange Examples这里是一些样例，以解释使用RTMP的消息交换。 Publish Recorded Video这个例子说明了一个发布者如何可以发布一个流，然后将视频推流到服务器上。其他客户端可以订阅这个已发布的流，并播放视频。 Broadcast a Shared Object Message这个例子说明了在创建和更改共享对象时所交换的消息。它也说明了共享对象消息广播的过程。 Publish Metadata from Recorded Stream这个例子描述了发布元数据的消息交换。 References[RFC0791] Postel, J., “Internet Protocol”, STD 5, RFC 791,September 1981.[RFC0793] Postel, J., “Transmission Control Protocol”, STD 7,RFC 793, September 1981.[RFC1982] Elz, R. and R. Bush, “Serial Number Arithmetic”, RFC 1982,August 1996.[RFC2119] Bradner, S., “Key words for use in RFCs to IndicateRequirement Levels”, BCP 14, RFC 2119, March 1997.[AS3] Adobe Systems, Inc., “ActionScript 3.0 Reference for theAdobe Flash Platform”, 2011, http://www.adobe.com/devnet/ actionscript/documentation.html.[AMF0] Adobe Systems, Inc., “Action Message Format – AMF 0”,December 2007, http://opensource.adobe.com/wiki/download/ attachments/1114283/amf0_spec_121207.pdf.[AMF3] Adobe Systems, Inc., “Action Message Format – AMF 3”,May 2008, http://opensource.adobe.com/wiki/download/ attachments/1114283/amf3_spec_05_05_08.pdf.123456789101112131415161718Authors’ AddressesHardeep Singh Parmar (editor)Adobe Systems Incorporated345 Park AveSan Jose, CA 95110-2704USPhone: +1 408 536 6000Email: hparmar@adobe.comURI: http://www.adobe.com/Michael C. Thornburgh (editor)Adobe Systems Incorporated345 Park AveSan Jose, CA 95110-2704USPhone: +1 408 536 6000Email: mthornbu@adobe.comURI: http://www.adobe.com/]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>RTMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctypes使用指南]]></title>
    <url>%2F2017%2F09%2F17%2Fctypes%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[ctypes 简介从Python2.5开始引入。ctypes是Python的外部函数库。它提供了C兼容的数据类型，并且允许调用动态链接库/共享库中的函数。它可以将这些库包装起来给Python使用。 ctypes 入门本入门中的代码使用doctest确保可用。不过一些代码在linux/windows/mac os x中的行为可能略有差异，这在其doctest的注释中有所表示。少数代码示例引用了ctypes的c_int类型。这个类型是32bit系统中c_long类型的别名。所以你在期待c_int而显示c_long时不必疑惑，他们是一样的。 载入动态链接库ctypes导出了 cdll，在windows上还有 windll 和 oledll 对象用于载入动态链接库。载入动态链接库可以直接存取其属性。 cdll 载入导出函数符合cdecl调用规范的库，而 windll 载入导出函数符合 stdcall 调用规范的库， oledll 也使用 stdcall 调用规范，并假设函数返回Windows的HRESULT错误码。错误码用于在出错时自动抛出WindowsError这个Python异常。如下是Windows的例子，主意msvcrt是MS标准C库，包含了大部分标准C函数，并且使用cdecl调用规范: 1234567&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; print windll.kernel32&lt;WinDLL &apos;kernel32&apos;, handle ... at ...&gt;&gt;&gt;&gt; print cdll.msvcrt&lt;CDLL &apos;msvcrt&apos;, handle ... at ...&gt;&gt;&gt;&gt; libc=cdll.msvcrt&gt;&gt;&gt; Windows通常使用”.dll”作为动态链接库的扩展名。Linux上需要指定包含扩展名的文件名来载入动态库，所以属性存取方式就失效了。你可以使用 LoadLibrary 方法，或者创建CDLL的实例来载入: 123456&gt;&gt;&gt; cdll.LoadLibrary(&quot;libc.so.6&quot;)&lt;CDLL &apos;libc.so.6&apos;, handle ... at ...&gt;&gt;&gt;&gt; libc==CDLL(&quot;libc.so.6&quot;)&gt;&gt;&gt; libc&lt;CDLL &apos;libc.so.6&apos;, handle ... at ...&gt;&gt;&gt;&gt; 从载入的动态链接库中访问函数函数是作为dll对象的属性来存取的: 123456789101112&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; libc.printf&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; print windll.kernel32.GetModuleHandleA&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; print windll.kernel32.MyOwnFunctionTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;ctypes.py&quot;, line 239, in __getattr__ func = _StdcallFuncPtr(name,self)AttributeError: function &apos;MyOwnFunction&apos; not found&gt;&gt;&gt; 注意win32系统动态链接库，如kernel32和user32经常同时导出ANSI和UNICODE版本的函数。UNICODE版本的会在名字末尾加”W”，而ANSI版本的加上”A”。Win32版本的 GetModuleHandle 函数，返回给定模块名的句柄，有如下C原型，还有一个宏用于暴露其中一个作为 GetModuleHandle ，依赖于UNICODE定义与否: 1234/* ANSI version */HMODULE GetModuleHandleA(LPCSTR lpModuleName);/* UNICODE version */HMODULE GetModuleHandleW(LPCWSTR lpModuleName); windll 并不会自动选择调用某个版本，所以你必须指定要调用的，传递的时候也要指定正确的字符串参数类型。有时动态链接库导出函数并不是有效的Python标识符，例如 “??2@YAPAXI@Z” 。这种情况下，你必须使用getattr 获取函数: 123&gt;&gt;&gt; getattr(cdll.msvcrt,&quot;??2@YAPAXI@Z&quot;)&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; 在Windows上，有些动态链接库导出函数不是用名字，而是用序号(ordinal)。这些函数通过索引存取: 123456789&gt;&gt;&gt; cdll.kernel32[1]&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; cdll.kernel32[0]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;ctypes.py&quot;, line 310, in __getitem__ func = _StdcallFuncPtr(name,self)AttributeError: function ordinal 0 not found&gt;&gt;&gt; 调用函数你可以像正常的Python函数一样调用这些函数。这里用 time() 函数示例，返回Unix epoch系统时间，和GetModuleHandleA() 函数，返回win32模块句柄。这个例子调用函数时附带NULL指针(None作为NULL指针): 12345&gt;&gt;&gt; print libc.time(None)1150640792&gt;&gt;&gt; print hex(windll.kernel32.GetModuleHandleA(None))0x1d000000&gt;&gt;&gt; 在调用函数时，如果使用了错误的参数数量和调用规范时，ctypes尝试保护调用。不幸的是该功能仅在Windows上有用。它通过检查函数返回栈来实现，所以尽管发生了错误，但是函数还是调用了: 12345678&gt;&gt;&gt; windll.kernel32.GetModuleHandleA()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with not enough argument (4 bytes missing)&gt;&gt;&gt; windll.kernel.GetModuleHandleA(0,0)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with too many argument (4 bytes in excess) 这在你使用了错误的调用规范时同样会发生: 1234567891011&gt;&gt;&gt; cdll.kernel32.GetModuleHandleA(None) # doctest: +WINDOWSTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with not enough arguments (4 bytes missing)&gt;&gt;&gt;&gt;&gt;&gt; windll.msvcrt.printf(&quot;spam&quot;) # doctest: +WINDOWSTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with too many arguments (4 bytes in excess)&gt;&gt;&gt; 想要找到正确的调用规范，你必须查看C头文件或者函数的文档。在Windows，ctypes使用win32结构异常处理，避免无保护的挂掉: 1234&gt;&gt;&gt; windll.kernel32.GetModuleHandleA(32)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?WindowsError: exception: access violation reading 0x00000020 尽管如此，仍然有很多方法用ctypes挂掉Python，所以你必须很小心的使用。None、整数、长整数、字节串和unicode字符串是可以作为本地Python对象直接传递给函数调用的。None是作为C的NULL指针，字 节串和unicode字符串作为内存块指针传递(char 或 wchar_t)。Python整数和长整数作为平台相关的C类型传递。在调用更多的函数之前，必须了解关于ctypes数据类型的知识。 基本数据类型ctypes定义了一系列基本C数据类型： ctypes 类型 C类型 Python 类型 c_char char 1个字符的字符串 c_wchar wchar_t 1个字符的unicode字符串 c_byte char int/long c_ubyte unsigned char int/long c_short short int/long c_ushort unsigned short int/long c_int int int/long c_uint unsigned int int/long c_long long int/long c_ulong unsigned long int/long c_longlong __int64 或 long long int/long c_ulonglong unsigned __int64 或 unsigned long long int/long c_float float float c_double double float c_char_p char * (NUL 结尾字符串) string 或 None c_wchar_p wchar_t * (NUL 结尾字符串) unicode 或 None c_void_p void * int/long 或 None 所有这些类型都可以通过调用可选传输初始化值方式指定值: 123456&gt;&gt;&gt; c_int()c_long(0)&gt;&gt;&gt; c_char_p(&quot;Hello, world&quot;)c_char_p(&apos;Hello, world&apos;)&gt;&gt;&gt; c_ushort(-3)c_ushort(65533) 这些类型都是可变的，其值也是随后可变的: 123456789&gt;&gt;&gt; i=c_int(42)&gt;&gt;&gt; print ic_long(42)&gt;&gt;&gt; print i.value42&gt;&gt;&gt; i.value=-99&gt;&gt;&gt; print i.value-99&gt;&gt;&gt; 对指针类型 c_char_p/c_wchar_p/c_void_p 的赋值将会改变其指向的内存区域地址，而不是改变内存块的值(当然了，因为Python字符串是只读的): 12345678910&gt;&gt;&gt; s=&quot;Hello, world&quot;&gt;&gt;&gt; c_s=c_char_p(s)&gt;&gt;&gt; print c_sc_char_p(&apos;Hello, world&apos;)&gt;&gt;&gt; c_s.value=&quot;Hi, there&quot;&gt;&gt;&gt; print c_sc_char_p(&apos;Hi, there&apos;)&gt;&gt;&gt; print s #第一个字符串没有改变Hello, world&gt;&gt;&gt; 必须小心的是，不要传递这些的指针给可变内存。如果你需要可变内存块，ctypes提供了create_string_buffer() 函数。当前内存块可以存取或改变，如果你想要将其作为NUL结尾字符串方式，使用值的方法: 12345678910111213141516&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; p = create_string_buffer(3) # create a 3 byte buffer, initialized to NUL bytes&gt;&gt;&gt; print sizeof(p), repr(p.raw)3 &apos;\x00\x00\x00&apos;&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;) # create a buffer containing a NUL terminated string&gt;&gt;&gt; print sizeof(p), repr(p.raw)6 &apos;Hello\x00&apos;&gt;&gt;&gt; print repr(p.value)&apos;Hello&apos;&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;, 10) # create a 10 byte buffer&gt;&gt;&gt; print sizeof(p), repr(p.raw)10 &apos;Hello\x00\x00\x00\x00\x00&apos;&gt;&gt;&gt; p.value = &quot;Hi&quot;&gt;&gt;&gt; print sizeof(p), repr(p.raw)10 &apos;Hi\x00lo\x00\x00\x00\x00\x00&apos;&gt;&gt;&gt; create_string_buffer() 函数已经替换了 c_buffer() 函数(仍然作为别名存在)，有如 c_string() 函数以前，只是出现在以前的版本中。想要创建包含unicode字符(对应C类型wchar_t)的可变内存块，使用create_unicode_buffer() 函数。 调用函数，继续需要注意的是，printf打印到真实的标准输出，而不是 sys.stdout ，所以这些例子仅在控制台模式有效，而不是IDLE或PythonWin: 123456789101112131415&gt;&gt;&gt; printf=libc.printf&gt;&gt;&gt; printf(&quot;Hello, %s\n&quot;,&quot;World!&quot;)Hello, World!14&gt;&gt;&gt; printf(&quot;Hello, %S&quot;, u&quot;World!&quot;)Hello, World!13&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, 42)42 bottles of beer19&gt;&gt;&gt; printf(&quot;%f bottles of beer\n&quot;, 42.5)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ArgumentError: argument 2: exceptions.TypeError: Don&apos;t know how to convert parameter 2&gt;&gt;&gt; 如前面所说，除了整数、字符串和unicode字符串以外的Python类型必须使用ctypes类型做包装，所以他们可以转换为必须的C数据类型: 123&gt;&gt;&gt; printf(&quot;An int %d, a double %f\n&quot;,1234,c_double(3.14))An int 1234, a double 3.1400001049&gt;&gt;&gt; 使用自定义数据类型调用函数你可以使用自定义ctypes参数转换，允许你自己的类作为函数参数。ctypes寻找对象的 _asparameter 属性，并将其作为函数参数。当然，必须是整数、字符串或unicode 123456789&gt;&gt;&gt; class Bottles(object):... def __init__(self, number):... self._as_parameter_ = number...&gt;&gt;&gt; bottles = Bottles(42)&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, bottles)42 bottles of beer19&gt;&gt;&gt; 如果你不想存储实例的数据到 _asparameter 实例变量，你可以定义一个属性确保数据有效。 指定必须的参数类型(函数原型)可以通过指定函数的 argtypes 属性来指定函数的参数类型。argtypes必须是一个C数据类型序列(printf函数在这里不是个好例子，因为它需要依赖于格式化字符串的可变数量和多种类型的参数，反过来说倒是很适合于练手): 1234&gt;&gt;&gt; printf.argtypes=[c_char_p,c_char_p,c_int,c_double]&gt;&gt;&gt; printf(&quot;String &apos;%s&apos;, Int %d, Double %f\n&quot;,&quot;Hi&quot;,10,2.2)String &apos;Hi&apos;, Int 10, Double 2.200000&gt;&gt;&gt; 指定不兼容的参数类型，和尝试转换参数到到无效类型会出错: 1234567&gt;&gt;&gt; printf(&quot;%d %d %d&quot;, 1, 2, 3)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ArgumentError: argument 2: exceptions.TypeError: wrong type&gt;&gt;&gt; printf(&quot;%s %d %f&quot;, &quot;X&quot;, 2, 3)X 2 3.00000012&gt;&gt;&gt; 如果你自定义的类要传递给函数调用，必须实现 from_param 类方法，才能在argtypes序列中使用。from_param 类方法接收Python对象传递到函数调用，需要做类型检查或者其他确保对象可以被接受的工作，然后返回对象本身， _asparameter 属性，或者你想要传递给C函数的参数。再次说明，返回结果必须是整数、字符串、unicode、ctypes实例，或者任何有 _asparameter 属性的东西。 返回类型缺省情况假设函数返回C的int类型。其他返回类型可以通过设置函数的 restype 属性来实现。这里是一个更高级的例子，它使用strchr函数，需要一个字符串指针和一个字符，返回字符串的指针: 123456789&gt;&gt;&gt; strchr = libc.strchr&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;)) # doctest: +SKIP8059983&gt;&gt;&gt; strchr.restype = c_char_p # c_char_p is a pointer to a string&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;))&apos;def&apos;&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, ord(&quot;x&quot;))None&gt;&gt;&gt; 如果你想要上面的 ord(“x”) 调用，你可以设置argtypes属性，而第二个参数的Python字符串会转换成C字符: 12345678910111213&gt;&gt;&gt; strchr.restype = c_char_p&gt;&gt;&gt; strchr.argtypes = [c_char_p, c_char]&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)&apos;def&apos;&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;def&quot;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ArgumentError: argument 2: exceptions.TypeError: one character string expected&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, &quot;x&quot;)None&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)&apos;def&apos;&gt;&gt;&gt; 你还可以使用Python的可调用对象(函数或者类的例子)作为restype属性，如果外语函数返回整数。这时在C函数调用结束后会使用其返回的 整数调用这个Python可调用对象，而返回值作为函数调用的返回值。相当于对C函数返回值做了包装。这对于检查错误码而抛出异常的情况非常有用: 12345678910111213141516&gt;&gt;&gt; GetModuleHandle = windll.kernel32.GetModuleHandleA # doctest: +WINDOWS&gt;&gt;&gt; def ValidHandle(value):... if value == 0:... raise WinError()... return value...&gt;&gt;&gt;&gt;&gt;&gt; GetModuleHandle.restype = ValidHandle # doctest: +WINDOWS&gt;&gt;&gt; GetModuleHandle(None) # doctest: +WINDOWS486539264&gt;&gt;&gt; GetModuleHandle(&quot;something silly&quot;) # doctest: +WINDOWSTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 3, in ValidHandleWindowsError: [Errno 126] The specified module could not be found.&gt;&gt;&gt; 这里的 WinError 是一个函数，会调用Windows的 FormatMessage() API来获取错误码的字符串描述，并且返回异常。 WinError 接受可选的错误码参数，如果没有指定则调用 GetLastError() 获取。需要注意的是强大的错误检查机制是通过 errcheck 属性实现的。具体查看手册了解细节。 传递指针(或者传递参数引用)有时C函数需要一个指针指向的数据作为参数，还有可能是想向里面写的位置，或者数据太大不适合传递。这也叫做传递参数引用。 ctypes导出 byref() 函数用于传递参数引用。同样也可以用于指针函数，尽管指针对象可以做很多工作，但是如果你并不需要在Python中使用指针对象的话，使用 byref() 会更快: 1234567891011&gt;&gt;&gt; i = c_int()&gt;&gt;&gt; f = c_float()&gt;&gt;&gt; s = create_string_buffer(&apos;\000&apos; * 32)&gt;&gt;&gt; print i.value, f.value, repr(s.value)0 0.0 &apos;&apos;&gt;&gt;&gt; libc.sscanf(&quot;1 3.14 Hello&quot;, &quot;%d %f %s&quot;,... byref(i), byref(f), s)3&gt;&gt;&gt; print i.value, f.value, repr(s.value)1 3.1400001049 &apos;Hello&apos;&gt;&gt;&gt; 结构和联合结构和联合必须继承自ctypes模块的 Structure 和 Union 类。每个子类必须定义 fields 属性，该属性必须是2元素元组的列表，包含字段名和字段类型。 字段类型必须是ctypes类型，例如 c_int ，或者其他派生的ctypes类型：结构、联合、数组、指针。 这里有个POINT结构体的简单例子，包含两个整数叫做x和y，同时展示了如何构造结构体: 12345678910111213141516&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class POINT(Structure):... _fields_ = [(&quot;x&quot;, c_int),... (&quot;y&quot;, c_int)]...&gt;&gt;&gt; point = POINT(10, 20)&gt;&gt;&gt; print point.x, point.y10 20&gt;&gt;&gt; point = POINT(y=5)&gt;&gt;&gt; print point.x, point.y0 5&gt;&gt;&gt; POINT(1, 2, 3)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: too many initializers&gt;&gt;&gt; 你还可以构造更多复杂的结构体。结构体可以自包含作为一个字段类型。这里是一个RECT结构体，它包含了两个POINT结构体分别名为upperleft和lowerright： 12345678910&gt;&gt;&gt; class RECT(Structure):... _fields_ = [(&quot;upperleft&quot;, POINT),... (&quot;lowerright&quot;, POINT)]...&gt;&gt;&gt; rc = RECT(point)&gt;&gt;&gt; print rc.upperleft.x, rc.upperleft.y0 5&gt;&gt;&gt; print rc.lowerright.x, rc.lowerright.y0 0&gt;&gt;&gt; 嵌套结构体可以通过下面多种方法初始化： 12&gt;&gt;&gt; r = RECT(POINT(1, 2), POINT(3, 4))&gt;&gt;&gt; r = RECT((1, 2), (3, 4)) 域描述可以检索到类，这对调试有很大的帮助，因为它们可以提供到有用的信息： 12345&gt;&gt;&gt; print POINT.x&lt;Field type=c_long, ofs=0, size=4&gt;&gt;&gt;&gt; print POINT.y&lt;Field type=c_long, ofs=4, size=4&gt;&gt;&gt;&gt; 结构/联合对齐和字节序默认情况下结构体和联合的对齐使用C编译器相同的方式。这可以通过 pack 类属性来重载其行为。这必须设置一个正数指定字段的最大对齐。这个功能与MSVC中的 #pragma pack(n) 功能一样。 ctypes中的结构体和联合使用本地字节序。想要用非本地字节序，可以使用 BigEndianStructure 、LittleEndianStructure 、 BigEndianUnion 、 LittleEndianUnion 基类。这些类无法包含指针字段。 结构与联合中的位字段创建结构与联合体时，可以包含位字段。只有整型域才可以使用位字段，位宽可以在fields元组的第三个选项中指定： 123456789&gt;&gt;&gt; class Int(Structure):... _fields_ = [(&quot;first_16&quot;, c_int, 16),... (&quot;second_16&quot;, c_int, 16)]...&gt;&gt;&gt; print Int.first_16&lt;Field type=c_long, ofs=0:0, bits=16&gt;&gt;&gt;&gt; print Int.second_16&lt;Field type=c_long, ofs=0:16, bits=16&gt;&gt;&gt;&gt; 数组数组就是序列，包含固定数量(fixed number of)的相同类型的实例。推荐的创建数组类型的方式是使用正数和乘号应用到类型: 1TenPointsArrayType=POINT*10 这里有个巧妙的例子，一个结构体包含一个字段有4个POINT: 123456789101112&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class POINT(Structure):... _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)...&gt;&gt;&gt; class MyStruct(Structure):... _fields_ = [(&quot;a&quot;, c_int),... (&quot;b&quot;, c_float),... (&quot;point_array&quot;, POINT * 4)]&gt;&gt;&gt;&gt;&gt;&gt; print len(MyStruct().point_array)4&gt;&gt;&gt; 可以通过下面的办法高效访问数组： 123arr = TenPointsArrayType()for pt in arr: print pt.x, pt.y 上面的代码打印一行结果0 0，因为数组数据初始化为0。可以通过下面的办法显式初始化： 123456789&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; TenIntegers = c_int * 10&gt;&gt;&gt; ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)&gt;&gt;&gt; print ii&lt;c_long_Array_10 object at 0x...&gt;&gt;&gt;&gt; for i in ii: print i,...1 2 3 4 5 6 7 8 9 10&gt;&gt;&gt; 指针指针实例使用 pointer() 函数: 1234&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; i=c_int(42)&gt;&gt;&gt; pi=pointer(i)&gt;&gt;&gt; 指针实例有一个 contents 属性返回指针指向的内容对象，例如上面的例子: 123&gt;&gt;&gt; pi.contentsc_long(42)&gt;&gt;&gt; 注意ctypes没有OOR(Original Object Return原始对象返回)，他在你请求一个属性时构造一个新的、等同的对象: 12345&gt;&gt;&gt; pi.contents is iFalse&gt;&gt;&gt; pi.contents is pi.contentsFalse&gt;&gt;&gt; 给指针的contents属性赋值一个新的c_int实例会改变指针指向内容的内存地址： 12345&gt;&gt;&gt; i = c_int(99)&gt;&gt;&gt; pi.contents = i&gt;&gt;&gt; pi.contentsc_long(99)&gt;&gt;&gt; 指针实例可以通过整数下标访问： 123&gt;&gt;&gt; pi[0]99&gt;&gt;&gt; 也可以通过下标访问的方式来改变指针指向的内容： 123456&gt;&gt;&gt; print ic_long(99)&gt;&gt;&gt; pi[0] = 22&gt;&gt;&gt; print ic_long(22)&gt;&gt;&gt; 你也可以使用非0下标访问，但你必须知道你在做什么，比如在C语言：你可以访问或改变任意的内存地址。一般情况下，你仅可以在收到一个C函数返回来的指针，并且你知道它是指向了一个数组时才可以使用这个特性。 指针函数不仅创建了指针实例，它还会先创建指针类型。这些就是指针函数POINTER的工作，它可以接受任何ctypes的类型，并返回一个新的指针： 12345678910&gt;&gt;&gt; PI = POINTER(c_int)&gt;&gt;&gt; PI&lt;class &apos;ctypes.LP_c_long&apos;&gt;&gt;&gt;&gt; PI(42)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?TypeError: expected c_long instead of int&gt;&gt;&gt; PI(c_int(42))&lt;ctypes.LP_c_long object at 0x...&gt;&gt;&gt;&gt; NULL指针具有默认的布尔值False： 1234&gt;&gt;&gt; null_ptr = POINTER(c_int)()&gt;&gt;&gt; print bool(null_ptr)False&gt;&gt;&gt; 当访问或给NULL指针赋值时，会引发python类型检查异常： 1234567891011&gt;&gt;&gt; null_ptr[0]Traceback (most recent call last): ....ValueError: NULL pointer access&gt;&gt;&gt;&gt;&gt;&gt; null_ptr[0] = 1234Traceback (most recent call last): ....ValueError: NULL pointer access&gt;&gt;&gt; 类型转换通常情况下，ctypes会做严格的类型检查。这意味着，如果形参有一个POINTER(c_int)指针指向一个函数或者结构体的成员域类型，那么实参只能接受相同类型的实例。但这个规则在ctypes处理其他对象时也有例外。比如，你可以传递兼容的数据类型来代替指针类型。所以，对于POINTER(c_int)指针类型来说，可以使用c_int数据来代替： 12345678910111213&gt;&gt;&gt; class Bar(Structure):... _fields_ = [(&quot;count&quot;, c_int), (&quot;values&quot;, POINTER(c_int))]...&gt;&gt;&gt; bar = Bar()&gt;&gt;&gt; bar.values = (c_int * 3)(1, 2, 3)&gt;&gt;&gt; bar.count = 3&gt;&gt;&gt; for i in range(bar.count):... print bar.values[i]...123&gt;&gt;&gt; 可以通过给指针的values属性赋值为None来设置NULL指针： 12&gt;&gt;&gt; bar.values = None&gt;&gt;&gt; 在C语言，你可以通过强制类型转换的方法来转换不兼容的类型。ctypes也提供了一个转换函数让你可以使用相同的方式进行类型转换。上面定义的Bar结构体中，它的value域可以支持POINTER(c_int)指针或者c_int数组，但不支持其他类型： 12345&gt;&gt;&gt; bar.values = (c_byte * 4)()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long instance&gt;&gt;&gt; 在这种情况下，转换函数就方便多了。 转换函数可以将一个能转换成ctypes指针的实例转换成另外一个ctypes指针类型。转换函数需要两个参数，第一个是能够转换成指针类型的cytpes实例类型，第二个是ctypes指针类型。它返回第二个参数类型的实例，并且这个实例与第一个参数共用同一块内存： 1234&gt;&gt;&gt; a = (c_byte * 4)()&gt;&gt;&gt; cast(a, POINTER(c_int))&lt;ctypes.LP_c_long object at ...&gt;&gt;&gt;&gt; 所以，Bar结构的values域可以这样通过类型转换来赋值： 12345&gt;&gt;&gt; bar = Bar()&gt;&gt;&gt; bar.values = cast((c_byte * 4)(), POINTER(c_int))&gt;&gt;&gt; print bar.values[0]0&gt;&gt;&gt; 不完全的类型不完全的类型包含结构体，联合体或者类型未指定的数组。在C语言中，它们可以这样先声明后定义： 123456struct cell; /* forward declaration */struct &#123; char *name; struct cell *next;&#125; cell; 直接这样转换成ctypes代码将会无效： 123456789&gt;&gt;&gt; class cell(Structure):... _fields_ = [(&quot;name&quot;, c_char_p),... (&quot;next&quot;, POINTER(cell))]...Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 2, in cellNameError: name &apos;cell&apos; is not defined&gt;&gt;&gt; 因为新类cell在类本身定义时是无效的。在ctypes，我们可以先定义cell类，然后再给它的fields属性赋值： 1234567&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class cell(Structure):... pass...&gt;&gt;&gt; cell._fields_ = [(&quot;name&quot;, c_char_p),... (&quot;next&quot;, POINTER(cell))]&gt;&gt;&gt; 让我们试一下效果。我们创建两个cell的实例，然后让他们互相指向对方，然后尝试访问指针链表几次： 12345678910111213&gt;&gt;&gt; c1 = cell()&gt;&gt;&gt; c1.name = &quot;foo&quot;&gt;&gt;&gt; c2 = cell()&gt;&gt;&gt; c2.name = &quot;bar&quot;&gt;&gt;&gt; c1.next = pointer(c2)&gt;&gt;&gt; c2.next = pointer(c1)&gt;&gt;&gt; p = c1&gt;&gt;&gt; for i in range(8):... print p.name,... p = p.next[0]...foo bar foo bar foo bar foo bar&gt;&gt;&gt; 回调函数ctypes允许从python回调中创建c回调函数指针。这个常常被称为回调函数。 首先，你必须为回调函数创建一个类，这个类知道调用协议，函数返回值类型，函数接受的参数个数及类型。 CFUNCTYPE工厂函数使用普通cdecl调用协议来为回调函数创建类型。并且，在Windows平台，WINFUNCTYPE工厂函数使用stdcall调用协议来为回调函数创建类型。 这两个工厂函数在调用时，参数表都是使用返回值作为第一个参数，而将回调函数所需要的参数作为剩下的参数。 在这里我将使用一个c标准库里的快排函数作为演示例子，快排是一个借助回调函数进行排序的函数。快排将会用到下面的整型数组： 12345&gt;&gt;&gt; IntArray5 = c_int * 5&gt;&gt;&gt; ia = IntArray5(5, 1, 7, 33, 99)&gt;&gt;&gt; qsort = libc.qsort&gt;&gt;&gt; qsort.restype = None&gt;&gt;&gt; 快排调用时需要一个待排序的原始数据指针，数组元素个数，单个元素的大小，以及一个被称为回调的比较函数指针。回调函数形参表需要两个待比较元素类型的指针，它的返回值为，当第一个数据小于第二个时返回负整数，两个数据相等时返回0，其他情况返回正整数。 所以，我们例子所需要的回调函数形参表是两个整型指针，它返回一个整数。首先我们用工厂函数创建回调函数的类型： 12&gt;&gt;&gt; CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))&gt;&gt;&gt; 在真正实现回调函数之前，我们简单打印获取到的参数，然后返回0（一步一步来） 12345&gt;&gt;&gt; def py_cmp_func(a, b):... print &quot;py_cmp_func&quot;, a, b... return 0...&gt;&gt;&gt; 创建C回调函数： 12&gt;&gt;&gt; cmp_func = CMPFUNC(py_cmp_func)&gt;&gt;&gt; 然后运行一下： 123456789101112&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +WINDOWSpy_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;&gt;&gt;&gt; 我们已经知道怎么访问指针指向的内容了，所以让我们重新定义一下回调函数： 123456&gt;&gt;&gt; def py_cmp_func(a, b):... print &quot;py_cmp_func&quot;, a[0], b[0]... return 0...&gt;&gt;&gt; cmp_func = CMPFUNC(py_cmp_func)&gt;&gt;&gt; 这是我们在Windows上跑到的结果： 123456789101112&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +WINDOWSpy_cmp_func 7 1py_cmp_func 33 1py_cmp_func 99 1py_cmp_func 5 1py_cmp_func 7 5py_cmp_func 33 5py_cmp_func 99 5py_cmp_func 7 99py_cmp_func 33 99py_cmp_func 7 33&gt;&gt;&gt; 有趣的是，在linux上排序函数运行更高效，它仅需要更少的比较的次数： 1234567&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +LINUXpy_cmp_func 5 1py_cmp_func 33 99py_cmp_func 7 33py_cmp_func 5 7py_cmp_func 1 7&gt;&gt;&gt; 嗯，我们将要完成了！最后一步是要真正去对两个数据进行比较并且返回一个有用的结果： 12345&gt;&gt;&gt; def py_cmp_func(a, b):... print &quot;py_cmp_func&quot;, a[0], b[0]... return a[0] - b[0]...&gt;&gt;&gt; 最后在Windows上运行的结果： 123456789101112&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) # doctest: +WINDOWSpy_cmp_func 33 7py_cmp_func 99 33py_cmp_func 5 99py_cmp_func 1 99py_cmp_func 33 7py_cmp_func 1 33py_cmp_func 5 33py_cmp_func 5 7py_cmp_func 1 7py_cmp_func 5 1&gt;&gt;&gt; 然后下面是linux上的结果: 1234567&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) # doctest: +LINUXpy_cmp_func 5 1py_cmp_func 33 99py_cmp_func 7 33py_cmp_func 1 7py_cmp_func 5 7&gt;&gt;&gt; 很有趣地看到，Windows的快排比在linux版本的快排比较的次数多！ 我们可以简单检查一下排序结果： 1234&gt;&gt;&gt; for i in ia: print i,...1 5 7 33 99&gt;&gt;&gt; 回调函数的重要提示： 确保你在C代码的使用生命周期里保持引用CFUNCTYPE对象。ctypes并不会帮你做这样的事情，如果你没有做保证，它们就会被垃圾回收，然后当你调用这个回调函数时将会导致程序崩溃。 访问动态链接库导出的值有时候，一个动态链接库不仅提供了函数，它还提供了变量。一个例子是，在Python自身库里使用了Py_OptimizeFlag标志变量，这个整型变量被设置为0，1，或者2，它依赖于python在启动时指定的-O或者-OO标志。ctypes可以这样使用in_dll的类方法访问变量值。pythonapi是一个预定义符号可以访问Python C api： 1234&gt;&gt;&gt; opt_flag = c_int.in_dll(pythonapi, &quot;Py_OptimizeFlag&quot;)&gt;&gt;&gt; print opt_flagc_long(0)&gt;&gt;&gt; 如果解析器使用-O命令启动，例子就会打印c_long(1)，或者c_long(2)如果指定-OO参数。 Python的导出指针PyImport_FrozenModules也是一个扩展的例子展示指针的访问使用办法。 根据Python docs文档：这个指针初始化指向一组”struct _frozen`”记录，以一个成员全部都是NULL或者0作为结束标志。当导入一个静态模块，它就会在这张表里面搜索。第三方代码可以利用此技巧提供一个静态模块的动态创建集合。 所以熟悉这个指针证明还是挺有用的。为了限制例子的大小，我们仅展示这个表如果通过ctypes来访问。 12345678&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt;&gt;&gt;&gt; class struct_frozen(Structure):... _fields_ = [(&quot;name&quot;, c_char_p),... (&quot;code&quot;, POINTER(c_ubyte)),... (&quot;size&quot;, c_int)]...&gt;&gt;&gt; 我们已经定义struct_frozen的数据结构类型，所以我们可以获得指向这张表的指针： 123&gt;&gt;&gt; FrozenTable = POINTER(struct_frozen)&gt;&gt;&gt; table = FrozenTable.in_dll(pythonapi, &quot;PyImport_FrozenModules&quot;)&gt;&gt;&gt; 由于此表是一个struct_frozen记录的数据指针，所以我们可以迭代遍历它，不过我们必须保证结束我们的循环，因为此指针没有指明大小。迟早它会因为非法访问而导致崩溃，所以当我们访问到NULL实体时，最好结束循环： 12345678910&gt;&gt;&gt; for item in table:... print item.name, item.size... if item.name is None:... break...__hello__ 104__phello__ -104__phello__.spam 104None 0&gt;&gt;&gt; 事实上，标准Python有一个并不怎么出名的静态模块和一个静态包（相对于其他成员来说），它仅用于测试。试试用import hello吧。 意料之外在ctypes，有些坑可能你没想到。 思考下面的例子： 1234567891011121314151617&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class POINT(Structure):... _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)...&gt;&gt;&gt; class RECT(Structure):... _fields_ = (&quot;a&quot;, POINT), (&quot;b&quot;, POINT)...&gt;&gt;&gt; p1 = POINT(1, 2)&gt;&gt;&gt; p2 = POINT(3, 4)&gt;&gt;&gt; rc = RECT(p1, p2)&gt;&gt;&gt; print rc.a.x, rc.a.y, rc.b.x, rc.b.y1 2 3 4&gt;&gt;&gt; # now swap the two points&gt;&gt;&gt; rc.a, rc.b = rc.b, rc.a&gt;&gt;&gt; print rc.a.x, rc.a.y, rc.b.x, rc.b.y3 4 3 4&gt;&gt;&gt; 嗯，我们当然期望最后一名打印3 4 1 2。到底发生了什么事？这里是上面rc.a, rc.b = rc.b, rc.a这一行的步骤： 1234&gt;&gt;&gt; temp0, temp1 = rc.b, rc.a&gt;&gt;&gt; rc.a = temp0&gt;&gt;&gt; rc.b = temp1&gt;&gt;&gt; 注意，temp0和temp1都是使用了上述rc对象的内部缓存块对象。所以当执行rc.a = temp0时，拷贝了temp0的缓冲内容给rc的缓冲。依次地，又改为temp1的内容。所以最后一句rc.b = temp1并没有想像中那样的效果。记住，检索结构体，联合体及数组并不是使用它们的拷贝，而是检索一个访问顶级对象相关缓冲区的封装对象。 另外一个意想不到的例子是： 1234567&gt;&gt;&gt; s = c_char_p()&gt;&gt;&gt; s.value = &quot;abc def ghi&quot;&gt;&gt;&gt; s.value&apos;abc def ghi&apos;&gt;&gt;&gt; s.value is s.valueFalse&gt;&gt;&gt; 为什么这里打印False？ctypes实例是一些包含内存块加上一些内容内存访问描述信息的对象。存储一个Python对象在内存块并不是存储对象本身，取而代之存储的是对象的内容。每次访问内容时都会构造一个新的Python对象！ 可变大小的数据类型ctypes提供了可变数组与结构体的支持（在0.9.9.7版本增加）。 resize函数可以调整一个已经存在的ctypes对象的内存缓冲大小。这个函数以ctypes对象为第一个参数，以需要调整后的字节大小为第二个参数。重新调整的内存块大小不能小于原生对象类型的内存块大小，若你这么做，则会抛出ValueError： 12345678910111213&gt;&gt;&gt; short_array = (c_short * 4)()&gt;&gt;&gt; print sizeof(short_array)8&gt;&gt;&gt; resize(short_array, 4)Traceback (most recent call last): ...ValueError: minimum size is 8&gt;&gt;&gt; resize(short_array, 32)&gt;&gt;&gt; sizeof(short_array)32&gt;&gt;&gt; sizeof(type(short_array))8&gt;&gt;&gt; 这看起来不错，但怎么访问这个数据增加的元素呢？由于type方法仍然只知道有4个元素，当访问其他元素时我们会得到错误： 1234567&gt;&gt;&gt; short_array[:][0, 0, 0, 0]&gt;&gt;&gt; short_array[7]Traceback (most recent call last): ...IndexError: invalid index&gt;&gt;&gt; ctypes中另外一种使用可变数据类型的方法是使用Python的动态语言特性，具体问题具体分析，当已经知道需要的数据大小时，才（重）定义数据类型。 bug, todo和未完成的东西没有实现枚举类型。你自己使用c_int作为基类就可以简单实现它。 没有实现long double类型。 参考资料 http://starship.python.net/crew/theller/ctypes/tutorial.html#bugs-todo-and-non-implemented-things本文档翻译的文章。 http://gashero.iteye.com/blog/519837本文档主要借鉴参考的文章。 http://www.isnowfy.com/introduction-to-python-c-extension/简单列举了各种python的c扩展办法。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>ctypes</tag>
        <tag>Cross language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocol Buffers 使用教程]]></title>
    <url>%2F2017%2F08%2F05%2FProtocol-Buffers-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述什么是 protocol buffers?ProtocolBuffer 是用于结构化数据串行化的灵活、高效、自动的方法，类似 XML，不 过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码 来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。 他们如何工作你首先需要在一个.proto 文件中定义你需要做串行化的数据结构信息。每个 ProtocolBuffer 信息是一小段逻辑记录，包含一系列的键值对。这里有个非常简单的.proto 文件定义了个人信息: 12345678910111213141516message Person &#123; required string name=1; required int32 id=2; optional string email=3; enum PhoneType &#123; MOBILE=0; HOME=1; WORK=2; &#125; message PhoneNumber &#123; required string number=1; optional PhoneType type=2 [default=HOME]; &#125; repeated PhoneNumber phone=4;&#125; 如你所见，消息格式很简单，每个消息类型拥有一个或多个特定的数字字段，每个字 段拥有一个名字和一个值类型。值类型可以是数字(整数或浮点)、布尔型、字符串、原始字 节或者其他 ProtocolBuffer 类型，还允许数据结构的分级。你可以指定可选字段，必选字 段和重复字段。你可以在protocolbuffers/docs/proto找到更多关于如何 编写 .proto 文件的信息。 一旦你定义了自己的报文格式(message)，你就可以运行ProtocolBuffer编译器，将你 的.proto 文件编译成特定语言的类。这些类提供了简单的方法访问每个字段(像是 query() 和 set_query() )，像是访问类的方法一样将结构串行化或反串行化。例如你可以选择 C++ 语言，运行编译如上的协议文件生成类叫做 Person 。随后你就可以在应用中使用这个类来 串行化的读取报文信息。你可以这么写代码: 12345Person person;person.set_name(&quot;John Doe&quot;);person.set_id(1234); person.set_email(&quot;jdoe@example.com&quot;);fstream.output(&quot;myfile&quot;,ios::out | ios::binary);person.SerializeToOstream(&amp;output); 然后，你可以读取报文中的数据: 12345fstream input(&quot;myfile&quot;,ios::in | ios:binary);Person person;person.ParseFromIstream(&amp;input);cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.email() &lt;&lt; endl; 你可以在不影响向后兼容的情况下随意给数据结构增加字段，旧有的数据会忽略新的字段。所以如果使用 ProtocolBuffer 作为通信协议，你可以无须担心破坏现有代码的情况下扩展协议。 你可以在 API 参考overview中找 到完整的参考，而关于 ProtocolBuffer 的报文格式编码则可以在encoding中找到。 为什么不使用 xml?ProtocolBuffer 拥有多项比 XML 更高级的串行化结构数据的特性，ProtocolBuffer: 更简单小3-10倍快20-100倍更少的歧义可以方便的生成数据存取类例如，让我们看看如何在 XML 中建模 Person 的 name 和 email 字段: 1234&lt;person&gt;&lt;name&gt;John Doe&lt;/name&gt;&lt;email&gt;jdoe@example.com&lt;/email&gt;&lt;/person&gt; 对应的 ProtocolBuffer 报文则如下: 1234person &#123; name: &quot;John Doe&quot; email: &quot;jdoe@example.com&quot;&#125; 当这个报文编码encoding到 ProtocolBuffer 的二进制格式时(上面的文本 仅用于调试和编辑)，它只需要28字节和100-200ns 的解析时间。而 XML 的版本需要69字节(除 去空白)和5000-10000ns 的解析时间。 当然，操作 ProtocolBuffer 也很简单: 12cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.email() &lt;&lt; endl; 而 XML 的你需要: 123456cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.getElementsByTagName(&quot;name&quot;)-&gt;item(0)-&gt;innerText() &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.getElementsByTagName(&quot;email&quot;)-&gt;item(0)-&gt;innerText() &lt;&lt; endl; 当然，ProtocolBuffer 并不是在任何时候都比 XML 更合适，例如 ProtocolBuffer 无法 对一个基于标记文本的文档建模(比如 HTML)，因为你根本没法方便的在文本中插入结构。 另外，XML 是便于人类阅读和编辑的，而 ProtocolBuffer 则不是。还有 XML 是自解释的， 而 ProtocolBuffer 仅在你拥有报文格式定义的.proto 文件时才有意义。 如何开始?下载包，包含了 Java、Python、 C++的 ProtocolBuffer 编译器，用于生成你需要的 IO 类。构建和安装你的编译器，跟随 README 的指令就可以做到。 一旦你安装好了，就可以跟着编程指导来选择语言- 随后就是使用 ProtocolBuffer 创建一个简单的应用了。 一点历史ProtocolBuffers 最初是在 Google 开发的，用以解决索引服务器的请求、响应协议。 在使用 ProtocolBuffers 之前，有一种格式用以处理请求和响应数据的编码和解码，并且支 持多种版本的协议。而这最终导致了丑陋的代码，比如:12345678if (version==3) &#123; ...&#125; else if (version&gt;4) &#123; if (version==5) &#123; ... &#125; ...&#125; 通信协议因此变得越来越复杂，因为开发者必须确保，发出请求的人和接受请求的人必 须同时兼容，并且在一方开始使用新协议时，另外一方也要可以接受。ProtocolBuffers 设计用于解决这一类问题: 很方便引入新字段，而中间服务器可以忽略这些字段，直接传递过去而无需理解所有的 字段。 格式可以自描述，并且可以在多种语言中使用(C++、Java 等) 然而用户仍然需要手写解析代码。 随着系统的演化，他需要一些其他的功能: 自动生成编码和解码代码，而无需自己编写解析器。 除了用于简短的 RPC(Remote Procedure Call)请求，人们使用 ProtocolBuffer来做数据存储格式(例如 BitTable)。 RPC服务器接口可以作为 .proto 文件来描述，而通过 ProtocolBuffer的编译器生成存根(stub)类供用户实现服务器接口。 ProtocolBuffers 现在已经是 Google 的混合语言数据标准了，现在已经正在使用的有 超过48,162种报文格式定义和超过12,183个 .proto 文件。他们用于 RPC 系统和持续数据存 储系统。 环境安装下载官方下载网站 安装12345tar -zxvf protobuf-2.5.0.tar.gzcd protobuf-2.5.0./configure --prefix=$INSTALL_DIRmakemake install 更详细的安装步骤请参考源码目录下的 README.txt。 安装完后在INSTALL_DIR目录下生成三个目录: 1bin include lib bin目录下是protoc工具，用于将你的.proto 文件编译成相应目标语言的编解码代码。include和lib目录是protoc工具所依赖的头文件与库环境。 利用protoc工具编译成目标语言编译前，先准备你的.proto 文件，这里暂时以源码目录下的 examples/addressbook.proto 文件为例。 protoc 用法: 1Usage: ./protoc [OPTION] PROTO_FILES 详情请使用 1./protoc --help 开始将你的.protoc 文件编译成目标语言编解码文件: 12mkdir c java python./protoc --proto_path=./ --cpp_out=c/ --java_out=java/ --python_out=python/ addressbook.proto 官方的 protoc 工具仅支持C++/java/python三种语言，如果你使用其他语言，比如 c#，php，你可以使用其他第三方工具。命令简介: 1./protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto 其中: 123--proto_path:.proto 所在的路径--cpp_out:生成 C++代码的路径--java_out:生成 java 代码的路径--python_out:生成 python 代码的路径 Python如何使用protocol buffers安装 python 的 pb 库:在 protobuf 源码目录下可以找到一个目录python，没错，你需要进入此目录安装python的pb库。 12cd protobuf-2.5.0/python$PYTHONHOME/bin/python setup.py install --prefix=$PYTHONHOME 使用–prefix 选项指定你 python 的安装目录，然后静待安装完成。以下是安装时常见的错误: 安装提示 error: package directory ‘google/protobuf/compiler’ does not exist 解决办法： 执行mkdir google/protobuf/compiler 创建compiler目录即可。 TBD 安装完 python 的 pb 库后，你就可以在源码的 examples 目录中，使用 add_person.py 和 list_people.py 来测试如何使用 pb 序列化与反序列化了。序列化与反序列化的相关接口 分别为 SerializeToString()和 ParseFromString()。 更多 python 相关的 api 请看protocol-buffers/docs/reference/python/index。 其他语言如何使用protocol buffersTBD 语言指导消息定义在.proto 文件里面用 Protocol Buffers 消息类型进行定义，每一个 Protocol Buffers消息是信息的一条小的逻辑记录，里面包含一系列名称-值对。下面是一个简单的.proto 文件: 12345message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;&#125; 字段类型可以是基本类型，例如整形、浮点型，值类型可以是其他的 Protocol Buffers 的消息类型，这样你可以用分层的方式定义你的数据结构。 分配字段Tag(标记)每个字段必须有一个唯一的标记，这个标记在序列化时会作为字段的标识出现在序 列化后的二进制数据中。一旦该消息用于生产，字段的 tag 就不能修改了。标记的值小 于15时序列化编码为一个字节，大于15会用到两个以上的字节。 指定字段的规则消息的字段可以具有以下类型的属性: required: 消息中必须包含一个该字段的值 optional: 可选字段，消息中可以有0个或一个该字段的值 repeated: 重复字段，消息中可以有0个或多个该字段的值 选择字段规则的建议你可以在你的消息格式里面添加新的域，而不用考虑向后兼容性，老的二进制流在 解析的时候可以简单的忽略掉新增的域。因此如果你使用 Protocol Buffers 作为你数据 格式的通信协议时，你可以扩展你的协议，而不用担心破坏现有的代码。对于 required，尽可能的少用，若一个字段开始时指定为 required，则以后就不能 修改为 optional。建议将字段设置都设置为 optional 类型，这样字段的 required 规则可以放在业务代码中进行处理。 增加更多的消息类型在单个 .proto 文件里可以定义多种消息类型: 123456789message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;&#125;message SearchResponse &#123; ...&#125; 注释.proto 文件使用 C/C++的注释风格: 12345message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; // Which page number do we want? optional int32 result_per_page = 3; // Number of results to return per page.&#125; 数值类型下表列举了 pb 协议数据类型与 C++/Java/Python 语言的类型对应关系: .proto Type Notes C++ Type Java Type Python Type[2] double double double float float float float float int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int int int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 long int/long[3] uint32 Uses variable-length encoding. uint32 int[1] int/long[3] uint64 Uses variable-length encoding. uint64 long[1] int/long[3] sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long[3] fixed32 Always four bytes. More efficient than uint32 if values are often greater than 228. uint32 int[1] int fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 256. uint64 long[1] int/long[3] sfixed32 Always four bytes. int32 int int sfixed64 Always eight bytes. int64 long int/long[3] bool bool boolean boolean string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode[4] bytes May contain any arbitrary sequence of bytes. string ByteString str 你可以在protocol-buffers/docs/encoding找到这些类型在 pb 序列化时是如何被编码的。 [1] 在 Java, unsigned 32-bit and 64-bit integers 都是使用最高位表示符号位，而无符号位部分是一样的。 [2] 所有情况下，赋值操作会触发类型检查以保证可用性。 [3] 64-bit or unsigned 32-bit integers 会被解码为 long 类型，但如果在赋值时使用 int 类型的话，解码后可以是 int 类型。任何情况下，值必须与被赋值时一样。见[2]。 [4] Python strings 类型在解码后是 unicode 类型，但如果原始字符串是 ASCII 编码的话也可能是 str 类型。 可选字段规则与默认值一个消息字段可以使用 optional 规则来限定，表示该字段是可选类型，即该消息可以 包含该字段也可以不包含该字段。当一个消息被解析时，如果序列化数据没有包含 optional 字段，则该字段会使用默认值来代替。默认值可以显式指定如下: 1optional int32 result_per_page = 3 [default = 10]; 如果没有显式指定默认值，则使用数据类型的默认值来代替:比如，字符串类型的默认值是空字符串，布尔类型的默认值是 false，数字类型的默认值是0，枚举类 型的默认值是第一个被定义的枚举值。 枚举类型使用 enum 关键字定义枚举类型，比如你想定义一个叫 Corpus 的枚举类型: 123456789101112131415message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3 [default = 10]; enum Corpus &#123; UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; &#125; optional Corpus corpus = 4 [default = UNIVERSAL];&#125; 使用其他消息类型你可以使用其他的消息类型来定义你的消息字段，以构成各种复合类型，比如 SearchResponse 消息里定义了一个 Result 消息类型的字段: 123456789message SearchResponse &#123; repeated Result result = 1;&#125;message Result &#123; required string url = 1; optional string title = 2; repeated string snippets = 3;&#125; 另外，你还可以使用 import 语句导入其他.proto 文件定义的消息类型。 包含路径的 import: 1import &quot;myproject/other_protos.proto&quot;; 不包含路径的 import: 12import public &quot;new.proto&quot;;import &quot;other.proto&quot;; 当使用 public 域 import 时，编译器会去 -I/–proto_path 标志指定的路径去查找，如果没有指定此标志，它会去编译器目录索引。通常情况下，建议你使用 –proto_path 指 定为项目的根路径，并且使用全名（包含命名空间或包名）import。 命名风格良好的命名风格让你的.proto 文件更加易读。 消息以及字段名称使用 CamelCase 方式命名消息名称，使用下划线分隔的名字来命名消息的字段，例如: 123message SongServerRequest &#123; required string song_name = 1;&#125; 枚举类型使用 CamelCase 方式命名消息名称，例如 PhoneType 使用大写字母+下划线来命名枚举值，例如: 12345enum PhoneType &#123; TYPE_MOBILE = 0; TYPE_HOME = 1; TYPE_WORK = 2;&#125; 服务如果你的.proto 文件定义了 RPC 服务，你可以使用 CamelCase 的方式命名你的服务名与RPC 方法名: 123service FooService &#123; rpc GetSomething(FooRequest) returns (FooResponse);&#125; 编码原理本节主要介绍 protocol buffer 消息转换成二进制格式的原理。如果仅需要了解怎么使 用 protocol buffers，你可以无需理解这些原理，但了解这些能帮助你理解 protocol buffers 对编码后数据大小的影响。 一个简单的消息下面是一个简单的消息定义: 123message Test1 &#123; required int32 a = 1;&#125; 若你创建了一个 Test1的消息，然后 a 赋值为150，序列化后，你会发现消息被编码为 下面3个字节: 108 96 01 看起来非常小巧与数字化，但它代表什么意义?继续看下去，好戏还在后头…… 变长整型(varint)为了理解 protocol buffer 的编码原理，你首先需要理解 varint 的概念。Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小 的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。注意，采用 Varint 表示法，大的数字则需要更多个 byte 来表示。从统计的角度来说，一般不会所有消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。Varint 中的每个 byte 的最高位 most significant bit (msb) 有特殊的含义，如果 该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示:1010 1100 0000 0010，以下是它的解码过程: 首先按照字节分组: 11010 1100 0000 0010 去掉 msb 1010 1100 000 0010 将字节反向排列 1000 0010 010 1100 重新组合成字节 1000 001 0010 1100 → 100101100=300 消息结构一个 protocol buffer 消息是一系列的键-值对。序列化后的二进制消息仅使用字段数字为 key。当消息被编码后，键值对被组织成一个字节流。消息在解码后，解析器能够忽略不认识 的字段。按照这样的方式，旧程序能够忽略不认识的新增字段。最后，”key”实际上是由两个值组成的，其中一个是.proto 文件的字段数字标号，另外一个是 wire types，这样才 能提供足够的信息去找到接下来数据的长度。下面是可用的wire types: Type Meaning Used For 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimited string, bytes, embedded messages, packed repeated fields 3 Start group groups (deprecated) 4 End group groups (deprecated) 5 32-bit fixed32, sfixed32, float 每个消息流的 key 都是一个 varint 类型，它的值为(field_number &lt;&lt; 3) | wire_type 。换句话说，最后三位用于保存 wire type 。 比如 key 是08，去掉 msb 位后如下: 1000 1000 则field_number 和 wire type 分别为: 12field_number=0001wire_type=000 更多的值类型带符号整数在前面的例子中，所有的 protocol buffer 类型都是 wire type 0的 varints 类型。然 而，带符号整数 (sint32 and sint64)与标准的整型(int32 and int64)在编码时有很大的 区别。如果你使用 int32 或者 int64来表示一个负数，结果需要10个字节，因为它会被认为 是一个非常大的无符号整数。为此，对带符号整数使用 ZigZag 编码会更高效。ZigZag 编码用无符号数来表示有符号数字，正数和负数交错，这就是 zigzag 这个词 的含义了。使用 zigzag 编码时，与0距离越近，编码时使用的值越小，从统计意义层面来看， 这样编码更高效，因为数据通信中绝对值小的数据交互占的比例要高。下面是 ZigZag 的编 码表: Signed Original Encoded As 0 0 -1 1 1 2 -2 3 2147483647 4294967294 -2147483648 4294967295 换句话说，每个值 n 都使用以下方式编码: 12sint32:(n &lt;&lt; 1) ^ (n &gt;&gt; 31)sint34:(n &lt;&lt; 1) ^ (n &gt;&gt; 63) 注意到第二个位移部分(n &gt;&gt; 31)实际上是算术位移，所以若 n 是正数，算术位移后得到的数全部位都是0，若 n 是负数，算术位移后得到的数全部位都是1。 当 sint32或 sint64被解析时，它的值会被解码回原始的带符号数。 非 varint 数非 varint 的数据类型就非常简单了， double 和 fixed64是 wire type 1，它会告诉解 析器期望的是一个固定的64位数据块;类似的，float 和 fixed32是 wire type 5，它会告 诉解析器期望的是一个固定的32位数据块。无论何种情况，值都是以 little-endian 小端对 齐的字节顺序方式存储。 字符串wire type 2 (length-delimited) 意思是它的值先使用一个 varint 来表示编码后的 数据大小，而接下来就是相应长度的编码数据了。 123message Test2 &#123; required string b = 2;&#125; 设置 b 的值为”testing”，你会得到下面编码: 112 07 74 65 73 74 69 6e 67 分析 key，首先第一个字节12为: 10001 0010 msb 为0，表示 key 仅用一个字节表示，去掉 msb: 1001 0010 根据 key 的解码办法，得到: 12field_number = 0010 = 2wire_type = 010 = 2 分析第二个字节07，根据 varint 编码可知数据长度为7，然后紧跟后面的7个字节则为 “testing”。 嵌套消息下面 Test3是一个嵌套消息: 1234567message Test1 &#123; required int32 a = 1;&#125;message Test3 &#123; required Test1 c = 3;&#125; 如果将 Test1的 a 字段赋值为150，则得到下面的编码: 11a 03 08 96 01 还记得编码原理刚开始提到的“一个简单的消息”吗?后面3个字节是否似曾相识？而Test3是嵌套消息，它的 wire type = 2，请参照该类型的编码办法即可解码。 可选与重复元素Optional 可选字段optional 可选元素在消息编码时可以有0或者1个键值对。 Repeated 重复字段Repeated 字段序列化时，序列化的结果中包含0个或多个 key-value，每个 key-value 都包含字段的 tag。PB2.1.0版本中提供了另外一种 Repeated 字段，即带有[packed=true]属性的 Repeated 字段，这种字段又称为:packedrepeated field。packed repeated field 字段序列化时，有0个或多个元素，并且所有的 元素打包在一个 key-value 中，key-value 的类型采用 wire type 2 (length-delimited)，每个元素不需要提供各自的 tag。下面是一个例子: 123message Test4 &#123; repeated int32 d = 4 [packed=true];&#125; 序列化字节码: 1234522 // tag (field number 4, wire type 2)06 // payload size (6 bytes)03 // first element (varint 3)8E 02 // second element (varint 270)9E A7 05 // third element (varint 86942) 相关序列化与反序列化技术的性能比较本章节内容摘自thrift-protobuf-compare。作者提到，数值并非一切，仅供参考，实际上测试结果会受硬件，测试用例等影响。 总耗时(包括对象创建，序列化与反序列化): 序列化时间(每次序列化的时间，包括对象创建时间): 反序列化时间: 序列化大小: 对象创建时间: 从上面的数据来看，protocol buffers 在序列化与反序列化性能及序列化后的数据大 小方面都不有错的表现。 参考资料 https://developers.google.com/protocol-buffers/Protocol-buffers 的官方介绍，本教程的主要参考资料。 http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/Protocol Buffers 原理的中文介绍。 http://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking#Object_Creation_Time Protocol Buffers 与其他相关技术的性能对比。 http://www.cppblog.com/liquidx/archive/2009/06/23/88366.html http://blog.csdn.net/hguisu/article/details/20721109]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>PB</tag>
        <tag>Protocol Buffers</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The background of this blog]]></title>
    <url>%2F2017%2F07%2F23%2FThe-background-of-this-blog%2F</url>
    <content type="text"><![CDATA[欢迎浏览本博客。作为第一篇非技术类的文章，可能没什么干货分享，但总感觉应该写点什么。好吧，就谈谈开博背景！ 自由。本人喜欢自由的写作，在其他博客平台，总有各种各样的限制，比如审核。自己的博客，样式随便改。 简洁。喜欢MarkDown的简洁，也喜欢简洁的博客主题。 分享。无他，写博客就为了分享。当然，这也是大家相互学习的一种有效途径。 精彩。人生在世，不过短短几十年，我们不是什么伟人，但这可以记录我们的精彩。 战斗吧，兄弟！]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hello World</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
