<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[golang 调试分析方法]]></title>
    <url>%2F2022%2F04%2F10%2Fgolang-debug-and-profile%2F</url>
    <content type="text"><![CDATA[断点调试Visual Studio Code创建配置VSCode IDE要运行或者调试golang程序之前，需要创建运行配置 launch.json ，方法如下： 打开菜单“运行”-&gt;“添加配置”，在创建的配置添加如下内容： 1234567891011121314151617&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Launch Package&quot;, &quot;type&quot;: &quot;go&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;mode&quot;: &quot;auto&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/main.go&quot;, &quot;args&quot;: [] &#125; ]&#125; 配置说明：cwd：当前工作目录，可以使用变量 ${workspaceFolder} 。program：可执行程序或者文件。args：程序运行所需参数，数组类型。 更多配置的用法请参考 visualstudio debugging 调试方法设置断点，如下图所示： 使用快捷键F5，或者打开菜单，点击“运行”-&gt;“启动调试”，调试主界面如下，这样就可以愉快的调试了。 GoLand创建配置打开菜单，“Run”-&gt;“Debug” 在弹出框选“Edit Configurations” 编辑配置如下图所示，编辑完后点击Apply应用即可完成。 调试方法设置断点，如下图所示 启动debug，MAC快捷键control+option+D，或者点击菜单“Run”-&gt;“Debug”，选择之前创建的配置，即可调试，如下图所示： 性能分析pprofpprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，包括CPU、内存、goroutine、锁等。golang标准库提供了以下两种使用方式： net/http/pprof：采集 HTTP Server 的运行时数据进行分析 runtime/pprof：采集程序（含Server和非Server）的运行数据进行分析 另外，golang也提供了比较多好用的可视化工具来负责开发者做分析，使用方式包括报告的生成、交互式终端和Web界面。 pprof工具准备12345678910111213141516# 安装pprof工具go install github.com/google/pprof@latest# 安装图形化依赖工具 Graphviz# 以Mac为例，其他平台安装方法请参考 https://graphviz.org/download/brew install Graphviz# Mac平台如果安装有报错，比如==&gt; Pouring jasper-3.0.2.arm64_monterey.bottle.tar.gzError: No such file or directory @ rb_sysopen - /Users/xxx/Library/Caches/Homebrew/downloads/d3af18f496d6e7cae9775e1e69ea79074687e03221367f075c3a6e6f2c77c705--jasper-3.0.2.arm64_monterey.bottle.tar.gz# 可以手工逐个安装报错的依赖，比如brew install jasperbrew install gdk-pixbufbrew install pangobrew install librsvg 分析使用本例使用的完整 demo 放在 go-learing 的 examples/pprof 目录下。 标准库自带Web界面使用方法简单的demo 123456789101112package mainimport ( &quot;log&quot; &quot;net/http&quot; _ &quot;net/http/pprof&quot;)func main() &#123; log.Printf(&quot;pprof demo is running&quot;) http.ListenAndServe(&quot;0.0.0.0:8090&quot;, nil)&#125; 本例子使用标准库提供的 “net/http/pprof” 包，通过import该包后，HTTP服务程序就会注入 /debug/pprof 相关的路由，可以访问 http://localhost:8090/debug/pprof/ 查看总览，如下所示 12345678910111213/debug/pprof/Types of profiles available:Count Profile3 allocs0 block0 cmdline4 goroutine3 heap0 mutex0 profile7 threadcreate0 trace 下面是各种 profile 的描述： allocs: A sampling of all past memory allocations. 过去所有内存分配的抽样。 block: Stack traces that led to blocking on synchronization primitives. 导致同步原语阻塞的堆栈跟踪。 cmdline: The command line invocation of the current program. 当前程序的命令行调用。 goroutine: Stack traces of all current goroutines. 堆栈当前所有goroutines的跟踪。 heap: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample. 活动对象的内存分配抽样。在获取堆样本之前，可以指定gc GET参数来运行gc。 mutex: Stack traces of holders of contended mutexes. 竞争互斥锁持有者的堆栈跟踪。 profile: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile. CPU profile。可以在GET参数中指定以秒为单位的持续时间，默认是30s。在获得profile文件之后，使用go工具pprof命令来研究它。 threadcreate: Stack traces that led to the creation of new OS threads. 导致创建新的操作系统线程的堆栈跟踪。 trace: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace. 当前程序执行的痕迹。可以在GET参数中指定以秒为单位的持续时间。在获得trace文件之后，使用go工具 trace 命令来研究它。 pprof工具的交互式终端使用方法12345# 方法一go tool pprof $&#123;source&#125;# 方法二，前提是要安装 pprof ，具体方法请查看“ pprof 工具准备”章节pprof $&#123;source&#125; source可以是通过”net/http/pprof” 包提供的http url ，也可以是本地 profile 文件。 cpu分析12345678910111213141516171819202122232425262728293031323334353637$ go tool pprof http://localhost:8090/debug/pprof/profile?seconds=15Fetching profile over HTTP from http://localhost:8090/debug/pprof/profile?seconds=15Saved profile in /Users/xxx/pprof/pprof.samples.cpu.004.pb.gzType: cpuTime: Apr 5, 2022 at 3:13pm (CST)Duration: 15s, Total samples = 290ms ( 1.93%)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof) help Commands: callgrind Outputs a graph in callgrind format comments Output all profile comments disasm Output assembly listings annotated with samples dot Outputs a graph in DOT format eog Visualize graph through eog evince Visualize graph through evince gif Outputs a graph image in GIF format gv Visualize graph through gv kcachegrind Visualize report in KCachegrind list Output annotated source for functions matching regexp pdf Outputs a graph in PDF format peek Output callers/callees of functions matching regexp png Outputs a graph image in PNG format proto Outputs the profile in compressed protobuf format ps Outputs a graph in PS format raw Outputs a text representation of the raw profile svg Outputs a graph in SVG format tags Outputs all tags in the profile text Outputs top entries in text form top Outputs top entries in text form topproto Outputs top entries in compressed protobuf format traces Outputs all profile samples in text form tree Outputs a text rendering of call graph web Visualize graph through web browser weblist Display annotated source in a web browser o/options List options and their current values q/quit/exit/^D Exit pprof 执行该命令后，需等待seconds参数指定的时间（默认30s），采样完成后，即可用交互式命令进行分析，具体可以使用 help 指令查看说明，比如 top 可以查看占用 cpu 最多的 n 个记录。 1234567(pprof) topShowing nodes accounting for 290ms, 100% of 290ms total flat flat% sum% cum cum% 280ms 96.55% 96.55% 280ms 96.55% github.com/rukesun/go-learning/examples/pprof/internal/simulator.(*XXCPU).Run 10ms 3.45% 100% 10ms 3.45% runtime.memmove 0 0% 100% 10ms 3.45% github.com/rukesun/go-learning/examples/pprof/internal/simulator.(*XXHeap).Run 0 0% 100% 10ms 3.45% runtime.growslice flat：该位置的运行耗时 flat%：该位置的 CPU 运行耗时总比例 sum%：该位置累积使用 CPU 总比例 cum：该位置加上它的子调用运行总耗时 cum%：该位置加上它的的子调用的 CPU 运行耗时总比例 最后一列为函数调用的位置。 1234567891011121314151617181920(pprof) help listOutput annotated source for functions matching regexp Usage: list&lt;func_regex|address&gt; [-focus_regex]* [-ignore_regex]* Include functions matching func_regex, or including the address specified. Include samples matching focus_regex, and exclude ignore_regex.(pprof) list RunTotal: 300msROUTINE ======================== github.com/rukesun/go-learning/examples/pprof/internal/simulator.(*XXCPU).Run in /Users/ht/research/golang/go-learning/examples/pprof/internal/simulator/xxcpu.go 270ms 300ms (flat, cum) 100% of Total . . 16:&#125; . . 17: . . 18:func (c *XXCPU) Run() &#123; . . 19: log.Printf(&quot;%v Run&quot;, c.Name()) . . 20: loop := 1000000000 270ms 300ms 21: for i := 0; i &lt; loop; i++ &#123; . . 22: // do nothing . . 23: &#125; . . 24:&#125; 通过list命令可以查看关联的代码，比如这里可以看出XXCPU的Run方法里面，有个循环的代码会消耗较多的 cpu 。 内存分析 1234567891011121314151617181920212223242526272829$ go tool pprof http://localhost:8090/debug/pprof/heap(pprof) topShowing nodes accounting for 36353.94kB, 100% of 36353.94kB totalShowing top 10 nodes out of 20 flat flat% sum% cum cum% 32768kB 90.14% 90.14% 32768kB 90.14% github.com/rukesun/go-learning/examples/pprof/internal/simulator.(*XXHeap).Run 2048.81kB 5.64% 95.77% 2048.81kB 5.64% runtime.malg 1025.12kB 2.82% 98.59% 1025.12kB 2.82% runtime.allocm 512kB 1.41% 100% 512kB 1.41% runtime.doaddtimer 0 0% 100% 512kB 1.41% runtime.mcall 0 0% 100% 512kB 1.41% runtime.modtimer 0 0% 100% 1025.12kB 2.82% runtime.mstart 0 0% 100% 1025.12kB 2.82% runtime.mstart0 0 0% 100% 1025.12kB 2.82% runtime.mstart1 0 0% 100% 1025.12kB 2.82% runtime.newm(pprof) list RunTotal: 35.50MBROUTINE ======================== github.com/rukesun/go-learning/examples/pprof/internal/simulator.(*XXHeap).Run in /Users/xxx/research/golang/go-learning/examples/pprof/internal/simulator/xxheap.go 32MB 32MB (flat, cum) 90.14% of Total . . 17:&#125; . . 18: . . 19:func (h *XXHeap) Run() &#123; . . 20: log.Printf(&quot;%v Run&quot;, h.Name()) . . 21: for i := 0; i &lt; 10; i++ &#123; 32MB 32MB 22: h.data = append(h.data, [1024 * 1024]byte&#123;&#125;) . . 23: &#125; . . 24: log.Printf(&quot;After %v Run, len:%v, cap:%v&quot;, h.Name(), len(h.data), cap(h.data)) . . 25:&#125; 同样通过top和list大法，找出内存分配较多的地方。 协程分析12345678910111213141516171819202122232425262728293031$ go tool pprof http://localhost:8090/debug/pprof/goroutineFetching profile over HTTP from http://localhost:8090/debug/pprof/goroutineSaved profile in /Users/xxx/pprof/pprof.goroutine.001.pb.gzType: goroutineTime: Apr 5, 2022 at 3:24pm (CST)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof) topShowing nodes accounting for 3002, 100% of 3003 totalDropped 27 nodes (cum &lt;= 15) flat flat% sum% cum cum% 3002 100% 100% 3002 100% runtime.gopark 0 0% 100% 3000 99.90% github.com/rukesun/go-learning/examples/pprof/internal/simulator.(*XXGoroutine).Run.func1 0 0% 100% 3000 99.90% time.Sleep(pprof) list RunTotal: 3003ROUTINE ======================== github.com/rukesun/go-learning/examples/pprof/internal/simulator.(*XXGoroutine).Run.func1 in /Users/xxx/research/golang/go-learning/examples/pprof/internal/simulator/xxgoroutine.go 0 3000 (flat, cum) 99.90% of Total . . 18: . . 19:func (g *XXGoroutine) Run() &#123; . . 20: log.Printf(&quot;%v Run&quot;, g.Name()) . . 21: for i := 0; i &lt; 1000; i++ &#123; . . 22: go func() &#123; . 3000 23: time.Sleep(3600 * time.Second) . . 24: &#125;() . . 25: &#125; . . 26:&#125;ROUTINE ======================== runtime/pprof.writeRuntimeProfile in /Users/xxx/.gvm/gos/go1.18/src/runtime/pprof/pprof.go 0 1 (flat, cum) 0.033% of Total 同样通过top和list大法，找出协程分配较多的地方。 pprof工具的可视化界面使用方法123456789# 方法一go tool pprof -http=:8091 $&#123;source&#125;# 方法二，前提是要安装 pprof ，具体方法请查看“ pprof 工具准备”章节pprof -http=:8091 $&#123;source&#125;# 方法三，在交互式界面上执行 web 指令go tool pprof $&#123;source&#125;(pprof) web cpu分析执行命令 1go tool pprof -http=:8091 http://localhost:8090/debug/pprof/profile?seconds=15 可视化Graph框越大线越粗，代表该代码处占用的时间越长。 可视化Top 可视化火焰图 火焰图（Flame Graph）是由 Linux 性能优化大师 Brendan Gregg 发明的，它以一个全局的视野来看待时间分布，并且列出所有可能导致性能瓶颈的调用栈。火焰图有以下特征： 每一列代表一个调用栈，每一个格子代表一个函数。 纵轴展示了栈的深度，正立火焰图按照调用关系从下到上排列（倒立火焰图方向刚好相反）。 横轴部分，火焰图将采集的多个调用栈信息，通过按字母横向排序的方式将众多信息聚合在一起。需要注意的是它并不代表时间的先后。横轴格子的宽度代表其在采样中出现频率，所以一个格子的宽度越大，说明它是瓶颈原因的可能性就越大。 火焰图格子的颜色是随机的暖色调，方便区分各个调用信息。 可视化Peek 可视化Source 内存分析1go tool pprof -http=:8091 http://localhost:8090/debug/pprof/heap 可视化Graph其他图表请参考 cpu 分析部分，这里不再一一列举。 协程分析执行命令 1go tool pprof -http=:8091 http://localhost:8090/debug/pprof/goroutine 可视化Graph其他图表请参考 cpu 分析部分，这里不再一一列举。 使用runtime/pprof生成profile文件调试之前的章节使用 net/http/pprof 提供的 HTTP 接口进行调试分析，如果是非 HTTP 的程序或者因为数据安全问题，我们不想暴露 HTTP 接口，那么我们该如何分析调试？答案是在代码中引入 runtime/pprof 包，示例代码如下： 12345678910111213141516171819202122232425262728293031323334var cpuprofile = flag.String(&quot;cpuprofile&quot;, &quot;&quot;, &quot;write cpu profile to `file`&quot;)var memprofile = flag.String(&quot;memprofile&quot;, &quot;&quot;, &quot;write memory profile to `file`&quot;)func main() &#123; flag.Parse() if *cpuprofile != &quot;&quot; &#123; f, err := os.Create(*cpuprofile) if err != nil &#123; log.Fatal(&quot;could not create CPU profile: &quot;, err) &#125; defer f.Close() // error handling omitted for example // 启动CPU Profile if err := pprof.StartCPUProfile(f); err != nil &#123; log.Fatal(&quot;could not start CPU profile: &quot;, err) &#125; // 停止CPU Profile defer pprof.StopCPUProfile() &#125; // ... rest of the program ... if *memprofile != &quot;&quot; &#123; f, err := os.Create(*memprofile) if err != nil &#123; log.Fatal(&quot;could not create memory profile: &quot;, err) &#125; defer f.Close() // error handling omitted for example runtime.GC() // get up-to-date statistics // 生成当前内存统计的 Heap Profile if err := pprof.WriteHeapProfile(f); err != nil &#123; log.Fatal(&quot;could not write memory profile: &quot;, err) &#125; &#125;&#125; 完整代码请参考 demo 工程的 pprof/internal/xxprof/xxprof.go ，通过上面的代码生成相关的 profile 文件之后，使用 pprof 工具即可分析调试。 另外，为了便于使用，我们可以结合 signal 来使用，示例代码 12345678910111213141516171819202122232425262728293031323334353637package xxsignalimport ( &quot;log&quot; &quot;os&quot; &quot;os/signal&quot; &quot;syscall&quot; &quot;github.com/rukesun/go-learning/examples/pprof/internal/xxprof&quot;)func init() &#123; go func() &#123; var profiler *xxprof.Profile signals := make(chan os.Signal, 1) signal.Notify(signals, syscall.SIGUSR1, syscall.SIGUSR2) for &#123; v := &lt;-signals log.Printf(&quot;Got signal:&quot;, v) switch v &#123; case syscall.SIGUSR1: case syscall.SIGUSR2: if profiler == nil &#123; profiler = xxprof.NewProfile() profiler.Start() &#125; else &#123; profiler.Stop() profiler = nil &#125; default: log.Printf(&quot;Got unregistered signal:&quot;, v) &#125; &#125; &#125;()&#125; 在需要使用的程序 import xxsignal ，然后通过kill发送相关的信号即可。注意，使用 signal 时，需要使用 go build 编译成二进制可执行文件，通过 go run 的方式则不能捕获相关的信号。 1kill -SIGUSR2 $&#123;pid&#125; 参考资料 Debugging in Visual Studio Code, https://code.visualstudio.com/docs/editor/debugging Running | Goland, https://www.jetbrains.com/help/go/running-applications.html Debugging | Goland, https://www.jetbrains.com/help/go/debugging-code.html PProf README, https://github.com/google/pprof/blob/master/doc/README.md Profiling a Go program, https://pkg.go.dev/runtime/pprof@go1.18#hdr-Profiling_a_Go_program Go tool pprof, https://github.com/eddycjy/blog/blob/master/content/posts/go/tools/2018-09-15-go-tool-pprof.md Go pprof practice, https://blog.wolfogre.com/posts/go-ppof-practice/ Go Zero profile, https://github.com/zeromicro/go-zero/blob/master/core/proc/profile.go]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>programing</tag>
        <tag>golang</tag>
        <tag>pprof</tag>
        <tag>vscode</tag>
        <tag>goland</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git commit格式参考]]></title>
    <url>%2F2020%2F03%2F22%2Fgit-commit-guidelines%2F</url>
    <content type="text"><![CDATA[前言编写良好的Commit messages可以达到以下几个重要的目的 加快review的流程 帮助我们编写良好的版本发布日志 让之后的维护者了解代码里出现特定变化和feature被添加的原因 目前，社区有多种 Commit message 的写法规范。来自Angular 规范是目前使用最广的写法，比较合理和系统化。如下图： Commit messages格式当前业界应用的比较广泛的是 Angular Git Commit Guidelines 具体格式为: 12345&lt;type&gt;: &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 每个commit message一般包含header、body和footer，header是必须的，body和footer不做强制要求，所以一般可以简化为 1&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; 或者省略scope 1&lt;type&gt;: &lt;subject&gt; 说明 type: 本次 commit 的类型，诸如 bugfix docs style 等 scope: 本次 commit 波及的范围 subject: 简明扼要的阐述下本次 commit 的主旨 body: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机 footer: 描述下与之关联的 issue 或 break change，详见案例 例子 12345678feat(jqLite): add prop() supportfix(ngStyle): correctly remove old style when new style value is invaliddocs(developers): commit message format typostyle(animator): style cleanuprefactor(filter): filters are now injectable and servicesperf(*): don&apos;t trigger digests after enter/leave of structural directivestest(mocks): test mocks with compiled angularchore(release): preparing release notes for 0.10.3 Type类型必须是以下其中一种 feat: 新功能 fix: bug fix docs: 只改了文档 style: 代码格式修改，不影响代码的逻辑性，比如空格，格式化，缺失分号等 refactor: 代码重构，既不是bug fix也不是新功能 perf: 性能优化 test: 补充或修改测试代码 chore: 改变构建流程，或者增加依赖库和工具等，比如增加文档生成工具 Scope范围可以是指定提交更改位置的任何内容，比如search, location, browser, compile等 你可以使用*来代替多个范围 Subject主题包含对变更的简洁描述，有几个要求 使用祈使句和现代时，比如使用change而不是changed或者changes 首字母不要大写 句末无需使用句号 Body主体与主题一样，应使用祈使句和现代时，应包括改变的动机，并将其与以前的行为进行对比。 Footer描述一些重大的修改和相关的问题，详情参考 AngularJS Message footer Revert当回滚提交时，必须以 revert: 作为开头然后紧跟着该提交的header。 body部分可以这样描述 12This reverts commit &lt;hash&gt;. hash是将要被回滚的那个提交的SHA码。 参考您必须知道的 Git 分支开发规范angular.js-git-commit-guidelinesAngularJS Git Commit Message Conventions]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Git Commit</tag>
        <tag>Git</tag>
        <tag>Manual</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git开发规范参考]]></title>
    <url>%2F2020%2F03%2F22%2Fone-git-flow%2F</url>
    <content type="text"><![CDATA[分支管理git 的分支管理功能非常强大，为了提高效率、避免分支混乱，我们参考git flow的开发流程规范或者可以直接使用git flow工具。 分支构成主要分支master分支：永远处在即将发布（production-ready）状态；develop分支：为开发分支，始终保持最新完成以及bug修复后的代码。 辅助分支feature分支：开发新功能的分支，基于develop，开发完成后merge回develop；release分支：准备要发布版本的分支（测试环境用的），用来修复SIT（System Integration Testing） bug；基于develop分支，完成后merge回develop和master分支；hotfix分支：修复线上（master）紧急bug，等不及release分支就必须马上上线；基于master分支，完成后merge回master和develop分支。 命名规范约定如下： feature分支命名：feature/name release分支命名：release/name hotfix分支命名：hotfix/name 常见的开发流程增加新功能12345(develop)$: git checkout -b feature/xxx # 从develop建立功能分支(feature/xxx)$: blabla # 开发(feature/xxx)$: git add xxx(feature/xxx)$: git commit -m &apos;commit comment&apos;(develop)$: git merge feature/xxx --no-ff # 把功能分支合并到develop 修复紧急bug123456(master)$: git checkout -b hotfix/xxx # 从master建立hotfix分支(hotfix/xxx)$: blabla # 开发(hotfix/xxx)$: git add xxx(hotfix/xxx)$: git commit -m &apos;commit comment&apos;(master)$: git merge hotfix/xxx --no-ff # 把hotfix分支合并到master，并上线到生产环境；注意，非管理员请用Merge Request；(develop)$: git merge hotfix/xxx --no-ff # 把hotfix分支合并到develop，同步代码 测试环境发布测试123(develop)$: git checkout -b release/x.y.z # 从develop建立预发布分支(release/x.y.z)$: blabla # 开发或者从其他feature分支合并代码(release/x.y.z)$: git merge develop --no-ff # 把develop分支合并到release/x.y.z，然后在测试环境拉取并测试 生产环境上线12(master)$: git merge release/x.y.z --no-ff # 把release/x.y.z或者develop测试好的代码合并到master(master)$: git tag -a 0.1.0 -m &apos;xxx&apos; # 给版本命名，打Tag 注意：这一步由master管理员做，普通开发人员合并代码请用Merge Request。 Tag管理Tag生成时间master分支每次发布时，必须打tag。 Tag命名规范版本格式：主版本号.次版本号.修订号，如：1.0.1。 版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改；项目架构发生巨大变化； 次版本号：当你做了向下兼容的功能性新增； 修订号：当你做了向下兼容的问题修正；小的修改，如代码格式修正等。 参考您必须知道的 Git 分支开发规范分支管理规范git分支管理和工作流规范：具体规范]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Manual</tag>
        <tag>GitFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow安装教程]]></title>
    <url>%2F2020%2F03%2F01%2Ftensorflow-install%2F</url>
    <content type="text"><![CDATA[TensorFlow 安装环境要求TensorFlow在以下64位系统环境下经过测试和支持 Python 3.5–3.7 macOS 10.12.6 (Sierra) or later (no GPU support) Ubuntu 16.04 or later Raspbian 9.0 or later Windows 7 or later 在mac OS上安装在mac OS上通常有两种安装方法virtualenv+pip和docker。 通过virtualenv + pipPython 3 要求 Python 3.5–3.7pip &gt;= 19.0 Python 2.7 要求 Python == 2.7pip &gt;= 19.0 安装Pthon开发环境这里以Python 3 为例，如果你没有安装Python，pip和Virtualenv，请参考下面的方法，否则跳过这一步 12345/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot;brew updatebrew install python # Python 3sudo pip3 install -U virtualenv # system-wide install 创建一个VirtualenvVirtualenv 可以做到与其他 Python 开发隔离的虚拟环境。下面是在 ./py3x 目录下创建一个Python 3 的虚拟环境1virtualenv --system-site-packages -p python3 ./py3x 激活虚拟环境1source ./py3x/bin/activate # sh, bash, ksh, or zsh 在虚拟环境中升级pip1pip install --upgrade pip 如果不想使用虚拟环境，可以使用下面的命令退出1deactivate # don&apos;t exit until you&apos;re done using TensorFlow 通过pip安装TensorFlowpip有下面三种不同的TensorFlow包： tensorflow：最新稳定发布版 tf-nightly：预览版，可能不稳定 tensorflow==1.15：TensorFlow 1.x 的最后一个版本 安装示例1pip install --upgrade tensorflow 校验是否安装成功1python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot; 通过dockerDocker 使用容器创建虚拟环境，以便将 TensorFlow 安装与系统的其余部分隔离开来。 官方 TensorFlow Docker 的镜像位于 tensorflow/tensorflow。下面是各标签的说明 标签 说明 latest TensorFlow 最新稳定版。 nightly TensorFlow 预览版（不稳定）。 version TensorFlow 指定版本，如1.15.0。 devel TensorFlow开发版，包含源码。 上面的标签也有一些变体，下面是相关的说明 标签变体 说明 tag-gpu 支持 GPU 的指定标签版本。 tag-py3 支持 Python 3 的指定标签版本。 tag-jupyter 带有 Jupyter 的指定标签版本（包含 TensorFlow 教程）。 这里假定你已经安装Docker，先拉取镜像，以支持 Python 3 的最新 TensorFlow 版本为例1docker pull tensorflow/tensorflow:latest-py3 # Download latest stable image 其他版本示例 123docker pull tensorflow/tensorflow # latest stable releasedocker pull tensorflow/tensorflow:devel-gpu # nightly dev release w/GPU supportdocker pull tensorflow/tensorflow:latest-gpu-jupyter # latest release w/ GPU support and Jupyter 启动 TensorFlow Docker 容器 1docker run [-it] [--rm] [-p hostPort:containerPort] tensorflow/tensorflow[:tag] [command] 以启动支持 Python 3 的最新 TensorFlow 版本为例 1docker run -it -p 8080:8080 tensorflow/tensorflow:latest-py3 启动 Python，验证你的环境 123&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; print(tf.__version__)2.1.0 在Linux上安装Linux上安装完Virtualenv或者Docker后，其他方法是一样的，不再详细说明。 参考[1] Install TensorFlow with pip[2] Install TensorFlow with Docker]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>DeepLearning</tag>
        <tag>Install</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐的学习资源]]></title>
    <url>%2F2019%2F12%2F01%2Frecommended-study-resources%2F</url>
    <content type="text"><![CDATA[推荐的学习资源列表Golang语言the-way-to-go (recommend)golang.org (official) 数据库Mongodbmongodb-tutorial (recommend)docs.mongodb.com (official) Redisredis-tutorial (recommend)redisdocredis.io (official) SQLsql-tutorialmysql-tutorialdev.mysql.com (official) Nginxnginx.org (official)Nginx 配置详解Nginx 反向代理与负载均衡详解OpenResty最佳实践-NginxNginx开发从入门到精通]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Resource</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建个人私有云盘]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98%2F</url>
    <content type="text"><![CDATA[前言市场上有很多云盘的产品，比如百度云盘，不过本教程主要目的是要搭建个人私有云盘。查了网上很多资料，个人云盘也有很多，比如nextcloud，owncloud，seafile等。这里选择nextcloud，优势就不用说了，网上一搜一大把。 Nextcloud搭建办法主要的搭建办法有两个： 通过VPS一键安装 手动安装 通过VPS一键安装Vultr有一键安装Nextcloud的功能，非常方便。主要步骤如下： 注册vps 创建vps实例 Server Location -&gt; 选择一个好的机房，比如洛杉矶，日本和新加坡等。 Server Type -&gt; 选Application，选中Nextcloud Server Size -&gt; 根据自己需要选择 剩下的配置使用默认即可 首先，登陆Vultr官网，点击Create Account注册。选择一个好的机房，当然是自己测过才放心。这里推荐使用PingInfoView来测试。以下是vultr的机房： 列表如下，贴到PingInfoView上即可。 123456789101112131415sgp-ping.vultr.comhnd-jp-ping.vultr.comsyd-au-ping.vultr.comfra-de-ping.vultr.comams-nl-ping.vultr.comlon-gb-ping.vultr.compar-fr-ping.vultr.comwa-us-ping.vultr.comsjo-ca-us-ping.vultr.comlax-ca-us-ping.vultr.comil-us-ping.vultr.comnj-us-ping.vultr.comtx-us-ping.vultr.comga-us-ping.vultr.comfl-us-ping.vultr.com linux/mac用户可以使用我写的脚本vultr_test来测试。以下是我的测试结果：选择的原则是，ping值最小，丢包率最小。比如我的测试结果中，较不错的是sjo、wa和lax，都是美国机房。 接下来Server Type选Application，选中Nextcloud，如下所示根据自己的需要选择Server Size，剩下的配置使用默认即可。点击Deploy Now，然后静静地等待1~2分钟。部署完成后，查看实例详情，可以看到Nextcloud的地址，登陆账号和密码。打开你的Nextcloud地址，会提示不安全，这个是ssl证书问题，你可以直接忽略。下面是打开后的界面怎么样，是不是很期待？输入账号和密码，点击登录，网盘就可以使用了可以传视频，文档，可以自定义目录，更多的功能等待你去探索！好了，是不是有点小激动？麻麻再也不用担心我的小电影没地方放了。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>nextcloud</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang学习资料]]></title>
    <url>%2F2018%2F10%2F27%2Fgolang%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[基础golang.orgthe-way-to-goGo语言圣经 规范与习惯project-layoutCodeReviewCommentsEffective GoEffective Go中文版 APIGo PackagesTencent developer doc for Go 资源Go Projectsgo-study-index]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>programing</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg的那些坑-RTP missed xxx packets]]></title>
    <url>%2F2018%2F07%2F01%2FFFmpeg%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91-RTP-missed-xxx-packets%2F</url>
    <content type="text"><![CDATA[FFmpeg使用场景使用FFmpeg将两路RTP流合成一路流1ffmpeg -acodec libopus -i ../var/tmp/1024_0.sdp -acodec libopus -i ../var/tmp/1024_1.sdp -filter_complex &quot;[0:v]setpts=PTS-STARTPTS,setsar=1[left];[1:v]setpts=PTS-STARTPTS,setsar=1[right];[left][right]hstack[vout];[0:a][1:a]amix[aout]&quot; -map [vout] -map [aout] -vcodec libx264 -profile:v high -preset veryfast -strict -2 -acodec aac -f flv rtmp://localhost:1935/live/1024 问题FFmpeg日志提示RTP: missed xxx packets合流视频花屏。 12345678910111213[h264 @ 0x45c05a0] Invalid level prefix[h264 @ 0x45c05a0] error while decoding MB 11 19[h264 @ 0x45c05a0] concealing 53 DC, 53 AC, 53 MV errors in I frame[sdp @ 0x42e5c20] max delay reached. need to consume packet[sdp @ 0x42e5c20] RTP: missed 16 packets[sdp @ 0x42e5c20] max delay reached. need to consume packet[sdp @ 0x42e5c20] RTP: missed 4 packets[h264 @ 0x45c05a0] negative number of zero coeffs at 0 4[h264 @ 0x45c05a0] error while decoding MB 0 4[h264 @ 0x45c05a0] concealing 289 DC, 289 AC, 289 MV errors in P frame[h264 @ 0x4413420] Invalid level prefix[h264 @ 0x4413420] error while decoding MB 9 19[h264 @ 0x4413420] concealing 55 DC, 55 AC, 55 MV errors in P frame 原因FFmpeg默认接收线程数据队列大小thread_queue_size为8，当合流不够快时，接收数据队列溢出，导致RTP接收数据丢包。 解决办法使用thread_queue_size选项配置大一点的接收线程数据队列，如 1ffmpeg -thread_queue_size 512 -acodec libopus -i ../var/tmp/1024_0.sdp -thread_queue_size 512 -acodec libopus -i ../var/tmp/1024_1.sdp -filter_complex &quot;[0:v]setpts=PTS-STARTPTS,setsar=1[left];[1:v]setpts=PTS-STARTPTS,setsar=1[right];[left][right]hstack[vout];[0:a][1:a]amix[aout]&quot; -map [vout] -map [aout] -vcodec libx264 -profile:v high -preset veryfast -strict -2 -acodec aac -f flv rtmp://localhost:1935/live/1024]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>av</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg的那些坑-Too many packets buffered for output stream]]></title>
    <url>%2F2018%2F07%2F01%2FFFmpeg%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91-Too-many-packets-buffered-for-output-stream%2F</url>
    <content type="text"><![CDATA[FFmpeg使用场景使用FFmpeg给视频打水印 1ffmpeg -i test.mp4 -i watermark.png -acodec copy -preset veryfast -filter_complex &quot;overlay=x=20:y=20&quot; -y wm_test.mp4 问题报错Too many packets buffered for output stream 0:1. 1234567891011121314151617181920212223242526272829303132333435ffmpeg version 3.3-static http://johnvansickle.com/ffmpeg/ Copyright (c) 2000-2017 the FFmpeg developers built with gcc 5.4.1 (Debian 5.4.1-8) 20170304 configuration: --enable-gpl --enable-version3 --enable-static --disable-debug --disable-ffplay --disable-indev=sndio --disable-outdev=sndio --cc=gcc-5 --enable-fontconfig --enable-frei0r --enable-gnutls --enable-gray --enable-libass --enable-libfreetype --enable-libfribidi --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-libopus --enable-librtmp --enable-libsoxr --enable-libspeex --enable-libtheora --enable-libvidstab --enable-libvo-amrwbenc --enable-libvorbis --enable-libvpx --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxvid --enable-libzimg libavutil 55. 58.100 / 55. 58.100 libavcodec 57. 89.100 / 57. 89.100 libavformat 57. 71.100 / 57. 71.100 libavdevice 57. 6.100 / 57. 6.100 libavfilter 6. 82.100 / 6. 82.100 libswscale 4. 6.100 / 4. 6.100 libswresample 2. 7.100 / 2. 7.100 libpostproc 54. 5.100 / 54. 5.100Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &apos;test.mp4&apos;: Metadata: major_brand : isom minor_version : 512 compatible_brands: isomiso2avc1mp41 encoder : Lavf57.56.100 Duration: 00:00:26.94, start: 0.000000, bitrate: 434 kb/s Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 360x640, 367 kb/s, 6.16 fps, 14 tbr, 14336 tbn, 28 tbc (default) Metadata: handler_name : VideoHandler Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, mono, fltp, 63 kb/s (default) Metadata: handler_name : SoundHandlerInput #1, png_pipe, from &apos;watermark.png&apos;: Duration: N/A, bitrate: N/A Stream #1:0: Video: png, pal8(pc), 205x39, 25 tbr, 25 tbn, 25 tbcStream mapping: Stream #0:0 (h264) -&gt; overlay:main Stream #1:0 (png) -&gt; overlay:overlay overlay -&gt; Stream #0:0 (libx264) Stream #0:1 -&gt; #0:1 (copy)Press [q] to stop, [?] for helpToo many packets buffered for output stream 0:1.Conversion failed! 原因原因是有些视频数据有问题，导致视频处理过快，容器封装时队列溢出。 解决办法增大容器封装队列大小，比如 1-max_muxing_queue_size 1024 1ffmpeg -i test.mp4 -i watermark.png -max_muxing_queue_size 1024 -acodec copy -preset veryfast -filter_complex &quot;overlay=x=20:y=20&quot; -y wm_test.mp4]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>av</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多媒体框架GStreamer]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A1%86%E6%9E%B6GStreamer%2F</url>
    <content type="text"><![CDATA[前言注：原文出处多媒体框架GStreamer GStreamer is a library for constructing graphs of media-handling components. The applications it supports range from simple Ogg/Vorbis playback, audio/video streaming to complex audio (mixing) and video (non-linear editing) processing. GStreamer是一个轻便的多媒体框架，在TX1上默认并未提供V4L2驱动，需要手动安装，而且这个驱动是基于GStreamer的。此外，在TX1上支持的H.264和H.265硬解码也是通过GStreamer的。 基本概念PipelineGStreamer是通过管道和插件实现各种功能或构建各种流媒体应用的。管道的概念在shell中已经很常见了，不过GStreamer中的管道符号不是|而是!。GStreamer中将很多元素串联起来，类似管道的命令，将前者输出作为后者输入。如: 1gst-launch-1.0 filesrc location=a.mp3 ! decodebin ! audioconvert ! alsasink 其中，每个元素说明如下: filesrc: 从本地磁盘加载了一个文件，使用该元素时你设置了location 属性指向该文件。 decodebin: 使用该元素从filesrc解码。会自动检测文件的类型并在后台构造一些GStreamer元素来解码。 audioconvert: 音频转换元素。 alsasink: 将音频使用ALSA传递给声卡。 Element元素是GStreamer内置可使用在管道上的命令，GStreamer通过各种元素完成任务。可以使用gst-inspect-1.0命令来查看可使用的元素。当创建Pipeline时，需要为各个Element设置各种属性。GStreamer将GstElement细分成如下几类： Source Element: 数据源元素。只有输出端，它仅能用来产生供管道消费的数据，而不能对数据做任何处理。一个典型的数据源元素的例子是音频捕获单元，它负责从声卡读取原始的音频数据，然后作为数据源提供给其它模块使用。 Filter Element: 过滤器元素。既有输入端又有输出端，它从输入端获得相应的数据，并在经过特殊处理之后传递给输出端。一个典型的过滤器元素的例子是音频编码单元，它首先从外界获得音频数据，然后根据特定的压缩算法对其进行编码，最后再将编码后的结果提供给其它模块使用。 Sink Element: 接收器元素。只有输入端，它仅具有消费数据的能力，是整条媒体管道的终端。一个典型的接收器元素的例子是音频回放单元，它负责将接收到的数据写到声卡上，通常这也是音频处理过程中的最后一个环节。 Pad一般元素都有输入输出接口，即pad。可将各个元素视作黑盒，则一般元素都有一个输入pad和输出pad，即过滤器元素。输入pad称为sink，输出pad称为src。管道命令模型基本如下: 1[src] ! [sink src] ! [sink src] ! [sink] 最左边的元素只有一个src pad用来提供信息（如filesrc）。接下来的几个元素接收信息并做一些处理，因此他们有sink和src pad（例如decodebin和audiocovert），最后一个元素只接收信息（例如alsasink）。使用gst-inspect-1.0命令查看一个元素的详细信息时，就可以看到该元素的pad信息。 注意可能与平时大家认为的概念有些不同的是，src pad是用来发送数据的端点，即数据的 输出端；而sink pad是用来接收数据的端点，即数据的输入端。 一般来说，src pad只能连接到sink pad。但ghost pad两端就要连接相同类型的pad。 Cap每个元素的cap表示该元素可以接收什么样的信息，类似于V4L2中的cap。 BinGStreamer中的bin类似于c中的结构体，是可以存放多个元素的容器。例如管道是a ! b ! c ! d，可以把他们放进mybin，这样当使用mybin时其实是引用了a ! b ! c ! d。 Ghost pad从名字上来看，ghost pad即特殊的pad。 当你创建了一个bin并在里面放置了很多元素时，该bin变成了你自定义的元素，该元素按顺序调用里面的元素。要做到这样，bin很自然地需要它自己的pad，它自己的pad会挂接到bin里面元素的pad上，这就是 ghost pad了。当你创建一个bin时，你创建了ghost pad并告诉他们要去挂接里面哪一个元素。 MessageMessage是Pipeline用向外来主动报告自己的运行状态。Message会被发送到一个消息队列，即Pipeline的Bus。应用程序则是从Bus中获取message，并进行处理。 EventEvent是Pipeline用来通信的机制，分为上行、下行和双向Event。在定义了某个事件的响应后，也可以由应用程序直接向该插件(bin)发送事件。通过Event可以控制整个Pipeline的运行状态。 上行事件: 由sink插件向source插件方向传输。包括: 12GST_EVENT_QOSGST_EVENT_SEEK 下行事件: 由source插件向sink插件方向传输。包括: 12GST_EVENT_EOSGST_EVENT_NEWSEGMENT 双行事件:包括: 12GST_EVENT_FLUSH_STARTGST_EVENT_FLUSH_STOP SignalSignal是应用控制某一插件的运行状态，可以看做Glib对象的一个属性，属于同步操作，和Linux中的系统信号有差别。通过Signal可以让某个插件做一些对插件本身变量的操作，比如增加或删除一些维护信息等。 GStreamer程序处理可以使用c或Python，Python中需要import gi，c中使用include &lt;gst/gst.h&gt;等头文件。TX1中的GStreamer头文件可以在/usr/include/GStreamer-1.0目录下找到。 元素处理Elements是具有一定功能的基本单元，主要组成如下: 1234udpsrc: 接受UDP数据(source产生数据)rtph264depay: H264的RTP拆包(filter)。(rtp+h264包)-&gt;(h264包)mpegtsmux: 打ts包(filter)。(h264包)-&gt;(ts包)filesink: 将数据存入文件(sink消耗数据) 在应用程序中创建GstElement对象的方法是借助于工厂对象GstElementFactory。由于GStreamer框架提供了多种类型的GstElement对象，因此对应地提供了多种类型的GstElementFactory对象，它们是通过特定的工厂名称来进行区分的。如: 12GstElementFactory *factory;factory = gst_element_factory_find (&quot;mad&quot;); 该代码通过gst_element_factory_find()函数创建了一个名为mad的工厂对象。之后就可以通过gst_element_factory_create()函数来创建特定的GstElement对象了。 12GstElement *element;element = gst_element_factory_create (factory, &quot;decoder&quot;); 函数gst_element_factory_create()在调用时有两个参数，分别是需要用到的工厂对象，以及即将创建的元素名。元素名可以用查询的办法获得，也可以通过传入空指针（NULL）来生成工厂对象的默认元素。 GStreamer使用了与GObject相同的机制来对属性（property）进行管理，包括查询（query）、设置（set）和读取（get）等。所有的GstElement对象都需要从其父对象GstObject那里继承名称（name）这一最基本的属性，这是因为像gst_element_factory_make()和gst_element_factory_create()这样的函数在创建工厂对象和元素对象时都会用到名称属性，通过调用gst_object_set_name()和gst_object_get_name()函数可以设置和读取GstElement对象的名称属性。 Pad处理成功创建GstElement对象之后，可以通过gst_element_get_pad()获得该元素的指定pad。例如，下面的代码将返回element元素中名为src的pad： 12GstPad *srcpad;srcpad = gst_element_get_pad (element, &quot;src&quot;); 需要的话也可以通过gst_element_get_pad_list()函数来查询指定元素中的所有pad。例如，下面的代码将输出elemen元素中所有pad的名称： 1234567GList *pads;pads = gst_element_get_pad_list (element);while (pads) &#123; GstPad *pad = GST_PAD (pads-&gt;data); g_print (&quot;pad name is: %s\n&quot;, gst_pad_get_name (pad)); pads = g_list_next (pads);&#125; 与元素一样，pad的名称也能够动态设置或者读取，这是通过调用gst_pad_get_name()和gst_pad_set_name()函数来完成的。所有元素的pad都可以细分成输入pad和输出pad两种，其中输入pad只能接收数据但不能产生数据，而输出pad则正好相反。函数gst_pad_get_direction()可以获得指定pad的类型。GStreamer框架中的所有pad都必然依附于某个元素之上，调用gst_pad_get_parent()可以获得指定pad所属的元素，该函数的返回值是一个指向GstElement的指针。 Pad从某种程度上可以看成是元素的代言人，因为它要负责向外界描述该元素所具有的能力。GStreamer框架提供了统一的机制来让pad描述元素所具有的能力（capability），这是借助结构体_GstCaps来实现的： 1234567struct _GstCaps &#123; gchar *name; /* the name of this caps */ guint16 id; /* type id (major type) */ guint refcount; /* caps are refcounted */ GstProps *properties; /* properties for this capability */ GstCaps *next; /* caps can be chained together */&#125;; GStreamer框架中的每个pad都可能对应于多个能力描述，它们能够通过函数gst_pad_get_caps()来获得。例如，下面的代码将输出pad中所有能力描述的名称及其MIME类型： 123456789GstCaps *caps;caps = gst_pad_get_caps (pad);g_print (&quot;pad name is: %s\n&quot;, gst_pad_get_name (pad));while (caps) &#123; g_print (&quot; Capability name is %s, MIME type is %s\n&quot;, gst_caps_get_name (cap), gst_caps_get_mime (cap)); caps = caps-&gt;next;&#125; Bin处理在GStreamer应用程序中使用的bin主要有两种类型： GstPipeline 管道是最常用到的容器，对于一个GStreamer应用程序来讲，其顶层bin必须是一条管道。 GstThread 线程的作用在于能够提供同步处理能力，如果GStreamer应用程序需要进行严格的音视频同步，一般都需要用到这种类型的bin。 GStreamer框架提供了两种方法来创建bin：一种是借助工厂方法，另一种则是使用特定的函数。下面的代码示范了如何使用工厂方法创建线程对象，以及如何使用特定函数来创建管道对象： 12345GstElement *thread, *pipeline;// 创建线程对象，同时为其指定唯一的名称。thread = gst_element_factory_make (&quot;thread&quot;, NULL);// 根据给出的名称，创建一个特定的管道对象。pipeline = gst_pipeline_new (&quot;pipeline_name&quot;); Bin成功创建之后，就可以调用gst_bin_add()函数将已经存在的元素添加到其中来了： 12345GstElement *element;GstElement *bin;bin = gst_bin_new (&quot;bin_name&quot;);element = gst_element_factory_make (&quot;mpg123&quot;, &quot;decoder&quot;);gst_bin_add (GST_BIN (bin), element); 从bin中找到特定的元素可以借助gst_bin_get_by_name()函数实现： 12GstElement *element;element = gst_bin_get_by_name (GST_BIN (bin), &quot;decoder&quot;); 由于GStreamer框架中的一个bin能够添加到另一个bin中，因此有可能会出现嵌套bin的情况，gst_bin_get_by_name()函数在查找元素时会对嵌套的bin作递归查找。元素有添加到bin中后，在需要的时候还可以从中移出，通过调用gst_bin_remove()函数来完成： 12GstElement *element;gst_bin_remove (GST_BIN (bin), element); Ghost pad具有ghost pad的bin在行为上与元素是完全相同的，所有元素具有的属性它都具有，所有针对元素能够进行的操作也同样能够针对bin进行，因此在GStreamer应用程序中能够像使用元素一样使用这类bin。通常通过以下方式为bin添加一个ghost pad: 123456GstElement *bin;GstElement *element;element = gst_element_factory_create (&quot;mad&quot;, &quot;decoder&quot;);bin = gst_bin_new (&quot;bin_name&quot;);gst_bin_add (GST_BIN (bin), element);gst_element_add_ghost_pad (bin, gst_element_get_pad (element, &quot;sink&quot;), &quot;sink&quot;); 元素连接GStreamer框架中的元素是通过各自的pad连接起来的，如下所示: 1234567GstPad *srcpad, *sinkpad;srcpad = gst_element_get_pad (element1, &quot;src&quot;);sinpad = gst_element_get_pad (element2, &quot;sink&quot;);// 连接gst_pad_link (srcpad, sinkpad);// 断开gst_pad_unlink (srcpad, sinkpad); 如果需要建立起连接的元素都只有一个输入pad和一个输出pad，那么更简单的做法是调用gst_element_link()函数直接在它们之间建立起连接，或者调用gst_element_unlink()函数断开它们之间的连接： 1234// 连接gst_element_link (element1, element2);// 断开gst_element_unlink (element1, element2); 元素状态每个元素一般会有四种状态: 标识 状态 NULL 这是所有元素的默认状态，表明它刚刚创建，还没有开始做任何事情。 READY 表明元素已经做好准备，随时可以开始处理流程。 PAUSED 表明元素因某种原因暂时停止处理数据。 PLAYING 表明元素正在进行数据处理。 所有的元素都从NULL状态开始，依次经历NULL、READY、PAUSED、PLAYING等状态间的转换。元素当前所处的状态可以通过调用gst_element_set_state()函数进行切换： 123GstElement *bin;/* 创建元素，并将其连接成bin */gst_element_set_state (bin, GST_STATE_PLAYING); 默认情况下，管道及其包含的所有元素在创建之后将处于NULL状态，此时它们不会进行任何操作。当管道使用完毕之后，不要忘记重新将管道的状态切换回NULL状态，让其中包含的所有元素能够有机会释放它们正在占用的资源。管道真正的处理流程是从第一次将其切换到READY状态时开始的，此时管道及其包含的所有元素将做好相应的初始化工作，来为即将执行的数据处理过程做好准备。对于一个典型的元素来讲，处于READY状态时需要执行的操作包括打开媒体文件和音频设备等，或者试图与位于远端的媒体服务器建立起连接。处于READY状态的管道一旦切换到PLAYING状态，需要处理的多媒体数据就开始在整个管道中流动，并依次被管道中包含的各个元素进行处理，从而最终实现管道预先定义好的某种多媒体功能。GStreamer框架也允许将管道直接从NULL状态切换到PLAYING状态，而不必经过中间的READY状态。正处于播放状态的管道能够随时切换到PAUSED状态，暂时停止管道中所有数据的流动，并能够在需要的时候再次切换回PLAYING状态。如果需要插入或者更改管道中的某个元素，必须先将其切换到PAUSED或者NULL状态，元素在处于PAUSED状态时并不会释放其占用的资源。 Probe应用程序可以通过探针(Probe)来探测某个插件的pad中流过的数据，如: 12345678910111213141516/*******Callback handler when probe date received***********/static gboolean callback_have_data(GstPad *padsrc, GstBuffer *buffer, gpointer data)&#123; gint iBufSize = 0; gchar* pBuffer = NULL; iBufSize = GST_BUFFER_SIZE(buffer); pBuffer = (gchar*)GST_BUFFER_DATA(buffer); static gint numBuf = 0; g_print(&quot;\rBUF %d Size=%d &quot;, numBuf++, iBufSize); return TRUE;&#125;GstPad *m_pad_concert_src = gst_element_get_static_pad(m_gst_convert, &quot;src&quot;); gst_pad_add_buffer_probe(m_pad_concert_src, G_CALLBACK(callback_have_data), NULL);gst_object_unref(m_pad_concert_src); 该代码在m_pad_concert插件的src pad加一个探针，每当有buf到达时，就调用callback_have_data(),这里这个函数只是打印一下buf的大小，统计一下buf流过的个数。 例子一个简单的程序: 12345678910111213141516171819202122#include &lt;gst/gst.h&gt;int main(int argc, char *argv[]) &#123; GstElement *pipeline; GstBus *bus; GstMessage *msg; /* Initialize GStreamer */ gst_init (&amp;argc, &amp;argv); /* Build the pipeline */ pipeline = gst_parse_launch (&quot;playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm&quot;, NULL); /* Start playing */ gst_element_set_state (pipeline, GST_STATE_PLAYING); /* Wait until error or EOS */ bus = gst_element_get_bus (pipeline); msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS); /* Free resources */ if (msg != NULL) gst_message_unref (msg); gst_object_unref (bus); gst_element_set_state (pipeline, GST_STATE_NULL); gst_object_unref (pipeline); return 0;&#125; 然后使用gcc进行编译，编译时需加上参数pkg-config –cflags –libs gstreamer-0.10。其中，gst_init (&amp;argc, &amp;argv)用于初始化所有内部结构，检查插件是否可用，以及执行用于GStreamer的命令参数。pipeline = gst_parse_launch (“playbin2 uri=http://docs.GStreamer.com/media/sintel_trailer-480p.webm&quot;, NULL)中，gst_parse_launch函数接受一个管道的文本表示并把它变成一个实际的管道。playbin2是充当source和sink一个特殊的元素（element），并且能够实现整个管道。gst_element_set_state (pipeline, GST_STATE_PLAYING)函数设置Pipeline状态为播放状态。gst_element_get_bus (pipeline); 函数获取管道的总线，gst_bus_timed_pop_filtered函数将阻塞，直到收到错误或EOS(End-Of-Stream)。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>av</tag>
        <tag>gstreamer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kurento Media Server源码编译]]></title>
    <url>%2F2018%2F05%2F27%2FKurento-Media-Server%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[Build dependencyModule dependency graphKurento模块的依赖关系如下图所示 Module dependency listKurento模块依赖关系并不是严格的线性关系，所以编译顺序可以有多种组合，以下是其中一种可能的编译顺序： Externals： gstreamer libsrtp openh264 usrsctp jsoncpp gst-plugins-base gst-plugins-good gst-plugins-ugly gst-plugins-bad gst-libav openwebrtc-gst-plugins libnice KMS Main + Extra: kurento-module-creator kms-cmake-utils kms-jsonrpc kms-core kms-elements kms-filters kurento-media-server kms-chroma kms-crowddetector kms-datachannelexample kms-platedetector kms-pointerdetector BuildNote: 适用于Ubuntu和Centos 如果在Centos下编译，还需要升级glib，autotools等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245# KMS源码目录KMS_HOME=$HOME/kms_source# KMS编译目录KMS_BUILD_HOME=$KMS_HOME/build/kmsCMAKE_MODULES_PATH=$&#123;KMS_BUILD_HOME&#125;/share/cmake-3.5/Modules# 导入编译所需的环境变量export CMAKE_OPTS=&quot;-DCMAKE_INSTALL_LIBDIR=lib -DCMAKE_MODULE_PATH:STRING=$&#123;CMAKE_MODULES_PATH&#125; -DKURENTO_MODULES_DIR:STRING=$&#123;KMS_BUILD_HOME&#125;/share/kurento/modules&quot;export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$KMS_BUILD_HOME/lib/pkgconfigexport LIBRARY_PATH=$LIBRARY_PATH:$KMS_BUILD_HOME/libexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$KMS_BUILD_HOME/libexport CPATH=$CPATH:$KMS_BUILD_HOME/include:$KMS_BUILD_HOME/include/gstreamer-1.5export PATH=$PATH:$KMS_BUILD_HOME/binJAVA_CMD=$(which java)# 创建所需目录mkdir -p $&#123;KMS_HOME&#125;mkdir -p $&#123;KMS_BUILD_HOME&#125;mkdir -p $&#123;KMS_BUILD_HOME&#125;/bin# ---- build externals ----# gstreamercd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/gstreamer.gitcd gstreamergit checkout kms6.6.0./autogen.sh# introspection requires python &gt;= 2.7./configure --enable-introspection=no --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build opensslcd $&#123;KMS_HOME&#125;wget https://www.openssl.org/source/old/1.0.2/openssl-1.0.2g.tar.gztar -zxvf openssl-1.0.2g.tar.gzcd openssl-1.0.2g./config shared --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build libsrtpcd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/libsrtp.gitcd libsrtpgit checkout kms6.6.0./configure --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build nasm# required by openh264cd $&#123;KMS_HOME&#125;wget https://www.nasm.us/pub/nasm/releasebuilds/2.13.02/nasm-2.13.02.tar.gztar -xzvf nasm-2.13.02.tar.gzcd nasm-2.13.02./configure --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build openh264cd $&#123;KMS_HOME&#125;git clone https://github.com/cisco/openh264.gitcd openh264git checkout v1.4.0make &amp;&amp; make install PREFIX=$KMS_BUILD_HOMEif [ $? -ne 0 ]; then exit -1; fi# build usrsctpcd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/usrsctp.gitcd usrsctpgit checkout kms6.6.0./bootstrap./configure --prefix=$KMS_BUILD_HOMEmake &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build opuscd $&#123;KMS_HOME&#125;wget https://archive.mozilla.org/pub/opus/opus-1.2.1.tar.gztar -zxvf opus-1.2.1.tar.gzcd opus-1.2.1./configure --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build orccd $&#123;KMS_HOME&#125;wget https://gstreamer.freedesktop.org/src/orc/orc-0.4.28.tar.xztar -Jxvf orc-0.4.28.tar.xzcd orc-0.4.28./configure --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build jsoncppcd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/jsoncpp.gitcd jsoncppgit checkout kms6.6.0mkdir -p build &amp;&amp; cd buildcmake -DCMAKE_INSTALL_PREFIX=$KMS_BUILD_HOME $CMAKE_OPTS ..make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# 否则编译kms-jsonrpc会报错 fatal error: json/json.h: No such file or directorysed -i &apos;s/\/kmsjsoncpp//g&apos; $KMS_BUILD_HOME/lib/pkgconfig/kmsjsoncpp.pc# gst-plugins-basecd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/gst-plugins-base.gitcd gst-plugins-basegit checkout kms6.6.0./autogen.sh./configure --enable-introspection=no --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# gst-plugins-good# for rtp cd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/gst-plugins-good.gitcd gst-plugins-goodgit checkout kms6.6.0./autogen.sh./configure --enable-introspection=no --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# gst-plugins-uglycd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/gst-plugins-ugly.gitcd gst-plugins-uglygit checkout kms6.6.0./autogen.sh./configure --enable-introspection=no --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# gst-plugins-bad# for openh264+libsrtpcd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/gst-plugins-bad.gitcd gst-plugins-badgit checkout kms6.6.0./autogen.sh./configure --enable-introspection=no --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# gst-libavcd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/gst-libav.gitcd gst-libavgit checkout kms6.6.0./autogen.sh./configure --enable-introspection=no --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build openwebrtc-gst-pluginscd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/openwebrtc-gst-plugins.gitcd openwebrtc-gst-pluginsgit checkout kms6.6.0./autogen.sh./configure --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build libnicecd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/libnice.gitcd libnicegit checkout kms6.6.1./autogen.sh./configure --enable-introspection=no --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build libevent# required by kurento-media-servercd $&#123;KMS_HOME&#125;wget https://github.com/libevent/libevent/releases/download/release-2.0.22-stable/libevent-2.0.22-stable.tar.gztar -xzvf libevent-2.0.22-stable.tar.gzcd libevent-2.0.22-stable./configure --prefix=$KMS_BUILD_HOME &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build boostcd $&#123;KMS_HOME&#125;# boost&gt;1.58.0不支持json配置注释wget &quot;https://sourceforge.net/projects/boost/files/boost/1.58.0/boost_1_58_0.tar.gz/download&quot; -O boost_1_58_0.tar.gztar -zxvf boost_1_58_0.tar.gzcd boost_1_58_0./bootstrap.sh./b2 install --prefix=$KMS_BUILD_HOME#if [ $? -ne 0 ]; then exit -1; fi# ---- build kms main ----# build kms-cmake-utilscd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/kms-cmake-utils.gitcd kms-cmake-utilsgit checkout 6.7.0mkdir -p build &amp;&amp; cd build &amp;&amp; cmake -DCMAKE_INSTALL_PREFIX=$KMS_BUILD_HOME $CMAKE_OPTS .. &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build kurento-module-creatorcd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/kurento-module-creator.gitcd kurento-module-creatorgit checkout 6.7.0mvn packagecp target/classes/FindKurentoModuleCreator.cmake $&#123;CMAKE_MODULES_PATH&#125;cp target/kurento-module-creator-jar-with-dependencies.jar $&#123;KMS_BUILD_HOME&#125;/bincp scripts/kurento-module-creator $&#123;KMS_BUILD_HOME&#125;/binsed -i &quot;s|JAVA_CMD=.*|JAVA_CMD=$&#123;JAVA_CMD&#125;|g&quot; $KMS_BUILD_HOME/bin/kurento-module-creatorif [ $? -ne 0 ]; then exit -1; fi# build kms-jsonrpccd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/kms-jsonrpc.gitcd kms-jsonrpc git checkout 6.7.0rm -rf build &amp;&amp; mkdir -p build &amp;&amp; cd buildcmake -DCMAKE_INSTALL_PREFIX=$KMS_BUILD_HOME $CMAKE_OPTS ..make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build kms-corecd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/kms-core.gitcd kms-coregit checkout 6.7.1rm -rf build &amp;&amp; mkdir -p build &amp;&amp; cd buildcmake -DCMAKE_INSTALL_PREFIX=$KMS_BUILD_HOME $CMAKE_OPTS .. &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build kms-elementscd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/kms-elements.gitcd kms-elementsgit checkout 6.7.1rm -rf build &amp;&amp; mkdir -p build &amp;&amp; cd buildcmake -DCMAKE_INSTALL_PREFIX=$KMS_BUILD_HOME $CMAKE_OPTS .. &amp;&amp; make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi# build kurento-media-servercd $&#123;KMS_HOME&#125;git clone https://github.com/Kurento/kurento-media-server.gitcd kurento-media-server git checkout 6.7.1rm -rf build &amp;&amp; mkdir -p build &amp;&amp; cd buildcmake -DCMAKE_INSTALL_PREFIX=$KMS_BUILD_HOME $CMAKE_OPTS .. make &amp;&amp; make installif [ $? -ne 0 ]; then exit -1; fi Run12345KMS_HOME=$HOME/kms_sourceKMS_BUILD_HOME=$KMS_HOME/build/kmsexport LD_LIBRARY_PATH=$KMS_BUILD_HOME/lib:$LD_LIBRARY_PATH$KMS_BUILD_HOME/bin/kurento-media-server -f $KMS_BUILD_HOME/etc/kurento/kurento.conf.json -c $KMS_BUILD_HOME/etc/kurento/modules/kurento Reference Kurento Developer Guide]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>KMS</tag>
        <tag>Kurento</tag>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建自己专属的vpn——Centos搭建vpn的几种办法]]></title>
    <url>%2F2018%2F04%2F07%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E4%B8%93%E5%B1%9E%E7%9A%84vpn%E2%80%94%E2%80%94Centos%E6%90%AD%E5%BB%BAvpn%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言上一篇《搭建自己专属的vpn——选择一个vps》提到如何选择一个vps，这一篇就淡淡如何利用vultr的vps搭建一个vpn。 方法一：搭建shadowsocks+serverspeeder（特别推荐）shadowsocks服务端安装参考官方Shadowsocks使用说明： CentOS: 12yum install python-setuptools &amp;&amp; easy_install pip pip install shadowsocks Debian / Ubuntu: 12apt-get install python-pip pip install shadowsocks 配置参考Configuration via Config File 修改配置文件/etc/shadowsocks.json，如果没有则新建。内容如下： 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false &#125; 或（多个SS账号） 123456789101112&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;port_password&quot;:&#123; &quot;8381&quot;:&quot;xxxxxxx&quot;, &quot;8382&quot;:&quot;xxxxxxx&quot;, &quot;8383&quot;:&quot;xxxxxxx&quot;, &quot;8384&quot;:&quot;xxxxxxx&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false &#125; 配置说明： 字段 说明 server ss服务监听地址 server_port ss服务监听端口 local_address 本地的监听地址 local_port 本地的监听端口 password 密码 timeout 超时时间，单位秒 method 加密方法，默认是aes-256-cfb fast_open 使用TCP_FASTOPEN, true / false workers workers数，只支持Unix/Linux系统 启动：前台启动 1ssserver -c /etc/shadowsocks.json 后台启动与停止 12ssserver -c /etc/shadowsocks.json -d start ssserver -c /etc/shadowsocks.json -d stop 如需开机启动修改/etc/rc.local，加入以下内容 1ssserver -c /etc/shadowsocks.json -d start 日志shadowsocks的日志保存在 /var/log/shadowsocks.log shadowsocks客户端安装下载地址： 1234567891011121314151617Windows https://github.com/shadowsocks/shadowsocks-windows/releases Mac OS X https://github.com/shadowsocks/ShadowsocksX-NG/releases Linux https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation https://github.com/shadowsocks/shadowsocks-qt5/releases IOS https://itunes.apple.com/app/apple-store/id1070901416?pt=2305194&amp;ct=shadowsocks.org&amp;mt=8 https://github.com/shadowsocks/shadowsocks-iOS/releasesAndroid https://play.google.com/store/apps/details?id=com.github.shadowsocks https://github.com/shadowsocks/shadowsocks-android/releases serverspeeder加速安装注意：serverspeeder加速是可选的，如果你使用vpn测速发现很慢，可以安装试试。 加速前 加速后 下行速度瞬间提升，是不是觉得有点小激动？一键安装serverspeeder注：参考serverspeeder锐速一键破解安装版 1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 如果报内核不支持，可以更换系统内核 1234567891011下载内核安装包 wget http://ftp.scientificlinux.org/linux/scientific/6.6/x86_64/updates/security/kernel-2.6.32-504.3.3.el6.x86_64.rpm 更换内核 rpm -ivh kernel-2.6.32-504.3.3.el6.x86_64.rpm --force 重启 reboot 查看内核版本是否替换成功 cat /proc/version 如果系统内核已更新，再次执行一键安装serverspeeder方法即可。至此serverspeeder安装完毕，快去试试速度是不提升了。 卸载serverspeeder的方法 1chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f 方法二：搭建l2tp vpn（推荐）参考DearTanker’s Blog的一键安装方法： 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/across/master/l2tp.sh chmod +x l2tp.sh ./l2tp.sh 基本上，按交互式命令的提示按回车或者自定义自己的选择即可，然后再次验证ipsec（L2TP）并重启相关服务，否则提示服务器无响应 123service ipsec restart service xl2tpd restart ipsec verify 如果需要修改或者增加账号密码，可以修改/etc/ppp/chap-secrets 1账户 l2tpd 密码 * 测试成功使用的客户端有，win7+win10自带vpn客户端，andriod自带vpn客户端。 测试成功使用的网络环境有，电信+联通宽带，移动4g无法连接成功，如果哪位朋友在移动网络下有成功的经验，麻烦分享一下。 不使用vpn时，使用speedtest的测速结果： 下面是成功连接vpn后，使用speedtest的测速结果，虽然不是非常快，但基本够用。 方法三：搭建openvpn（不建议）vultr面板提供一键安装openvpn的办法，方法是在新建一个vps实例时选择默认安装一个应用程序： 具体安装办法参考官方的一键安装openvpn说明。openvpn是使用操作系统的登录账号登录的，所以搭建完openvpn后，你可以参考linux新建用户的办法新建一个用户及修改用户密码，然后使用opevpn提供的客户端或者网页（一般情况下是 https://your_vps_ip:943/ ）登录即可。 之所以不建议使用openvpn，原因是测速发现比较慢，下载带宽不到1M，而且openvpn貌似不支持移动端登录。 方法四：搭建pptpd vpn（不建议）注：之所以不建议使用pptpd，一方面是pptpd经常被墙，二是容易出问题。 安装1yum install ppp iptables pptpd 配置编辑/etc/pptpd.conf，搜索localip，去掉下面字段前面的#，然后保存退出 12localip 192.168.0.1 remoteip 192.168.0.234-238,192.168.0.245 注意，pptpd默认支持最大100个连接，每个remoteip分配一个连接，如果remoteip数不够100个，那么默认连接数就会变成remoteip数。如果默认连接数不够的话，就会出现自动断开的情况，比如手机上的vpn连上了，PC端的vpn就会断开。 编辑options.pptpd，搜索ms-dns，去掉搜索到的两行ms-dns前面的#，并修改为下面的字段 12ms-dns 8.8.8.8 ms-dns 8.8.4.4 编辑/etc/ppp/chap-secrets设置VPN的帐号密码，注意，用户名与密码是区分大小写的 1用户名 pptpd 密码 * 编辑/etc/sysctl.conf，修改内核参数，在末尾添加下面的代码，使内核支持转发 1net.ipv4.ip_forward=1 运行下面的命令使内核修改生效 1sysctl -p 添加下面的iptables转发规则（直接在SSH运行下面命令即可） 1iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE 添加转发规则后重启就会失效，Centos 6系统可以使用service iptables save保存配置，而Centos7则可以修改/etc/rc.d/rc.local保存上面的命令，这样开机会自动执行上面的命令。 启动用下面的命令使pptpd开机自动启动 1chkconfig pptpd on 启动pptpd 1service pptpd start 使用使用你的vpn客户端连接即可，如果配置没问题的话，就可以连接成功。测试成功连接的vpn客户端有，win7+win10自带vpn客户端，andriod自带vpn客户端。但只在宽带网络上连接成功，4g网络连接不成功。 排错如果你的vpn连接不成功，有可能是iptable防火墙的问题，你可以使用下面命令 123iptables -A INPUT -p tcp --dport 1723 -j ACCEPT 或者 iptables -F 然后在你的其他电脑使用telnet your_ip 1723测试是否连通。 如果你遇到访问网站偶尔连接上又断的问题，可能是MTU太大导致，可以 1234执行 iptables -I FORWARD -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1356 或者修改/etc/ppp/options.pptpd，在文件最后添加 mtu 1356 更多问题，可以打开pptpd的debug日志，根据debug日志的输出上网搜索一步步解决修改/etc/ppp/options.pptpd取消下面的注释123debug dump logfile /var/log/pptpd.log（没有则手工修改）]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>vps</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建自己专属的vpn——选择一个vps]]></title>
    <url>%2F2018%2F04%2F07%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E4%B8%93%E5%B1%9E%E7%9A%84vpn%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AAvps%2F</url>
    <content type="text"><![CDATA[前言作为一名技术人员，经常需要访问一些墙外的网站，你懂的。本来想直接购买个vpn，但又怕不太安全。看到网上有很多自己搭建vpn的教程，于是自己折腾了一下，终于成功搭建，随便与大家分享一些经验。 选择一个vps搭建vpn的第一步是，你必须有一台公网能访问的vps，而且该vps要在墙外，简单来说就是你必须要有一台能访问墙外的电脑。如何选择一个适合自己的vps呢？我自己认为主要有价格、稳定性和带宽等方面的因素，当然易操作性、良好的售后服务等也比较重要。 国外常见的vps有Linode、Vultr、SugarHosts、bandwagonhost等。 看了网上的一些评测，如《Vultr超高性价比VPS评测使用教程》，以及Vultr每月$2.5的费用，觉得可以入手，因为网上购买一个vpn也差不多这个费用。 注册账号首先，登陆Vultr官网，点击Create Account注册即可，之前官方搞活动，暑假注册使用免费送$20，现在好像没有什么优惠了，期待下次还有活动。现在最新优惠是每月$2.5的实例，不过经常没货。 注册并不会收费，只有创建了实例才会收费，如果觉得不好用可以直接删除自己创建的实例，这样就不会收费了。注意，如果实例关机但没有把实例删除，还是会收费的，毕竟该实例占用了公网IP和硬盘空间。 可喜的是，现在vultr已经支持支付宝付款了。 选择机房如何选择一个好的机房，当然是自己测过才放心。这里推荐使用PingInfoView来测试。以下是vultr的机房： 列表如下，贴到PingInfoView上即可。 123456789101112131415sgp-ping.vultr.comhnd-jp-ping.vultr.comsyd-au-ping.vultr.comfra-de-ping.vultr.comams-nl-ping.vultr.comlon-gb-ping.vultr.compar-fr-ping.vultr.comwa-us-ping.vultr.comsjo-ca-us-ping.vultr.comlax-ca-us-ping.vultr.comil-us-ping.vultr.comnj-us-ping.vultr.comtx-us-ping.vultr.comga-us-ping.vultr.comfl-us-ping.vultr.com linux/mac用户可以使用我写的脚本vultr_test来测试。 以下是我的测试结果：选择的原则是，ping值最小，丢包率最小。比如我的测试结果中，较不错的是sjo、wa和lax，都是美国机房。 部署实例点击Servers，然后点右边的+号依次选择自己测试比较好的机房，选择操作系统版本，选择方案（$2.5的低配方案搭vpn已经够用，另外还可以自己搭个博客什么的），然后部署就搞定了。 如果vps使用linux操作系统，可以使用ssh的客户端登录，比如SecureCRT，这里就不再详细说明。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>vps</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RTMP协议规范_1.0]]></title>
    <url>%2F2017%2F11%2F19%2FRTMP%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83-1-0%2F</url>
    <content type="text"><![CDATA[译注 本文档主要翻译于rtmp specification 1.0。 绝大部分使用直译，小部分使用意译。专有名词基本不翻译，既保留规范的原意，又不会感觉翻译起来怪怪的。 IntroductionAdobe’s Real Time Messaging Protocol (RTMP)通过一个可靠的流传输通道提供双向的消息复用服务，流传输通道类似于 TCP [RFC0793]，目的是在通信双方之间并行传输带有关联时间信息的音视频流和数据消息。实现通常按不同类型的消息分配不同的优先级，从而在传输带宽受限时可以影响消息在底层流传输通道的入队顺序。本文档描述了实时消息传递协议的语法和操作。 Terminology本文档中的关键词，”MUST”、”MUST NOT”、”REQUIRED”、”SHALL”、”SHALL NOT”、“SHOULD”、”SHOULD NOT”、”RECOMMENDED”、”NOTRECOMMENDED”、”MAY”和”OPTIONAL”，都在[RFC2119]中解释描述。 ContributorsRajesh Mallipeddi，Adobe System 原成员，起草了本文档原始规范，并提供大部分的原始内容。Mohit Srivastava，Adobe System 成员，推动了本规范的发展。 DefinitionsPayload：包含在一个包中的数据，比如音频采样数据或者视频压缩数据。有效载荷的格式和解释超出了本文档的范围。Packet：一个数据包由固定头 header 和 payload 数据组成。一些底层的协议可能需要定义该数据包的封装。Port：传输协议用来区分在一个给定的主机内的多个目的地的抽象。TCP/IP协议使用小正整数来识别端口。OSI 传输层使用的传输选择器（TSEL）相当于端口。Transport address：网络地址和端口的组合用来识别一个传输层级别的端点，比如一个IP 地址和TCP 端口。包从源Transport address 传输到目标的Transportaddress。Message stream：消息流的逻辑传输通道。Message stream ID：每个消息都有一个与它相关联的 ID，以确定它的流在哪个消息流中。Chunk：一段消息。消息被拆分成小的部分并且它们在网络发出去之前被转换。Chunk stream：允许在一个特定方向上 chunk 流动的通信的逻辑通道。chunkstream 可以从客户端传输到服务器或者反过来传输。Chunk stream ID：每一块 chunk 都有一个与它关联的 ID，以标识它所在的chunk stream。Multiplexing：使单独的音频/视频数据转换成一个连贯的音频/视频流的过程，使得有可能同时传输多个视频和音频。DeMultiplexing：多路传输的反向过程，其中交错的音频和视频数据被组装成原始的音频和视频数据。Remote Procedure Call (RPC)：允许客户端或服务器在对等端调用子程序或过程的请求。Metadata：关于数据的描述。视频的元数据包括视频名称、持续时间、创作日期等。Application Instance：服务器上的应用程序实例，客户端连接通过它来发送连接请求。Action Message Format (AMF)：一个紧凑的二进制格式，用于序列化的ActionScript 对象图。AMF 有两种版本：AMF 0 [AMF0]和 AMF 3 [AMF3]。 Byte Order, Alignment, and Time Format所有的整型字段都使用网络字节序传输，字节 0 为第一个字节，第 0 位在一个字或字段中是最重要的位。这种字节顺序俗称为大端模式。这种传输顺序在 IP 协议[RFC0791]中详细描述。如果没有另外说明，本文档中的数字常量都是十进制。除非另有规定，RTMP 的所有数据都是字节对齐的；例如，一个 16 位的字段可能在一个奇数的字节偏移上。该位置如果指定填充，则填充字节值应该为零。时间戳在 RTMP 是作为一个相对于未知时期的毫秒整数。通常，每个流将以时间戳 0 作为开始，但这不是必需的，只要两端在时间基准能达成一致即可。注意，这意味着任何在多个流的同步（尤其是独立的主机）需要一些 RTMP 之外的机制协助。因为时间戳是 32 位长，他们每过 49 天，17 小时，2 分钟，47.296 秒就会轮转。因为数据流允许连续地，甚至可能多年不断地运行，一个 RTMP 应用在处理时间戳时应该使用序列号算法[RFC1982]，并且应该能够环绕式处理。 例如， 一个应用程序假定所有相邻的时间戳在 2 ^ 31 - 1 毫秒内都是彼此相邻的，所以10000 在 4000000000 后面，3000000000 在 4000000000 的前面。相对之前提到的时间戳，时间戳增量也可以表示为无符号整数的毫秒。时间戳增量可能是 24 或 32 位长。 RTMP Chunk Stream本节详述实时消息协议块流（RTMP 流块）。它为更高层次的多媒体流协议提供了复用和打包服务。虽然 RTMP 块流设计工作于实时消息协议（第 6 节），但它可以处理任何发送一个消息流的协议。每个消息包含时间戳和 payload 类型识别。RTMP ChunkStream 和 RTMP 是适合多种音视频应用，包括一对一和一对多的直播点播服务， 交互式视频会议应用。当使用一个可靠的传输协议如 TCP [RFC0793]，RTMP Chunk Stream 提供有保障的，按时间戳顺序的，端到端的，跨多个流的所有消息传输。RTMP Chunk Stream 不提供任何优先级控制或类似的形式，但可以通过更高级别的协议提供这样的优先级顺序。例如，基于每一个消息的发送或确认时间，一个实时视频服务器可能会选择放弃一个缓慢的客户端视频消息，以确保音频消息是及时收到的。RTMP Chunk Stream 包括自带的协议控制信息，并且还为更高级别的协议嵌入用户控制消息提供了一种机制。 Message Format消息可以分割成多个 chunk 的格式，以支持取决于一个更高级别协议的复用。然而，消息格式应该包含用于创建 chunk 的以下字段。Timestamp：消息的时间戳。这个字段可以传输 4 个字节。Length：消息 payload 的长度。如果消息头不能省略，它应该包括在该长度中。此字段在 chunk header 中占用 3 个字节。Type Id：一系列的类型 ID 被保留用于协议控制消息。这些传播信息的消息通过 RTMP Chunk Stream 协议和高层协议处理。所有其他类型的 ID 对高级别的协议是可用的，并被 RTMP Chunk Stream 视为不透明数值。事实上，在 RTMP Chunk Stream 中没有要求这些值被用来作为一个类型；所有（非协议）消息可能是同一类型，或应用程序可以使用此字段来区分同步轨道而不是类型。此字段占用 chunk header 中的 1 个字节。Message Stream ID：消息流 ID 可以是任意的值。同一 Chunk Stream 上的不同的多路复用消息流是基于它们的消息流 ID 进行多路解码的。除此之外，据RTMP Chunk Stream 而言，这是一个不透明的值。这个字段以小端格式在 chunk header 中占用 4 个字节。 HandshakeRTMP 连接以握手为开始。握手不同于协议的其余部分，它由三个静态大小的 chunk，而不是由可变大小的带有头的 chunk 组成。客户端（已启动连接的端点）和服务器每方都分别发送相同的三个 chunk。为了方便表达，当由客户端发送时，这些 chunk 将被命名为 C0，C1 和 C2；当由服务器发送时，它们被命名为 S0，S1，S2。 Handshake Sequence握手开始，客户端发送 C0，C1 chunk。客户端必须等到 S1 收到之后才能发送 C2。客户端必须等到 S2 收到之后才能发送其他数据。 服务器必须等到 C0 或可能 C1 收到之后才能发送 S0 和 S1。服务器必须等到 C1 收到之后才能发送 S2。服务器必须等到 C2 收到之后才能发送其他数据。 C0 and S0 FormatC0 和 S0 包是一个单字节，视为一个单一的 8 位整数字段：以下是 C0/S0 包的字段：Version（8 位）：在 C0，此字段标识客户端所请求的 RTMP 协议版本。在S0，此字段标识服务器选择的 RTMP 协议版本。本规范定义的版本号为 3。值0-2 由先前专有产品使用，现已弃用；4-31 留待将来实现；32-255 不允许使用（以区分 RTMP 和文本协议，因为它总是以一个可打印字符为开始）。当识别不出客户端请求的版本时，服务器应该响应版本号 3。客户端可能会选择降级到版本3，或放弃握手。 C1 and S1 FormatC1 和 S1 包都是 1536 个字节长，包括以下字段：Time （4 字节）：本字段包含一个时间戳，这应该作为未来从这个端点发出的所有块的时间基准。这可能是 0 ， 或一些任意的值。为了同步多个chunkstream，此端点可能要发送其他 chunkstream 的时间戳的当前值。Zero（4 个字节）：这个字段必须都是 0。Random data （1528 个字节）：此字段可以包含任何任意值。由于每个端点必须区分它发起的握手的应答和对端发起的握手，这个数据应该发送足够随机的东西。但不需要加密的安全性，甚至不需要动态值。 C2 and S2 FormatC2 和 S2 包都是 1536 个字节长，几乎是 S1 和 C1 的复制（分别地），它们包括以下字段： Time（4 个字节）：该字段必须包含对方包内的发送时间戳，它分别在 S1（ 对 于 C2） 或 C1（ 对 于 S2） 。Time2（4 个字节）：该字段必须包含对方前面的包（S1 或 C1）被读取的时间戳。Random echo（1528 个字节）：该字段必须包含对方发送的包（S1 或 C1） 的随机数字段，分别在 S1（对于 C2）和 C1（对于 S2）。每个端都可以使用 time 和 time2 字段与当前时间戳作为连接的带宽和/或延迟的快速评估，但这不太可能有用。 Handshake Diagram 下面介绍握手图中所提到的状态：Uninitialized：协议版本号在这个阶段中发送。客户端和服务器都是未初始化。该客户端在 C0 包发送协议版本号。如果服务器支持该版本，它将应答 S0 和 S1。如果没有，服务器响采取适当的行为应答。在 RTMP，这个动作是终止连接。Version Sent：在未初始化状态之后，客户端和服务器都处在发送版本号的状态。客户端正在等待包 S1，而服务器等待包 C1。在收到期待的包之后，客户端发送数据包 C2 而服务器发送数据包 S2。然后状态就变成 Ack Sent。Ack Sent：客户端和服务端分别等待 S2 和 C2。Handshake Done：客户端和服务器可以交换消息的状态。 Chunking在握手之后，连接多路复用一个或多个 chunk stream。每个 chunk stream 都从一个消息流中传送一个类型的消息。创建的每个 chunk 都有一个与它关联的唯一标识，称为块流标识（chunk stream ID）。chunk 在网络上传输。在传输的过程中，每一个 chunk 必须在下一个 chunk 之前全部发送。在接收端，chunk 被组装成基于 chunk stream ID 的消息。chunk 允许更高层协议上的大消息分解成较小的信息，例如防止大的优先级低的消息（如视频）阻塞小的高优先级的消息（如音频或控制）。chunk 也让小消息以较小的开销被发送，因为 chunk header 包含压缩指示的信息，否则将被包含在消息本身。chunk 大小是可配置的。它可以使用 chunk 大小控制消息来设置（第 5.4.1 节）。较大的 chunk 大小降低了处理器的使用率，但也导致更大的写入，在连接带宽较低时，可以延迟其他内容。较小的 chunk 不适合高比特率的流。chunk 大小在每个方向上都是独立维护的。 Chunk Format每一个 chunk 都包含头部和数据。头本身有三个部分： Basic Header（1 到 3 个字节）：此字段对 chunk stream ID 和 chunk type 进行编码。chunk type 决定 message header 的编码格式。它的长度完全取决于 chunk stream ID，这是一个可变长度的字段。Message Header（0，3，7 或者 1 个字节）：该字段对发送的消息进行编码（无论是在整体还是部分）。长度可以用 chunk header 中指定的 chunk type 来确定。Extended Timestamp（0 或者 4 个字节）：这个字段在一定情况下出现，取决于 Chunk Message header 中编码的时间戳或时间戳差量。更多信息见 5.3.1.3 节。Chunk Data（变长大小）：此 chunk 的有效负载，大小不超过配置的最大块大小。 Chunk Basic HeaderChunk Basic Header 编码 chunk stream ID 和 chunk 类型（按下图 FMT 字段表示）。chunk 类型决定已编码的消息头的格式。Chunk Basic Header 字段可能是 1，2，或 3 个字节，这取决于 chunk stream ID。一个实现应该使用可以保存 ID 的最小表示（按需编码）。该协议使用 3-65599 的 ID 支持多达 65597 个流。0，1，和 2 的 ID 是保留值。值 0 表示 2 字节的形式，并且 ID 在 64-319 的范围（第二字节+64）。值 1 表示 3 字节的形式，并且 ID 在 64-65599 的范围（第三字节×256+第二个字节+64）。值范围为 3-63 代表完整的 chunk stream ID。值为 2 的 chunk stream ID 是为低层协议控制信息和指令保留。位 0-5（最重要的）在 Chunk Basic Header 中代表 chunk stream ID。chunk stream ID 2-63 可在这个字段用 1 字节的版本编码。 chunk stream ID 64-319 可以在此头部用 2 字节的形式编码。ID 的计算方法为（第二个字节+64）。 chunk stream ID 64-65599 可以在此字段用 3 字节版本编码。ID 的计算方法为（第三字节*256+第二字节+64）。 cs id（6 个字节）：本字段包含 chunk stream ID，值从 2-36。值 0 和 1 表示此字段的 2 或 3 字节版本。fmt（2 个字节）：该字段标识“chunk message header”所使用的四种格式之一。每个 chunk 类型的“chunk message header”在下一节中解释。cs id - 64（8 或者 16 个字节）：此字段包含 chunk stream ID 减去 64 的值。例如，ID 365 将由 cs id 为 1，和这里（cs id - 64）的一个 16 位的 301 表示。chunk stream ID 值 64-319 可以由 2 或 3 字节形式的头表示。 Chunk Message Header有四种不同格式的 chunk message header，由在 chunk basic header 的“fmt” 字段决定。一个实现应该使用可能为每个 chunk message header 的最紧凑的表示。 Type 0类型0 的chunk header 是11 个字节长。这种类型必须使用在一个chunk stream的开始，必要时，流时间戳可以后退（例如，由于回退定位）。 timestamp（3 个字节）：对于一个类型 0 的 chunk，消息的绝对时间戳就在这里发送。如果时间戳大于或等于 16777215（十六进制 0xFFFFFF），该字段必须为 16777215，表明扩展时间戳（Extended Timestamp）字段编码的出现，以能够编码完整的 32 位时间戳。否则，这个字段应该是整个时间戳。 Type 1类型 1 的 chunk header 是 7 个字节长。不包含 message stream ID；此 chunk 采用与前面的 chunk 相同的流 ID。具有可变大小的消息的流（例如，许多视频格式）应该使用这个格式作为第一个之后的每一个新消息的第一个 chunk。 Type 2类型 2 的 chunk header 是 3 个字节长。既不包含流 ID，也不包含消息长度， 该 chunk 与前面的 chunk 具有相同的流 ID 和消息长度。具有常量大小的消息流 （例如，一些音频和数据格式）应该使用这个格式作为第一个之后的每一个消息的第一个 chunk。 Type 3类型 3 的 chunk 没有消息头。流 ID、消息长度和时间戳增量字段都不存在； 这种类型的 chunk 采用与前面 chunk 相同的 Chunk Stream ID。当一个独立的消息被分成 chunk，除了第一个 chunk 之外，所有的消息 chunk 应该使用这种类型。参考实例 2（5.3.2.2 节）。一个由完全相同大小，流 ID 和时空消息组成的流在类型 2 的 chunk 之后应该都使用该类型的 chunk。参考实例 1（5.3.2.1 节）。如果第一消息和第二消息的差量与第一个消息的时间戳是相同的，然后类型 3 的chunk 可以立即跟随类型 0 的 chunk，因为无需一个类型 2 的 chunk 表示该差量。如果一个类型 3 的 chunk 跟随着类型 0 的 chunk，然后类型 3 的 chunk 的时间戳差量与类型 0 的 chunk 的时间戳相同。 Common Header Fieldschunk message header 中每个字段的描述：timestamp delta（3 个字节）：对于类型 1 或类型 2 的 chunk，前面 chunk 的时间戳和当前 chunk 之间的区别就在此发送。如果差量大于或等于 16777215（十六进制 0xFFFFFF），该字段必须为 16777215，表明 Extended Timestamp 字段的出现，以编码整个 32 位的时间戳。否则，这个字段应该是整个时间戳。message length（3 个字节）：对于一个类型 0 或类型 1 的 chunk，消息的长度在此发送。请注意，这通常与 chunk payload 的大小是不一样的。chunk payload 的长度是除了最后一个 chunk 的所有 chunk 的最大大小，剩余部分（对于小消息来说，可能是整个长度）就是最后 chunk 的大小。message type id（1 个字节）：对于类型 0 或类型 1 的 chunk，消息的类型在此发送。message stream id（4 个字节）：对于一个类型 0 的 chunk，它存储的是 message stream ID。Message stream ID 以小端格式存储。通常情况下，相同 chunk stream 中的所有消息都来自于同一个 message stream。虽然将 message stream 多路分离成相同的 chunk stream 是可能的，但它的效果比头部压缩的要差。然而，如果一个 message stream 关闭而另一个随后打开，但决没有理由说一个现有的 chunk stream 不能通过发送一个新的类型 0 的 chunk 以被重用。 Extended TimestampExtended Timestamp 字段是用来编码大于 16777215（0xFFFFFF）的时间戳或时间戳增量；也就是说，它是对于类型 0，1 或者 2 的 chunk 中 24 位的时间或时间戳增量满足不了的情况而设计的。这个字段编码完整的 32 位时间或时间戳增量。这个字段的出现表示对于 16777215（0xFFFFFF）的情况，设置类型 0 的chunk 的时间戳或者类型 1、类型 2 的 chunk 的时间戳增量。当最近相同 chunk stream ID 的类型 0，1，或 2 的 chunk 指示存在 extended timestamp 字段时，这个字段在类型 3 的 chunk 中出现。 ExamplesExample 1这个例子显示了一个简单的音频信息流。这个例子演示了信息的冗余。下一个表格演示了在该流中产生的chunk。从消息3起，数据传输优化了。过了这一点之后 ，每个消息（头）只有1个字节的开销。 Example 2此示例说明了一个消息因为太长，以至于无法适用一个128字节的chunk，从而被分解成多个chunk。这里是产生的chunk：Chunk 1的头数据指定了整个消息是307个字节。从两个例子中注意到，类型3的chunk可以用在两种不同的方式中。第一种是指定消息的继续。第二种是指定一个新的消息的开始，它的头可以来自于现有的状态数据。 Protocol Control MessagesRTMP Chunk Stream使用消息类型ID 1，2，3，5，和6来做协议控制消息。这些消息包含了RTMP Chunk Stream协议所需的信息。这些协议控制消息必须有message stream ID 0（被称为控制流），并以chunk stream ID 2被发送。协议控制信息一经被收到后立马生效，它们的时间戳是被忽略的。 Set Chunk Size (1)协议控制消息1，Set Chunk Size，用于通知对端一个新的最大chunk大小。最大chunk大小默认为128字节，但客户端或服务器可以更改此值，并使用此消息更新其对端的状态。例如，假设一个客户端要发送131个字节的音频数据，并且chunk大小为128字节。在这种情况下，客户端可以将此消息发送到服务器，通知它，chunk大小现在为131个字节。然后，客户端可以在一个chunk中发送该音频数据。最大chunk大小应该至少有128个字节，并且必须至少是1个字节。最大chunk大小是独立于每个方向保持的。0：这个位必须是0。chunk size（31个字节）：此字段保存了新的最大chunk大小，以字节为单位，它将用于所有的发送端的后续chunk，直到进一步通知。有效大小为1到2147483647（0x7FFFFFFF），包括2147483647本身；然而，所有大小大于16777215（0xFFFFFF）是等价的，因为没有chunk大于一个消息，没有消息大于16777215个字节。 Abort Message (2)协议控制消息2，Abort Message，用于通知对端，如果它是等待chunk来完成一个消息，然后丢弃在一个chunk stream上收到的部分消息。该端接收chunk stream ID作为该协议消息的payload。应用程序可以在关闭时发送此消息，以指示不需要进一步处理消息。chunk stream ID（32位）：这个字段保存了当前将被丢弃消息的chunk stream ID。 Acknowledgement (3)客户端或服务器必须在接收到等于窗口大小的字节后向对端发送一个acknowledgment确认。窗口大小是发送端没有从接收端接收到确认前发送的最大字节数。此消息指定了序列号，它是到目前为止接收到的字节数。sequence number（32个字节）：这个字段保存到目前为止接收到的字节数。 Window Acknowledgement Size (5)客户端或服务器发送此消息通知对方发送Acknowledgement之间的窗口大小。该发送端希望在它发送了窗口大小的字节数之后，从对端收到Acknowledgement。自上次Acknowledgement发送后，接收端接收指定的字节数后必须发送一个Acknowledgement（第5.4.3节），否则如果Acknowledgement还没有被发送，会话得从新开始。 Set Peer Bandwidth (6)客户端或服务器发送此消息以限制其对端的输出带宽。该端收到此消息后，通过限制未确认数据的发送量以达到输出带宽限制的目的，直到数据量达到此消息指定的窗口大小为止。该端收到此消息后，如果窗口大小与发送端上次发送该消息的不一样，它应该应答一个Window Acknowledgement Size的消息。Limit Type是下列值之一：0 - Hard：该端应该限制它的输出带宽，直到指定的窗口大小为止。1 - Soft：无论哪一个的窗口更小，该端应该限制它的输出带宽直到此消息指定的窗口大小为止或者直到该限制已经有效果为止。2 - Dynamic：如果前一个是硬限制类型，那么此消息被认为是硬限制类型，否则忽略此消息。 RTMP Message Formats此节说明RTMP消息的格式。它基于使用更低级的传输层网络在实体之间传输，例如RTMP Chunk Stream。虽然RTMP被设计于用RTMP Chunk Stream工作，但它可以使用任何其他的传输协议发送消息。RTMP Chunk Stream和RTMP是适合多种音视频应用，包括一对一和一对多的直播点播服务，交互式视频会议应用。 RTMP Message Format服务器和客户端通过网络发送RTMP消息来彼此通信。该消息可以包括音频、视频、数据或任何其他消息。RTMP消息有两部分，一个头部和有效载荷。 Message Header消息头包含以下部分：Message Type：1个字节字段以表示消息类型。范围1-6的ID类型被保留用作协议控制消息。Length：3个字节的字段，表示payload的字节大小。它被制定为大端格式。Timestamp：4个字节的字段，它包含该消息的时间戳。这4个字节以大端字节序封包。Message Stream Id：3个字节的字段，标识消息流。这几个字节被制定为大端格式。 Message Payload消息的另一部分是有效负载payload，这是消息中包含的实际数据。例如，它可以是一些音频采样或压缩的视频数据。payload的格式和解释超出了本文档的范围。 User Control Messages (4)RTMP使用ID为4的消息类型作为用户控制消息。这些消息包含了RTMP streaming层使用到的信息。ID 1，2，3，5和6的协议消息被用于RTMP Chunk Stream协议（第5.4节）。用户控制信息应该使用message stream ID 0（称为控制流），当基于RTMP Chunk Stream发送时，它被用chunk stream ID 2来发送。用户控制信息在流中被收到时立马生效；它们的时间戳被忽略。客户端或服务器发送此消息以通知对端用户控件事件。此消息传输事件类型Event type和事件数据Event data。前2个字节的消息数据用于标识事件类型。事件类型之后就是事件数据。事件数据字段的大小是可变的。然而，在消息通过RTMP Chunk Stream层传输的情况下，最大chunk大小（第5.4.1节）应该足够大，以让这些消息放在一个chunk中。事件类型和事件数据在第7.1.7节中列举。 RTMP Command Messages本节介绍了服务器和客户端之间相互通信的不同类型的消息和命令。服务器和客户端之间交换的不同类型的消息包括用于发送音频数据的音频消息audio messages、用于发送视频数据的视频消息video messages、用于发送任何用户数据的数据消息data messages、共享对象消息shared object messages和命令消息command messages。共享对象消息提供了一个通用的方式来管理多个客户端和一个服务器之间的分布式数据。命令消息携带在客户端和服务器之间的AMF编码命令。客户端或服务器可以使用命令消息请求基于流的远程过程调用（RPC）与对方交流。 Types of Messages服务器和客户端通过网络上的消息互相通信。该消息可以是任何类型，其中包括音频消息、视频消息、命令消息、共享对象消息、数据消息和用户控制消息。 Command Message (20, 17)命令消息携带客户端和服务器之间的AMF编码命令。这些消息为AMF0编码分配消息类型值20，为AMF3 编码分配消息类型值17。这些消息被发送到对端执行一些操作，如连接，创建流、发布、播放，暂停。命令消息类型于状态和结果等，被用来通知发送者的请求命令状态。命令消息由命令名称command name、事务标识transaction ID和包含相关参数的命令对象command object组成。客户端或服务器可以使用命令消息请求基于流的远程过程调用（RPC）与对方交流。 Data Message (18, 15)客户端或服务器通过此消息发送元数据或任何用户数据给对端。元数据包括数据（音频，视频等）的详细信息，如创建时间，持续时间，主题等。这些消息为AMF0和AMF3分别被分配消息类型值18和15。 Shared Object Message (19, 16)共享对象是一个在跨多个客户端，实例等同步的Flash对象（名称-值对的集合）。消息类型19（对于AMF0）和16（对于AMF3）被保留用作共享对象事件shared object events。每个消息可以包含多个事件。下面是支持的事件类型： 事件 描述 Use(=1) 客户端发送此事件通知服务器一个名为共享对象的创建。 Release(=2) 当在客户端删除共享对象时，客户端将此事件发送到服务器上。 Request Change(=3) 客户端发送此事件以请求更改与共享对象命名参数关联的值。 Change (=4) 服务器发送此事件通知除了正在发起请求之外的所有客户端命名参数值的变化。 Success (=5) 如果请求被受理，服务器发送此事件给正在请求的客户端，以响应RequestChange事件。 SendMessage(=6) 客户端将此事件发送到服务器以广播一个消息。在接收此事件时，服务器向所有客户端广播消息，包括该发送者。 Status (=7) 服务器发送此事件以通知客户端相关的错误状况。 Clear (=8) 服务器将此事件发送给客户端，以清除共享对象。服务器还发送清除共享对象。服务器还发送此事件响应客户端在连接时发送的使用事件Use event。 Remove (=9) 服务器发送此事件让客户端删除一个插槽。 Request Remove(=10) 客户端发送此事件让服务器删除一个插槽。 Use Success(=11) 成功连接时，服务器将此事件发送给客户端。 Audio Message (8)客户端或服务器通过发送此消息发送音频数据到对端。消息类型值8被保留用作音频消息。 Video Message (9)客户端或服务器通过发送此消息发送视频数据到对端。消息类型值9被保留用作视频消息。 Aggregate Message (22)一个聚合消息是一个单一的包含了一系列RTMP子消息的消息，它们的格式在6.1节描述。消息类型22用于聚合消息。聚合消息的stream ID优先于聚合体内子消息的stream ID。聚合消息和第一子消息的时间戳之间的差异是时间偏移，它被用于将子消息的时间戳归一化成流的时标。偏移量被加到每个子消息的时间戳，以变成归一化后的流时间。第一次子消息的时间戳应该与聚合消息的时间戳相同，所以偏移量应为0。后面的指针包含在它头部中前一消息的大小。它被包含以匹配FLV文件格式并用于向后定位。使用聚合消息有几个性能优势： chunk stream可以在一个chunk中至多发送一个完整的消息。因此，增加chunk的大小并且使用聚合消息减少了chunk发送的数量。 子消息可以连续存储在内存中。当产生系统调用在网络上发送数据时，它更有效的。 User Control Message Events客户端和服务器发送此消息把用户控制事件通知对端。有关该消息的格式，请参考第6.2节。以下是支持的用户控制事件： 事件 描述 Stream Begin (=0) 服务器发送此事件通知客户端流已成为功能，并可用于通信。默认情况下，在从客户端成功收到应用程序连接命令后，此事件以ID 0来发送。 Stream EOF (=1) 服务器发送此事件通知客户端该流请求的数据回放结束了。若不发出额外的命令，就没有更多的数据被发送了。客户端丢弃该流收到的消息。该4个字节的事件数据代表哪个stream ID的流播放已结束。 StreamDry (=2) 服务器发送此事件通知客户端，在流上没有更多的数据。如果服务器在一段时间内没有检测到任何的消息，它可以通知订阅的客户端流是结束的。该4个字节的事件数据代表结束流的stream ID。 SetBufferLength (=3) 客户端发送此事件通知服务器用于缓冲从流过来的任何数据的缓冲区大小（以毫秒为单位）。此事件在服务器开始处理流之前被发送。事件数据的前4个字节表示stream ID，而下面4个字节代表每毫秒缓冲区的长度。 StreamIsRecorded (=4) 服务器发送此事件来通知客户端，该流是一个记录流。4个字节的事件数据代表记录流的stream ID。 PingRequest (=6) 服务器发送此事件来测试客户端是否是可到达的。事件数据是4个字节的时间戳，代表当服务器发出命令时，本地服务器的时间。客户收到PingRequest时响应PingResponse。 PingResponse (=7) 客户端向服务器发送此事件响应ping请求。事件数据是当收到PingRequest时的4个字节时间戳。 Types of Commands客户端和服务器交换AMF编码的命令。发送者发送一个命令消息，该命令消息包含命令名称command name、事务标识transaction ID和相关参数的命令对象command object。例如，连接命令包含“app”参数，它告诉服务器该客户端要连接的应用程序名称。接收端处理命令并使用相同的transaction ID回应。响应字符串要么是_result，要么是_error，要么是方法名method name，例如，方法名是verifyClient或contactExternalServer。命令字符串_result或_error表示一个应答。transaction ID指示应答相关的重要命令。它与在IMAP等多种协议的标签tag是相同的。命令字符串中的方法名表示发送端正在试图在接收端运行一个方法。下面类型的对象用于发送各种命令：NetConnection：一个服务器和客户端之间的连接的一个更高级别表示的对象。NetStream：一个表示发送音频流、视频流和其他相关数据的信道对象。我们还发送如播放，暂停等控制数据流的命令。 NetConnection CommandsNetConnection管理客户端和服务器之间的双向连接。此外，它为异步远程方法调用提供了支持。下面的命令可以在NetConnection上发送： connect call close createStream Connect客户端向服务器发送连接命令，请求连接到服务器应用程序实例。从客户端到服务器的命令结构如下： 字段名 类型 描述 Command Name String 命令名称，设置为“connect”。 Transaction ID Number 通常设置为1。 Command Object Object 包含名称-值对的命令对象。 Optional User Arguments Object 任何可选的信息。 以下是连接命令对象中使用的名称-值对的描述： 属性 类型 描述 样例值 app String 客户端要连接的服务器应用程序名 testapp flashver String Flash Player的版本号。它与ApplicationScript中getversion()方法返回的字符串是一样的。 FMSc/1.0 swfUrl String 发起连接的SWF源文件的URL file://C:/FlvPlayer.swf tcUrl String 服务器URL。它具有以下的格式。protocol://servername:port/appName/appInstance rtmp://localhost:1935/testapp/instance1 fpad Boolean 如果使用代理，值为true。 true或者false audioCodecs Number 指示客户端支持的音频编码。 SUPPORT_SND_MP3 videoCodecs Number 指示支持什么视频编码。 SUPPORT_VID_SORENSON videoFunction Number 指示支持什么专用的视频方法。 SUPPORT_VID_CLIENT_SEEK pageUrl String SWF文件从哪里加载的网页URL。 http://somehost/sample.html objectEncoding Number AMF编码方法。 AMF3 audioCodecs属性的标志值： 编解码标志 用法 值 SUPPORT_SND_NONE 原始音频，无压缩 0x0001 SUPPORT_SND_ADPCM ADPCM压缩 0x0002 SUPPORT_SND_MP3 mp3压缩 0x0004 SUPPORT_SND_INTEL 未使用 0x0008 SUPPORT_SND_UNUSED 未使用 0x0010 SUPPORT_SND_NELLY8 8-kHz采样速率的NellyMoser压缩 0x0020 SUPPORT_SND_NELLY NellyMoser压缩（5，11，22，和44 kHz采样速率） 0x0040 SUPPORT_SND_G711A G711A声音压缩（仅Flash Media Server支持） 0x0080 SUPPORT_SND_G711U G711U声音压缩（仅Flash Media Server支持） 0x0100 SUPPORT_SND_NELLY16 16-kHz采样速率的NellyMoser压缩 0x0200 SUPPORT_SND_AAC 高级音频编码（AAC）编解码 0x0400 SUPPORT_SND_SPEEX Speex音频 0x0800 SUPPORT_SND_ALL 所有RTMP支持的音频编解码 0x0FFF videoCodecs属性的标志值： 编解码标志 用法 值 SUPPORT_VID_UNUSED 废弃值 0x0001 SUPPORT_VID_JPEG 废弃值 0x0002 SUPPORT_VID_SORENSON Sorenson Flash视频 0x0004 SUPPORT_VID_HOMEBREW V1屏幕共享 0x0008 SUPPORT_VID_VP6 (On2) On2视频（Flash 8+） 0x0010 SUPPORT_VID_VP6ALPHA(On2 with alpha channel) 带有alpha通道的On2视频 0x0020 SUPPORT_VID_HOMEBREWV(screensharing v2) 屏幕共享版本2（Flash 8+） 0x0040 SUPPORT_VID_H264 H264视频 0x0080 SUPPORT_VID_ALL 所有的RTMP支持的视频编解码 0x00FF videoFunction属性的标志值： 方法标志 用法 值 SUPPORT_VID_CLIENT_SEEK 指示客户端可以进行帧精确控制查找 1 对象编码属性的值： 编码类型 用法 值 AMF0 AMF0对象编码，Flash 6及更新版本支持 0 AMF1 来自于Flash 9的AMF3编码（AS3） 3 从服务器到客户端的命令结构如下所示： 字段名 类型 描述 Command Name String _result或者_error；表示响应是否为结果或者错误。 Transaction ID Number 对于connect的应答来说，Transaction ID是1 Properties Object 该连接的描述属性（fmsver等）的名称-值对。 Information Object 来自于服务器的描述应答的名称-值对。“code”，“level”，“description”是这些信息的几个名称。 在该命令执行期间的消息流程是： 客户端发送connect命令给服务器，请求与服务器应用程序实例连接。 在收到connect命令之后，服务器给客户端发送“Window Acknowledgement Size”的协议消息。服务器也会连接connect命令提到的应用程序。 服务器给客户端发送“Set Peer Bandwidth”协议消息。 在处理“Set Peer Bandwidth”协议消息之后，客户端给服务器发送“Window Acknowledgement Size”的协议消息。 服务器给客户端发送另一个类型的协议消息，用户控制消息（StreamBegin）。 服务器发送result命令消息通知客户端该连接的状态（成功或失败）。该命令指定transaction ID（对于connect命令来说，它总是等于1）。该消息也会指定一些属性，如Flash Media Server的版本（字符串）。另外，它指定了其他连接应答相关的信息，比如级别（字符串），编码（字符串），描述（字符串），对象编码（数字）等。 CallNetConnection对象的调用方法在接收端运行远程过程调用（RPC）。RPC调用的名称作为该call命令的参数传递。发送端到接收端的命令结构如下所示： 字符名 类型 描述 Procedure Name String 远程过程调用的名称。 Transaction ID Number 如果需要一个应答，我们给出一个transaction Id。否则，我们传一个0的值。 Command Object Object 如果存在任何的命令信息，它就会被设置，否则，它被设置为null类型。 Optional Arguments Object 任何将要提供的可选参数。 应答的命令结构如下所示： 字段名 类型 描述 Command Name String 命令名称。 Transaction ID Number 命令的ID，标识它属于哪个应答的。 Command Object Object 如果存在任何的命令信息，它就会被设置，否则，它被设置为null类型。 Response Object 该调用方法的应答。 createStream客户端发送命令到服务器创建消息通信的逻辑通道。发布的音频、视频和元数据通过使用createStream命令创建的流通道传输。NetConnection是默认的通信通道，它的stream ID为0。协议和少量命令消息，包括createStream，使用该默认的通信通道。客户端到服务端的命令结构如下所示： 字段名 类型 描述 Command Name String 命令名称。设置为“createStream”。 Transaction ID Number 命令的会话ID。 Command Object Object 如果存在任何的命令信息，它就会被设置，否则，它被设置为null类型。 服务器到客户端的命令结构如下所示： 字段名 类型 描述 Command Name String _result或者_error；表示响应是否为结果或者错误。 Transaction ID Number 命令的ID，标识它属于哪个应答的。 Command Object Object 如果存在任何的命令信息，它就会被设置，否则，它被设置为null类型。 Stream ID Number 该返回值要么是stream ID，要么是一个错误信息对象。 NetStream CommandsNetStream定义了音频，视频和数据信息流可以在连通客户端到服务器的NetConnection上流通的通道。一个NetConnection对象可以支持多种数据流的多个NetStream。以下命令可以在NetStream上从客户端发送到服务器： play play2 deleteStream closeStream receiveAudio receiveVideo publish seek pause 服务器使用“onStatus”命令给客户端发送NetStream状态更新： 字段名 类型 描述 Command Name String 命令名“onStatus”。 Transaction ID Number Transaction ID设置为0。 Command Object Null onStatus消息没有命令对象。 Info Object Object 一个AMF对象至少有下面3种属性：“level”（字符串）：此消息的级别，“warning”、“status”或者“error”其中之一；“code”（ 字符串）：消息代码，比如“NetStream.Play.Start”；“description”（字符串）：一个可读的消息描述。Info对象可能包含其他适合编码的属性。 play客户端将此命令发送到服务器播放流。也可以多次使用此命令创建一个播放列表。如果你想创建一个在不同直播或录制流之间切换的动态播放列表，调用play不止一次并传递false以每次都重置。相反，如果你想立即播放指定的流，传递true以重置清除任何其他播放队列的流。从客户端到服务端的命令结构如下所示： 字段名 类型 描述 Command Name String 命令的名称，设置为“play”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Stream Name String 播放流的名称。如果要播放视频（FLV）文件，指定不带文件扩展名（比如，“sample”）的流名称。如果要回放MP3或者ID3标签，你必须要流名称前加上mp3:的前缀（比如，“mp3:sample”）。如果要播放H.264/AAC文件，你必须在流名称前加上mp4:的前缀，并且指定文件名后缀。比如，要播放文件sample.m4v，指定“mp4:sample.m4v”。 Start Number 一个可选的参数，指定以秒为单位的起始时间。默认值为-2，意思是，该订阅者第一次尝试播放流名称字段指定的直播流。如果该名称的直播流没有被找到，它会播放同名的录播流。如果没有该名称的录播流，该订阅者等到该名称的直播流可用时再播放。如果你在Start字段中传递-1，那么只有流名称字段指定的直播流才会被播放。如果你在Start字段传递0或者一个正数，一个在流名称字段指定的录播流会被播放，起始时间是Start字段指定的时间。如果找不到该记录流，播放列表的下一个条目会被播放。 Duration Number 一个可选的参数，指定以秒为单位的回放时间段。默认值是-1。-1值意味着，直播流被播放直到它不可用，或者录播流被播放直到结束。如果你传递0，它会播放录播流中Start字段指定开始时间的一帧。它假定Start字段的值大于等于0。如果你指定一个正数，它会播放Duration字段指定该段时间的直播流。之后，它能够播放Duration字段指定该段时间的录播流。（如果流在Duration字段指定的时间前结束，回放随着流的结束而结束。）如果你传递一个不同于-1的负数，它会把该值解析为-1。 Reset Boolean 一个可选的布尔值或数字，它指定是否清除之前的所有播放列表。 在该命令执行期间的消息流程是： 客户端在收到来自于服务器的createStream命令的成功结果后，发送play命令。 在收到play命令的同时，服务器发送一个协议消息设置chunk的大小。 服务器发送另一个协议消息（用户控制）指定“StreamIsRecorded”的事件，并且在该消息中带上stream ID。该消息在头2个字节带上事件类型并且在最后4个字节包含stream ID。 服务器发送另一个协议消息（用户控制）指定“StreamBegin”事件，以向客户端指示流的开始。 如果客户端发送的play命令成功的话，该服务器发送一个onStatus的命令消息NetStream.Play.Start和NetStream.Play.Reset。只有客户端发送的play命令带有reset标志时，服务器才会发送NetStream.Play.Reset。如果要播放的流没在被找到，服务器发送NetStream.Play.StreamNotFound的onStatus消息回应。 之后，服务器发送音频和视频数据在客户端播放。 play2不同于play命令，play2可以切换一个不同的码率而不改变播放内容的时间轴。服务器为客户端可以在play2中请求的所有支持的码率维护多个字段。客户端到服务器的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“play2”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Parameters Object 一个AMF编码的对象，它的属性是描述flash.net.NetStreamPlayOptions ActionScript对象的公有属性。 NetStreamPlayOptions对象的公共属性在ActionScript 3语言参考手册中描述。该命令的消息流程如下图所示： deleteStream当NetStream对象将要被销毁时，它发送该deleteStream命令。客户端到服务器的命令结构如下所示： 字段名 类型 描述 Command Name String 命令的名称，设置为“deleteStream”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Stream ID Number 在服务器上销毁流的ID。 该服务器不需要发送任何应答。 receiveAudioNetStream发送receiveAudio消息通知服务器是否发送或不发送音频到客户端。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“receiveAudio”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Bool Flag Boolean true或者false表示是否接收音频。 如果receiveAudio命令发送带有flase的bool flag，服务器不发送任何响应。如果这个标志被设置为true，服务器应答NetStream.Seek.Notify和NetStream.Play.Start的状态消息。 receiveVideoNetStream发送receiveVideo消息通知服务器是否发送或不发送视频到客户端。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“receiveVideo”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Bool Flag Boolean true或者false表示是否接收视频。 如果receiveVideo命令发送带有flase的bool flag，服务器不发送任何响应。如果这个标志被设置为true，服务器应答NetStream.Seek.Notify和NetStream.Play.Start的状态消息。 publish客户端发送publish命令将已命名的流发布到服务器上。使用这个名称，任何客户端都可以播放此流，并接收已发布的音频、视频和数据消息。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“publish”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Publishing Name String 发布流的名称。 Publishing Type String 发布的类型。设置为“live”，“record”或者“append”。record：该流已被发布并且数据被记录到一个新的文件。该文件存储在服务器的一个包含服务器应用程序目录的子目录。如果文件已经存在，则它被覆盖。append：流已经被发布，并且该数据被追加到一个文件。如果找不到文件，则创建它。live：直播数据被发布，而没有记录到文件。 服务器应答onStatus命令，以标记发布的开始。 seek客户端发送seek命令以定位媒体文件内或者播放列表的某个位置（以毫秒为单位）。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“seek”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 milliSeconds Number 定位到播放列表的毫秒数。 当定位成功，服务器发送NetStream.Seek.Notify的状态消息。失败的时候，它返回一个_error的消息。 pause客户端发送pause命令以告诉服务器暂停或者开始播放。客户端到服务端的命令结构如下： 字段名 类型 描述 Command Name String 命令的名称，设置为“pause”。 Transaction ID Number Transaction ID设置为0。 Command Object Null 不存在命令信息，设置为null类型。 Pause/Unpause Flag Boolean true或者false，以表示暂停或者恢复播放。 milliSeconds Number 毫秒数，在流的哪个位置被暂停或者恢复播放的。当流被暂停，这就是客户端的当前流的时间。当播放被恢复，该服务器仅会发送带有大于此值的时间戳的消息。 当流被暂停，服务器发送一个NetStream.Pause.Notify的状态消息。当一个流变成未暂停状态，NetStream.Unpause.Notify被发送。失败的时候，它返回一个_error的消息。 Message Exchange Examples这里是一些样例，以解释使用RTMP的消息交换。 Publish Recorded Video这个例子说明了一个发布者如何可以发布一个流，然后将视频推流到服务器上。其他客户端可以订阅这个已发布的流，并播放视频。 Broadcast a Shared Object Message这个例子说明了在创建和更改共享对象时所交换的消息。它也说明了共享对象消息广播的过程。 Publish Metadata from Recorded Stream这个例子描述了发布元数据的消息交换。 References[RFC0791] Postel, J., “Internet Protocol”, STD 5, RFC 791,September 1981.[RFC0793] Postel, J., “Transmission Control Protocol”, STD 7,RFC 793, September 1981.[RFC1982] Elz, R. and R. Bush, “Serial Number Arithmetic”, RFC 1982,August 1996.[RFC2119] Bradner, S., “Key words for use in RFCs to IndicateRequirement Levels”, BCP 14, RFC 2119, March 1997.[AS3] Adobe Systems, Inc., “ActionScript 3.0 Reference for theAdobe Flash Platform”, 2011, &lt;http://www.adobe.com/devnet/actionscript/documentation.html&gt;.[AMF0] Adobe Systems, Inc., “Action Message Format – AMF 0”,December 2007, &lt;http://opensource.adobe.com/wiki/download/attachments/1114283/amf0_spec_121207.pdf&gt;.[AMF3] Adobe Systems, Inc., “Action Message Format – AMF 3”,May 2008, &lt;http://opensource.adobe.com/wiki/download/attachments/1114283/amf3_spec_05_05_08.pdf&gt;.123456789101112131415161718Authors’ AddressesHardeep Singh Parmar (editor)Adobe Systems Incorporated345 Park AveSan Jose, CA 95110-2704USPhone: +1 408 536 6000Email: hparmar@adobe.comURI: http://www.adobe.com/Michael C. Thornburgh (editor)Adobe Systems Incorporated345 Park AveSan Jose, CA 95110-2704USPhone: +1 408 536 6000Email: mthornbu@adobe.comURI: http://www.adobe.com/]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>RTMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctypes使用指南]]></title>
    <url>%2F2017%2F09%2F17%2Fctypes%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[ctypes 简介从Python2.5开始引入。ctypes是Python的外部函数库。它提供了C兼容的数据类型，并且允许调用动态链接库/共享库中的函数。它可以将这些库包装起来给Python使用。 ctypes 入门本入门中的代码使用doctest确保可用。不过一些代码在linux/windows/mac os x中的行为可能略有差异，这在其doctest的注释中有所表示。少数代码示例引用了ctypes的c_int类型。这个类型是32bit系统中c_long类型的别名。所以你在期待c_int而显示c_long时不必疑惑，他们是一样的。 载入动态链接库ctypes导出了 cdll，在windows上还有 windll 和 oledll 对象用于载入动态链接库。载入动态链接库可以直接存取其属性。 cdll 载入导出函数符合cdecl调用规范的库，而 windll 载入导出函数符合 stdcall 调用规范的库， oledll 也使用 stdcall 调用规范，并假设函数返回Windows的HRESULT错误码。错误码用于在出错时自动抛出WindowsError这个Python异常。如下是Windows的例子，主意msvcrt是MS标准C库，包含了大部分标准C函数，并且使用cdecl调用规范: 1234567&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; print windll.kernel32&lt;WinDLL &apos;kernel32&apos;, handle ... at ...&gt;&gt;&gt;&gt; print cdll.msvcrt&lt;CDLL &apos;msvcrt&apos;, handle ... at ...&gt;&gt;&gt;&gt; libc=cdll.msvcrt&gt;&gt;&gt; Windows通常使用”.dll”作为动态链接库的扩展名。Linux上需要指定包含扩展名的文件名来载入动态库，所以属性存取方式就失效了。你可以使用 LoadLibrary 方法，或者创建CDLL的实例来载入: 123456&gt;&gt;&gt; cdll.LoadLibrary(&quot;libc.so.6&quot;)&lt;CDLL &apos;libc.so.6&apos;, handle ... at ...&gt;&gt;&gt;&gt; libc==CDLL(&quot;libc.so.6&quot;)&gt;&gt;&gt; libc&lt;CDLL &apos;libc.so.6&apos;, handle ... at ...&gt;&gt;&gt;&gt; 从载入的动态链接库中访问函数函数是作为dll对象的属性来存取的: 123456789101112&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; libc.printf&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; print windll.kernel32.GetModuleHandleA&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; print windll.kernel32.MyOwnFunctionTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;ctypes.py&quot;, line 239, in __getattr__ func = _StdcallFuncPtr(name,self)AttributeError: function &apos;MyOwnFunction&apos; not found&gt;&gt;&gt; 注意win32系统动态链接库，如kernel32和user32经常同时导出ANSI和UNICODE版本的函数。UNICODE版本的会在名字末尾加”W”，而ANSI版本的加上”A”。Win32版本的 GetModuleHandle 函数，返回给定模块名的句柄，有如下C原型，还有一个宏用于暴露其中一个作为 GetModuleHandle ，依赖于UNICODE定义与否: 1234/* ANSI version */HMODULE GetModuleHandleA(LPCSTR lpModuleName);/* UNICODE version */HMODULE GetModuleHandleW(LPCWSTR lpModuleName); windll 并不会自动选择调用某个版本，所以你必须指定要调用的，传递的时候也要指定正确的字符串参数类型。有时动态链接库导出函数并不是有效的Python标识符，例如 “??2@YAPAXI@Z” 。这种情况下，你必须使用getattr 获取函数: 123&gt;&gt;&gt; getattr(cdll.msvcrt,&quot;??2@YAPAXI@Z&quot;)&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; 在Windows上，有些动态链接库导出函数不是用名字，而是用序号(ordinal)。这些函数通过索引存取: 123456789&gt;&gt;&gt; cdll.kernel32[1]&lt;_FuncPtr object at 0x...&gt;&gt;&gt;&gt; cdll.kernel32[0]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;ctypes.py&quot;, line 310, in __getitem__ func = _StdcallFuncPtr(name,self)AttributeError: function ordinal 0 not found&gt;&gt;&gt; 调用函数你可以像正常的Python函数一样调用这些函数。这里用 time() 函数示例，返回Unix epoch系统时间，和GetModuleHandleA() 函数，返回win32模块句柄。这个例子调用函数时附带NULL指针(None作为NULL指针): 12345&gt;&gt;&gt; print libc.time(None)1150640792&gt;&gt;&gt; print hex(windll.kernel32.GetModuleHandleA(None))0x1d000000&gt;&gt;&gt; 在调用函数时，如果使用了错误的参数数量和调用规范时，ctypes尝试保护调用。不幸的是该功能仅在Windows上有用。它通过检查函数返回栈来实现，所以尽管发生了错误，但是函数还是调用了: 12345678&gt;&gt;&gt; windll.kernel32.GetModuleHandleA()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with not enough argument (4 bytes missing)&gt;&gt;&gt; windll.kernel.GetModuleHandleA(0,0)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with too many argument (4 bytes in excess) 这在你使用了错误的调用规范时同样会发生: 1234567891011&gt;&gt;&gt; cdll.kernel32.GetModuleHandleA(None) # doctest: +WINDOWSTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with not enough arguments (4 bytes missing)&gt;&gt;&gt;&gt;&gt;&gt; windll.msvcrt.printf(&quot;spam&quot;) # doctest: +WINDOWSTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: Procedure probably called with too many arguments (4 bytes in excess)&gt;&gt;&gt; 想要找到正确的调用规范，你必须查看C头文件或者函数的文档。在Windows，ctypes使用win32结构异常处理，避免无保护的挂掉: 1234&gt;&gt;&gt; windll.kernel32.GetModuleHandleA(32)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?WindowsError: exception: access violation reading 0x00000020 尽管如此，仍然有很多方法用ctypes挂掉Python，所以你必须很小心的使用。None、整数、长整数、字节串和unicode字符串是可以作为本地Python对象直接传递给函数调用的。None是作为C的NULL指针，字 节串和unicode字符串作为内存块指针传递(char 或 wchar_t)。Python整数和长整数作为平台相关的C类型传递。在调用更多的函数之前，必须了解关于ctypes数据类型的知识。 基本数据类型ctypes定义了一系列基本C数据类型： ctypes 类型 C类型 Python 类型 c_char char 1个字符的字符串 c_wchar wchar_t 1个字符的unicode字符串 c_byte char int/long c_ubyte unsigned char int/long c_short short int/long c_ushort unsigned short int/long c_int int int/long c_uint unsigned int int/long c_long long int/long c_ulong unsigned long int/long c_longlong __int64 或 long long int/long c_ulonglong unsigned __int64 或 unsigned long long int/long c_float float float c_double double float c_char_p char * (NUL 结尾字符串) string 或 None c_wchar_p wchar_t * (NUL 结尾字符串) unicode 或 None c_void_p void * int/long 或 None 所有这些类型都可以通过调用可选传输初始化值方式指定值: 123456&gt;&gt;&gt; c_int()c_long(0)&gt;&gt;&gt; c_char_p(&quot;Hello, world&quot;)c_char_p(&apos;Hello, world&apos;)&gt;&gt;&gt; c_ushort(-3)c_ushort(65533) 这些类型都是可变的，其值也是随后可变的: 123456789&gt;&gt;&gt; i=c_int(42)&gt;&gt;&gt; print ic_long(42)&gt;&gt;&gt; print i.value42&gt;&gt;&gt; i.value=-99&gt;&gt;&gt; print i.value-99&gt;&gt;&gt; 对指针类型 c_char_p/c_wchar_p/c_void_p 的赋值将会改变其指向的内存区域地址，而不是改变内存块的值(当然了，因为Python字符串是只读的): 12345678910&gt;&gt;&gt; s=&quot;Hello, world&quot;&gt;&gt;&gt; c_s=c_char_p(s)&gt;&gt;&gt; print c_sc_char_p(&apos;Hello, world&apos;)&gt;&gt;&gt; c_s.value=&quot;Hi, there&quot;&gt;&gt;&gt; print c_sc_char_p(&apos;Hi, there&apos;)&gt;&gt;&gt; print s #第一个字符串没有改变Hello, world&gt;&gt;&gt; 必须小心的是，不要传递这些的指针给可变内存。如果你需要可变内存块，ctypes提供了create_string_buffer() 函数。当前内存块可以存取或改变，如果你想要将其作为NUL结尾字符串方式，使用值的方法: 12345678910111213141516&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; p = create_string_buffer(3) # create a 3 byte buffer, initialized to NUL bytes&gt;&gt;&gt; print sizeof(p), repr(p.raw)3 &apos;\x00\x00\x00&apos;&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;) # create a buffer containing a NUL terminated string&gt;&gt;&gt; print sizeof(p), repr(p.raw)6 &apos;Hello\x00&apos;&gt;&gt;&gt; print repr(p.value)&apos;Hello&apos;&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;, 10) # create a 10 byte buffer&gt;&gt;&gt; print sizeof(p), repr(p.raw)10 &apos;Hello\x00\x00\x00\x00\x00&apos;&gt;&gt;&gt; p.value = &quot;Hi&quot;&gt;&gt;&gt; print sizeof(p), repr(p.raw)10 &apos;Hi\x00lo\x00\x00\x00\x00\x00&apos;&gt;&gt;&gt; create_string_buffer() 函数已经替换了 c_buffer() 函数(仍然作为别名存在)，有如 c_string() 函数以前，只是出现在以前的版本中。想要创建包含unicode字符(对应C类型wchar_t)的可变内存块，使用create_unicode_buffer() 函数。 调用函数，继续需要注意的是，printf打印到真实的标准输出，而不是 sys.stdout ，所以这些例子仅在控制台模式有效，而不是IDLE或PythonWin: 123456789101112131415&gt;&gt;&gt; printf=libc.printf&gt;&gt;&gt; printf(&quot;Hello, %s\n&quot;,&quot;World!&quot;)Hello, World!14&gt;&gt;&gt; printf(&quot;Hello, %S&quot;, u&quot;World!&quot;)Hello, World!13&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, 42)42 bottles of beer19&gt;&gt;&gt; printf(&quot;%f bottles of beer\n&quot;, 42.5)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ArgumentError: argument 2: exceptions.TypeError: Don&apos;t know how to convert parameter 2&gt;&gt;&gt; 如前面所说，除了整数、字符串和unicode字符串以外的Python类型必须使用ctypes类型做包装，所以他们可以转换为必须的C数据类型: 123&gt;&gt;&gt; printf(&quot;An int %d, a double %f\n&quot;,1234,c_double(3.14))An int 1234, a double 3.1400001049&gt;&gt;&gt; 使用自定义数据类型调用函数你可以使用自定义ctypes参数转换，允许你自己的类作为函数参数。ctypes寻找对象的 _as_parameter_ 属性，并将其作为函数参数。当然，必须是整数、字符串或unicode 123456789&gt;&gt;&gt; class Bottles(object):... def __init__(self, number):... self._as_parameter_ = number...&gt;&gt;&gt; bottles = Bottles(42)&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, bottles)42 bottles of beer19&gt;&gt;&gt; 如果你不想存储实例的数据到 _as_parameter_ 实例变量，你可以定义一个属性确保数据有效。 指定必须的参数类型(函数原型)可以通过指定函数的 argtypes 属性来指定函数的参数类型。argtypes必须是一个C数据类型序列(printf函数在这里不是个好例子，因为它需要依赖于格式化字符串的可变数量和多种类型的参数，反过来说倒是很适合于练手): 1234&gt;&gt;&gt; printf.argtypes=[c_char_p,c_char_p,c_int,c_double]&gt;&gt;&gt; printf(&quot;String &apos;%s&apos;, Int %d, Double %f\n&quot;,&quot;Hi&quot;,10,2.2)String &apos;Hi&apos;, Int 10, Double 2.200000&gt;&gt;&gt; 指定不兼容的参数类型，和尝试转换参数到到无效类型会出错: 1234567&gt;&gt;&gt; printf(&quot;%d %d %d&quot;, 1, 2, 3)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ArgumentError: argument 2: exceptions.TypeError: wrong type&gt;&gt;&gt; printf(&quot;%s %d %f&quot;, &quot;X&quot;, 2, 3)X 2 3.00000012&gt;&gt;&gt; 如果你自定义的类要传递给函数调用，必须实现 from_param 类方法，才能在argtypes序列中使用。from_param 类方法接收Python对象传递到函数调用，需要做类型检查或者其他确保对象可以被接受的工作，然后返回对象本身， _as_parameter_ 属性，或者你想要传递给C函数的参数。再次说明，返回结果必须是整数、字符串、unicode、ctypes实例，或者任何有 _as_parameter_ 属性的东西。 返回类型缺省情况假设函数返回C的int类型。其他返回类型可以通过设置函数的 restype 属性来实现。这里是一个更高级的例子，它使用strchr函数，需要一个字符串指针和一个字符，返回字符串的指针: 123456789&gt;&gt;&gt; strchr = libc.strchr&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;)) # doctest: +SKIP8059983&gt;&gt;&gt; strchr.restype = c_char_p # c_char_p is a pointer to a string&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;))&apos;def&apos;&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, ord(&quot;x&quot;))None&gt;&gt;&gt; 如果你想要上面的 ord(“x”) 调用，你可以设置argtypes属性，而第二个参数的Python字符串会转换成C字符: 12345678910111213&gt;&gt;&gt; strchr.restype = c_char_p&gt;&gt;&gt; strchr.argtypes = [c_char_p, c_char]&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)&apos;def&apos;&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;def&quot;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ArgumentError: argument 2: exceptions.TypeError: one character string expected&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, &quot;x&quot;)None&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)&apos;def&apos;&gt;&gt;&gt; 你还可以使用Python的可调用对象(函数或者类的例子)作为restype属性，如果外语函数返回整数。这时在C函数调用结束后会使用其返回的 整数调用这个Python可调用对象，而返回值作为函数调用的返回值。相当于对C函数返回值做了包装。这对于检查错误码而抛出异常的情况非常有用: 12345678910111213141516&gt;&gt;&gt; GetModuleHandle = windll.kernel32.GetModuleHandleA # doctest: +WINDOWS&gt;&gt;&gt; def ValidHandle(value):... if value == 0:... raise WinError()... return value...&gt;&gt;&gt;&gt;&gt;&gt; GetModuleHandle.restype = ValidHandle # doctest: +WINDOWS&gt;&gt;&gt; GetModuleHandle(None) # doctest: +WINDOWS486539264&gt;&gt;&gt; GetModuleHandle(&quot;something silly&quot;) # doctest: +WINDOWSTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 3, in ValidHandleWindowsError: [Errno 126] The specified module could not be found.&gt;&gt;&gt; 这里的 WinError 是一个函数，会调用Windows的 FormatMessage() API来获取错误码的字符串描述，并且返回异常。 WinError 接受可选的错误码参数，如果没有指定则调用 GetLastError() 获取。需要注意的是强大的错误检查机制是通过 errcheck 属性实现的。具体查看手册了解细节。 传递指针(或者传递参数引用)有时C函数需要一个指针指向的数据作为参数，还有可能是想向里面写的位置，或者数据太大不适合传递。这也叫做传递参数引用。 ctypes导出 byref() 函数用于传递参数引用。同样也可以用于指针函数，尽管指针对象可以做很多工作，但是如果你并不需要在Python中使用指针对象的话，使用 byref() 会更快: 1234567891011&gt;&gt;&gt; i = c_int()&gt;&gt;&gt; f = c_float()&gt;&gt;&gt; s = create_string_buffer(&apos;\000&apos; * 32)&gt;&gt;&gt; print i.value, f.value, repr(s.value)0 0.0 &apos;&apos;&gt;&gt;&gt; libc.sscanf(&quot;1 3.14 Hello&quot;, &quot;%d %f %s&quot;,... byref(i), byref(f), s)3&gt;&gt;&gt; print i.value, f.value, repr(s.value)1 3.1400001049 &apos;Hello&apos;&gt;&gt;&gt; 结构和联合结构和联合必须继承自ctypes模块的 Structure 和 Union 类。每个子类必须定义 fields 属性，该属性必须是2元素元组的列表，包含字段名和字段类型。 字段类型必须是ctypes类型，例如 c_int ，或者其他派生的ctypes类型：结构、联合、数组、指针。 这里有个POINT结构体的简单例子，包含两个整数叫做x和y，同时展示了如何构造结构体: 12345678910111213141516&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class POINT(Structure):... _fields_ = [(&quot;x&quot;, c_int),... (&quot;y&quot;, c_int)]...&gt;&gt;&gt; point = POINT(10, 20)&gt;&gt;&gt; print point.x, point.y10 20&gt;&gt;&gt; point = POINT(y=5)&gt;&gt;&gt; print point.x, point.y0 5&gt;&gt;&gt; POINT(1, 2, 3)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: too many initializers&gt;&gt;&gt; 你还可以构造更多复杂的结构体。结构体可以自包含作为一个字段类型。这里是一个RECT结构体，它包含了两个POINT结构体分别名为upperleft和lowerright： 12345678910&gt;&gt;&gt; class RECT(Structure):... _fields_ = [(&quot;upperleft&quot;, POINT),... (&quot;lowerright&quot;, POINT)]...&gt;&gt;&gt; rc = RECT(point)&gt;&gt;&gt; print rc.upperleft.x, rc.upperleft.y0 5&gt;&gt;&gt; print rc.lowerright.x, rc.lowerright.y0 0&gt;&gt;&gt; 嵌套结构体可以通过下面多种方法初始化： 12&gt;&gt;&gt; r = RECT(POINT(1, 2), POINT(3, 4))&gt;&gt;&gt; r = RECT((1, 2), (3, 4)) 域描述可以检索到类，这对调试有很大的帮助，因为它们可以提供到有用的信息： 12345&gt;&gt;&gt; print POINT.x&lt;Field type=c_long, ofs=0, size=4&gt;&gt;&gt;&gt; print POINT.y&lt;Field type=c_long, ofs=4, size=4&gt;&gt;&gt;&gt; 结构/联合对齐和字节序默认情况下结构体和联合的对齐使用C编译器相同的方式。这可以通过 pack 类属性来重载其行为。这必须设置一个正数指定字段的最大对齐。这个功能与MSVC中的 #pragma pack(n) 功能一样。 ctypes中的结构体和联合使用本地字节序。想要用非本地字节序，可以使用 BigEndianStructure 、LittleEndianStructure 、 BigEndianUnion 、 LittleEndianUnion 基类。这些类无法包含指针字段。 结构与联合中的位字段创建结构与联合体时，可以包含位字段。只有整型域才可以使用位字段，位宽可以在fields元组的第三个选项中指定： 123456789&gt;&gt;&gt; class Int(Structure):... _fields_ = [(&quot;first_16&quot;, c_int, 16),... (&quot;second_16&quot;, c_int, 16)]...&gt;&gt;&gt; print Int.first_16&lt;Field type=c_long, ofs=0:0, bits=16&gt;&gt;&gt;&gt; print Int.second_16&lt;Field type=c_long, ofs=0:16, bits=16&gt;&gt;&gt;&gt; 数组数组就是序列，包含固定数量(fixed number of)的相同类型的实例。推荐的创建数组类型的方式是使用正数和乘号应用到类型: 1TenPointsArrayType=POINT*10 这里有个巧妙的例子，一个结构体包含一个字段有4个POINT: 123456789101112&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class POINT(Structure):... _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)...&gt;&gt;&gt; class MyStruct(Structure):... _fields_ = [(&quot;a&quot;, c_int),... (&quot;b&quot;, c_float),... (&quot;point_array&quot;, POINT * 4)]&gt;&gt;&gt;&gt;&gt;&gt; print len(MyStruct().point_array)4&gt;&gt;&gt; 可以通过下面的办法高效访问数组： 123arr = TenPointsArrayType()for pt in arr: print pt.x, pt.y 上面的代码打印一行结果0 0，因为数组数据初始化为0。可以通过下面的办法显式初始化： 123456789&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; TenIntegers = c_int * 10&gt;&gt;&gt; ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)&gt;&gt;&gt; print ii&lt;c_long_Array_10 object at 0x...&gt;&gt;&gt;&gt; for i in ii: print i,...1 2 3 4 5 6 7 8 9 10&gt;&gt;&gt; 指针指针实例使用 pointer() 函数: 1234&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; i=c_int(42)&gt;&gt;&gt; pi=pointer(i)&gt;&gt;&gt; 指针实例有一个 contents 属性返回指针指向的内容对象，例如上面的例子: 123&gt;&gt;&gt; pi.contentsc_long(42)&gt;&gt;&gt; 注意ctypes没有OOR(Original Object Return原始对象返回)，他在你请求一个属性时构造一个新的、等同的对象: 12345&gt;&gt;&gt; pi.contents is iFalse&gt;&gt;&gt; pi.contents is pi.contentsFalse&gt;&gt;&gt; 给指针的contents属性赋值一个新的c_int实例会改变指针指向内容的内存地址： 12345&gt;&gt;&gt; i = c_int(99)&gt;&gt;&gt; pi.contents = i&gt;&gt;&gt; pi.contentsc_long(99)&gt;&gt;&gt; 指针实例可以通过整数下标访问： 123&gt;&gt;&gt; pi[0]99&gt;&gt;&gt; 也可以通过下标访问的方式来改变指针指向的内容： 123456&gt;&gt;&gt; print ic_long(99)&gt;&gt;&gt; pi[0] = 22&gt;&gt;&gt; print ic_long(22)&gt;&gt;&gt; 你也可以使用非0下标访问，但你必须知道你在做什么，比如在C语言：你可以访问或改变任意的内存地址。一般情况下，你仅可以在收到一个C函数返回来的指针，并且你知道它是指向了一个数组时才可以使用这个特性。 指针函数不仅创建了指针实例，它还会先创建指针类型。这些就是指针函数POINTER的工作，它可以接受任何ctypes的类型，并返回一个新的指针： 12345678910&gt;&gt;&gt; PI = POINTER(c_int)&gt;&gt;&gt; PI&lt;class &apos;ctypes.LP_c_long&apos;&gt;&gt;&gt;&gt; PI(42)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?TypeError: expected c_long instead of int&gt;&gt;&gt; PI(c_int(42))&lt;ctypes.LP_c_long object at 0x...&gt;&gt;&gt;&gt; NULL指针具有默认的布尔值False： 1234&gt;&gt;&gt; null_ptr = POINTER(c_int)()&gt;&gt;&gt; print bool(null_ptr)False&gt;&gt;&gt; 当访问或给NULL指针赋值时，会引发python类型检查异常： 1234567891011&gt;&gt;&gt; null_ptr[0]Traceback (most recent call last): ....ValueError: NULL pointer access&gt;&gt;&gt;&gt;&gt;&gt; null_ptr[0] = 1234Traceback (most recent call last): ....ValueError: NULL pointer access&gt;&gt;&gt; 类型转换通常情况下，ctypes会做严格的类型检查。这意味着，如果形参有一个POINTER(c_int)指针指向一个函数或者结构体的成员域类型，那么实参只能接受相同类型的实例。但这个规则在ctypes处理其他对象时也有例外。比如，你可以传递兼容的数据类型来代替指针类型。所以，对于POINTER(c_int)指针类型来说，可以使用c_int数据来代替： 12345678910111213&gt;&gt;&gt; class Bar(Structure):... _fields_ = [(&quot;count&quot;, c_int), (&quot;values&quot;, POINTER(c_int))]...&gt;&gt;&gt; bar = Bar()&gt;&gt;&gt; bar.values = (c_int * 3)(1, 2, 3)&gt;&gt;&gt; bar.count = 3&gt;&gt;&gt; for i in range(bar.count):... print bar.values[i]...123&gt;&gt;&gt; 可以通过给指针的values属性赋值为None来设置NULL指针： 12&gt;&gt;&gt; bar.values = None&gt;&gt;&gt; 在C语言，你可以通过强制类型转换的方法来转换不兼容的类型。ctypes也提供了一个转换函数让你可以使用相同的方式进行类型转换。上面定义的Bar结构体中，它的value域可以支持POINTER(c_int)指针或者c_int数组，但不支持其他类型： 12345&gt;&gt;&gt; bar.values = (c_byte * 4)()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long instance&gt;&gt;&gt; 在这种情况下，转换函数就方便多了。 转换函数可以将一个能转换成ctypes指针的实例转换成另外一个ctypes指针类型。转换函数需要两个参数，第一个是能够转换成指针类型的cytpes实例类型，第二个是ctypes指针类型。它返回第二个参数类型的实例，并且这个实例与第一个参数共用同一块内存： 1234&gt;&gt;&gt; a = (c_byte * 4)()&gt;&gt;&gt; cast(a, POINTER(c_int))&lt;ctypes.LP_c_long object at ...&gt;&gt;&gt;&gt; 所以，Bar结构的values域可以这样通过类型转换来赋值： 12345&gt;&gt;&gt; bar = Bar()&gt;&gt;&gt; bar.values = cast((c_byte * 4)(), POINTER(c_int))&gt;&gt;&gt; print bar.values[0]0&gt;&gt;&gt; 不完全的类型不完全的类型包含结构体，联合体或者类型未指定的数组。在C语言中，它们可以这样先声明后定义： 123456struct cell; /* forward declaration */struct &#123; char *name; struct cell *next;&#125; cell; 直接这样转换成ctypes代码将会无效： 123456789&gt;&gt;&gt; class cell(Structure):... _fields_ = [(&quot;name&quot;, c_char_p),... (&quot;next&quot;, POINTER(cell))]...Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 2, in cellNameError: name &apos;cell&apos; is not defined&gt;&gt;&gt; 因为新类cell在类本身定义时是无效的。在ctypes，我们可以先定义cell类，然后再给它的fields属性赋值： 1234567&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class cell(Structure):... pass...&gt;&gt;&gt; cell._fields_ = [(&quot;name&quot;, c_char_p),... (&quot;next&quot;, POINTER(cell))]&gt;&gt;&gt; 让我们试一下效果。我们创建两个cell的实例，然后让他们互相指向对方，然后尝试访问指针链表几次： 12345678910111213&gt;&gt;&gt; c1 = cell()&gt;&gt;&gt; c1.name = &quot;foo&quot;&gt;&gt;&gt; c2 = cell()&gt;&gt;&gt; c2.name = &quot;bar&quot;&gt;&gt;&gt; c1.next = pointer(c2)&gt;&gt;&gt; c2.next = pointer(c1)&gt;&gt;&gt; p = c1&gt;&gt;&gt; for i in range(8):... print p.name,... p = p.next[0]...foo bar foo bar foo bar foo bar&gt;&gt;&gt; 回调函数ctypes允许从python回调中创建c回调函数指针。这个常常被称为回调函数。 首先，你必须为回调函数创建一个类，这个类知道调用协议，函数返回值类型，函数接受的参数个数及类型。 CFUNCTYPE工厂函数使用普通cdecl调用协议来为回调函数创建类型。并且，在Windows平台，WINFUNCTYPE工厂函数使用stdcall调用协议来为回调函数创建类型。 这两个工厂函数在调用时，参数表都是使用返回值作为第一个参数，而将回调函数所需要的参数作为剩下的参数。 在这里我将使用一个c标准库里的快排函数作为演示例子，快排是一个借助回调函数进行排序的函数。快排将会用到下面的整型数组： 12345&gt;&gt;&gt; IntArray5 = c_int * 5&gt;&gt;&gt; ia = IntArray5(5, 1, 7, 33, 99)&gt;&gt;&gt; qsort = libc.qsort&gt;&gt;&gt; qsort.restype = None&gt;&gt;&gt; 快排调用时需要一个待排序的原始数据指针，数组元素个数，单个元素的大小，以及一个被称为回调的比较函数指针。回调函数形参表需要两个待比较元素类型的指针，它的返回值为，当第一个数据小于第二个时返回负整数，两个数据相等时返回0，其他情况返回正整数。 所以，我们例子所需要的回调函数形参表是两个整型指针，它返回一个整数。首先我们用工厂函数创建回调函数的类型： 12&gt;&gt;&gt; CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))&gt;&gt;&gt; 在真正实现回调函数之前，我们简单打印获取到的参数，然后返回0（一步一步来） 12345&gt;&gt;&gt; def py_cmp_func(a, b):... print &quot;py_cmp_func&quot;, a, b... return 0...&gt;&gt;&gt; 创建C回调函数： 12&gt;&gt;&gt; cmp_func = CMPFUNC(py_cmp_func)&gt;&gt;&gt; 然后运行一下： 123456789101112&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +WINDOWSpy_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;py_cmp_func &lt;ctypes.LP_c_long object at 0x00...&gt; &lt;ctypes.LP_c_long object at 0x00...&gt;&gt;&gt;&gt; 我们已经知道怎么访问指针指向的内容了，所以让我们重新定义一下回调函数： 123456&gt;&gt;&gt; def py_cmp_func(a, b):... print &quot;py_cmp_func&quot;, a[0], b[0]... return 0...&gt;&gt;&gt; cmp_func = CMPFUNC(py_cmp_func)&gt;&gt;&gt; 这是我们在Windows上跑到的结果： 123456789101112&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +WINDOWSpy_cmp_func 7 1py_cmp_func 33 1py_cmp_func 99 1py_cmp_func 5 1py_cmp_func 7 5py_cmp_func 33 5py_cmp_func 99 5py_cmp_func 7 99py_cmp_func 33 99py_cmp_func 7 33&gt;&gt;&gt; 有趣的是，在linux上排序函数运行更高效，它仅需要更少的比较的次数： 1234567&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +LINUXpy_cmp_func 5 1py_cmp_func 33 99py_cmp_func 7 33py_cmp_func 5 7py_cmp_func 1 7&gt;&gt;&gt; 嗯，我们将要完成了！最后一步是要真正去对两个数据进行比较并且返回一个有用的结果： 12345&gt;&gt;&gt; def py_cmp_func(a, b):... print &quot;py_cmp_func&quot;, a[0], b[0]... return a[0] - b[0]...&gt;&gt;&gt; 最后在Windows上运行的结果： 123456789101112&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) # doctest: +WINDOWSpy_cmp_func 33 7py_cmp_func 99 33py_cmp_func 5 99py_cmp_func 1 99py_cmp_func 33 7py_cmp_func 1 33py_cmp_func 5 33py_cmp_func 5 7py_cmp_func 1 7py_cmp_func 5 1&gt;&gt;&gt; 然后下面是linux上的结果: 1234567&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) # doctest: +LINUXpy_cmp_func 5 1py_cmp_func 33 99py_cmp_func 7 33py_cmp_func 1 7py_cmp_func 5 7&gt;&gt;&gt; 很有趣地看到，Windows的快排比在linux版本的快排比较的次数多！ 我们可以简单检查一下排序结果： 1234&gt;&gt;&gt; for i in ia: print i,...1 5 7 33 99&gt;&gt;&gt; 回调函数的重要提示： 确保你在C代码的使用生命周期里保持引用CFUNCTYPE对象。ctypes并不会帮你做这样的事情，如果你没有做保证，它们就会被垃圾回收，然后当你调用这个回调函数时将会导致程序崩溃。 访问动态链接库导出的值有时候，一个动态链接库不仅提供了函数，它还提供了变量。一个例子是，在Python自身库里使用了Py_OptimizeFlag标志变量，这个整型变量被设置为0，1，或者2，它依赖于python在启动时指定的-O或者-OO标志。ctypes可以这样使用in_dll的类方法访问变量值。pythonapi是一个预定义符号可以访问Python C api： 1234&gt;&gt;&gt; opt_flag = c_int.in_dll(pythonapi, &quot;Py_OptimizeFlag&quot;)&gt;&gt;&gt; print opt_flagc_long(0)&gt;&gt;&gt; 如果解析器使用-O命令启动，例子就会打印c_long(1)，或者c_long(2)如果指定-OO参数。 Python的导出指针PyImport_FrozenModules也是一个扩展的例子展示指针的访问使用办法。 根据Python docs文档：这个指针初始化指向一组”struct _frozen`”记录，以一个成员全部都是NULL或者0作为结束标志。当导入一个静态模块，它就会在这张表里面搜索。第三方代码可以利用此技巧提供一个静态模块的动态创建集合。 所以熟悉这个指针证明还是挺有用的。为了限制例子的大小，我们仅展示这个表如果通过ctypes来访问。 12345678&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt;&gt;&gt;&gt; class struct_frozen(Structure):... _fields_ = [(&quot;name&quot;, c_char_p),... (&quot;code&quot;, POINTER(c_ubyte)),... (&quot;size&quot;, c_int)]...&gt;&gt;&gt; 我们已经定义struct_frozen的数据结构类型，所以我们可以获得指向这张表的指针： 123&gt;&gt;&gt; FrozenTable = POINTER(struct_frozen)&gt;&gt;&gt; table = FrozenTable.in_dll(pythonapi, &quot;PyImport_FrozenModules&quot;)&gt;&gt;&gt; 由于此表是一个struct_frozen记录的数据指针，所以我们可以迭代遍历它，不过我们必须保证结束我们的循环，因为此指针没有指明大小。迟早它会因为非法访问而导致崩溃，所以当我们访问到NULL实体时，最好结束循环： 12345678910&gt;&gt;&gt; for item in table:... print item.name, item.size... if item.name is None:... break...__hello__ 104__phello__ -104__phello__.spam 104None 0&gt;&gt;&gt; 事实上，标准Python有一个并不怎么出名的静态模块和一个静态包（相对于其他成员来说），它仅用于测试。试试用import hello吧。 意料之外在ctypes，有些坑可能你没想到。 思考下面的例子： 1234567891011121314151617&gt;&gt;&gt; from ctypes import *&gt;&gt;&gt; class POINT(Structure):... _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)...&gt;&gt;&gt; class RECT(Structure):... _fields_ = (&quot;a&quot;, POINT), (&quot;b&quot;, POINT)...&gt;&gt;&gt; p1 = POINT(1, 2)&gt;&gt;&gt; p2 = POINT(3, 4)&gt;&gt;&gt; rc = RECT(p1, p2)&gt;&gt;&gt; print rc.a.x, rc.a.y, rc.b.x, rc.b.y1 2 3 4&gt;&gt;&gt; # now swap the two points&gt;&gt;&gt; rc.a, rc.b = rc.b, rc.a&gt;&gt;&gt; print rc.a.x, rc.a.y, rc.b.x, rc.b.y3 4 3 4&gt;&gt;&gt; 嗯，我们当然期望最后一名打印3 4 1 2。到底发生了什么事？这里是上面rc.a, rc.b = rc.b, rc.a这一行的步骤： 1234&gt;&gt;&gt; temp0, temp1 = rc.b, rc.a&gt;&gt;&gt; rc.a = temp0&gt;&gt;&gt; rc.b = temp1&gt;&gt;&gt; 注意，temp0和temp1都是使用了上述rc对象的内部缓存块对象。所以当执行rc.a = temp0时，拷贝了temp0的缓冲内容给rc的缓冲。依次地，又改为temp1的内容。所以最后一句rc.b = temp1并没有想像中那样的效果。记住，检索结构体，联合体及数组并不是使用它们的拷贝，而是检索一个访问顶级对象相关缓冲区的封装对象。 另外一个意想不到的例子是： 1234567&gt;&gt;&gt; s = c_char_p()&gt;&gt;&gt; s.value = &quot;abc def ghi&quot;&gt;&gt;&gt; s.value&apos;abc def ghi&apos;&gt;&gt;&gt; s.value is s.valueFalse&gt;&gt;&gt; 为什么这里打印False？ctypes实例是一些包含内存块加上一些内容内存访问描述信息的对象。存储一个Python对象在内存块并不是存储对象本身，取而代之存储的是对象的内容。每次访问内容时都会构造一个新的Python对象！ 可变大小的数据类型ctypes提供了可变数组与结构体的支持（在0.9.9.7版本增加）。 resize函数可以调整一个已经存在的ctypes对象的内存缓冲大小。这个函数以ctypes对象为第一个参数，以需要调整后的字节大小为第二个参数。重新调整的内存块大小不能小于原生对象类型的内存块大小，若你这么做，则会抛出ValueError： 12345678910111213&gt;&gt;&gt; short_array = (c_short * 4)()&gt;&gt;&gt; print sizeof(short_array)8&gt;&gt;&gt; resize(short_array, 4)Traceback (most recent call last): ...ValueError: minimum size is 8&gt;&gt;&gt; resize(short_array, 32)&gt;&gt;&gt; sizeof(short_array)32&gt;&gt;&gt; sizeof(type(short_array))8&gt;&gt;&gt; 这看起来不错，但怎么访问这个数据增加的元素呢？由于type方法仍然只知道有4个元素，当访问其他元素时我们会得到错误： 1234567&gt;&gt;&gt; short_array[:][0, 0, 0, 0]&gt;&gt;&gt; short_array[7]Traceback (most recent call last): ...IndexError: invalid index&gt;&gt;&gt; ctypes中另外一种使用可变数据类型的方法是使用Python的动态语言特性，具体问题具体分析，当已经知道需要的数据大小时，才（重）定义数据类型。 bug, todo和未完成的东西没有实现枚举类型。你自己使用c_int作为基类就可以简单实现它。 没有实现long double类型。 参考资料 http://starship.python.net/crew/theller/ctypes/tutorial.html#bugs-todo-and-non-implemented-things本文档翻译的文章。 http://gashero.iteye.com/blog/519837本文档主要借鉴参考的文章。 http://www.isnowfy.com/introduction-to-python-c-extension/简单列举了各种python的c扩展办法。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>ctypes</tag>
        <tag>Cross language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Protocol Buffers 使用教程]]></title>
    <url>%2F2017%2F08%2F05%2FProtocol-Buffers-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述什么是 protocol buffers?ProtocolBuffer 是用于结构化数据串行化的灵活、高效、自动的方法，类似 XML，不 过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码 来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。 他们如何工作你首先需要在一个.proto 文件中定义你需要做串行化的数据结构信息。每个 ProtocolBuffer 信息是一小段逻辑记录，包含一系列的键值对。这里有个非常简单的.proto 文件定义了个人信息: 12345678910111213141516message Person &#123; required string name=1; required int32 id=2; optional string email=3; enum PhoneType &#123; MOBILE=0; HOME=1; WORK=2; &#125; message PhoneNumber &#123; required string number=1; optional PhoneType type=2 [default=HOME]; &#125; repeated PhoneNumber phone=4;&#125; 如你所见，消息格式很简单，每个消息类型拥有一个或多个特定的数字字段，每个字 段拥有一个名字和一个值类型。值类型可以是数字(整数或浮点)、布尔型、字符串、原始字 节或者其他 ProtocolBuffer 类型，还允许数据结构的分级。你可以指定可选字段，必选字 段和重复字段。你可以在protocolbuffers/docs/proto找到更多关于如何 编写 .proto 文件的信息。 一旦你定义了自己的报文格式(message)，你就可以运行ProtocolBuffer编译器，将你 的.proto 文件编译成特定语言的类。这些类提供了简单的方法访问每个字段(像是 query() 和 set_query() )，像是访问类的方法一样将结构串行化或反串行化。例如你可以选择 C++ 语言，运行编译如上的协议文件生成类叫做 Person 。随后你就可以在应用中使用这个类来 串行化的读取报文信息。你可以这么写代码: 12345Person person;person.set_name(&quot;John Doe&quot;);person.set_id(1234); person.set_email(&quot;jdoe@example.com&quot;);fstream.output(&quot;myfile&quot;,ios::out | ios::binary);person.SerializeToOstream(&amp;output); 然后，你可以读取报文中的数据: 12345fstream input(&quot;myfile&quot;,ios::in | ios:binary);Person person;person.ParseFromIstream(&amp;input);cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.email() &lt;&lt; endl; 你可以在不影响向后兼容的情况下随意给数据结构增加字段，旧有的数据会忽略新的字段。所以如果使用 ProtocolBuffer 作为通信协议，你可以无须担心破坏现有代码的情况下扩展协议。 你可以在 API 参考overview中找 到完整的参考，而关于 ProtocolBuffer 的报文格式编码则可以在encoding中找到。 为什么不使用 xml?ProtocolBuffer 拥有多项比 XML 更高级的串行化结构数据的特性，ProtocolBuffer: 更简单小3-10倍快20-100倍更少的歧义可以方便的生成数据存取类例如，让我们看看如何在 XML 中建模 Person 的 name 和 email 字段: 1234&lt;person&gt;&lt;name&gt;John Doe&lt;/name&gt;&lt;email&gt;jdoe@example.com&lt;/email&gt;&lt;/person&gt; 对应的 ProtocolBuffer 报文则如下: 1234person &#123; name: &quot;John Doe&quot; email: &quot;jdoe@example.com&quot;&#125; 当这个报文编码encoding到 ProtocolBuffer 的二进制格式时(上面的文本 仅用于调试和编辑)，它只需要28字节和100-200ns 的解析时间。而 XML 的版本需要69字节(除 去空白)和5000-10000ns 的解析时间。 当然，操作 ProtocolBuffer 也很简单: 12cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.email() &lt;&lt; endl; 而 XML 的你需要: 123456cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.getElementsByTagName(&quot;name&quot;)-&gt;item(0)-&gt;innerText() &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.getElementsByTagName(&quot;email&quot;)-&gt;item(0)-&gt;innerText() &lt;&lt; endl; 当然，ProtocolBuffer 并不是在任何时候都比 XML 更合适，例如 ProtocolBuffer 无法 对一个基于标记文本的文档建模(比如 HTML)，因为你根本没法方便的在文本中插入结构。 另外，XML 是便于人类阅读和编辑的，而 ProtocolBuffer 则不是。还有 XML 是自解释的， 而 ProtocolBuffer 仅在你拥有报文格式定义的.proto 文件时才有意义。 如何开始?下载包，包含了 Java、Python、 C++的 ProtocolBuffer 编译器，用于生成你需要的 IO 类。构建和安装你的编译器，跟随 README 的指令就可以做到。 一旦你安装好了，就可以跟着编程指导来选择语言- 随后就是使用 ProtocolBuffer 创建一个简单的应用了。 一点历史ProtocolBuffers 最初是在 Google 开发的，用以解决索引服务器的请求、响应协议。 在使用 ProtocolBuffers 之前，有一种格式用以处理请求和响应数据的编码和解码，并且支 持多种版本的协议。而这最终导致了丑陋的代码，比如:12345678if (version==3) &#123; ...&#125; else if (version&gt;4) &#123; if (version==5) &#123; ... &#125; ...&#125; 通信协议因此变得越来越复杂，因为开发者必须确保，发出请求的人和接受请求的人必 须同时兼容，并且在一方开始使用新协议时，另外一方也要可以接受。ProtocolBuffers 设计用于解决这一类问题: 很方便引入新字段，而中间服务器可以忽略这些字段，直接传递过去而无需理解所有的 字段。 格式可以自描述，并且可以在多种语言中使用(C++、Java 等) 然而用户仍然需要手写解析代码。 随着系统的演化，他需要一些其他的功能: 自动生成编码和解码代码，而无需自己编写解析器。 除了用于简短的 RPC(Remote Procedure Call)请求，人们使用 ProtocolBuffer来做数据存储格式(例如 BitTable)。 RPC服务器接口可以作为 .proto 文件来描述，而通过 ProtocolBuffer的编译器生成存根(stub)类供用户实现服务器接口。 ProtocolBuffers 现在已经是 Google 的混合语言数据标准了，现在已经正在使用的有 超过48,162种报文格式定义和超过12,183个 .proto 文件。他们用于 RPC 系统和持续数据存 储系统。 环境安装下载官方下载网站 安装12345tar -zxvf protobuf-2.5.0.tar.gzcd protobuf-2.5.0./configure --prefix=$INSTALL_DIRmakemake install 更详细的安装步骤请参考源码目录下的 README.txt。 安装完后在INSTALL_DIR目录下生成三个目录: 1bin include lib bin目录下是protoc工具，用于将你的.proto 文件编译成相应目标语言的编解码代码。include和lib目录是protoc工具所依赖的头文件与库环境。 利用protoc工具编译成目标语言编译前，先准备你的.proto 文件，这里暂时以源码目录下的 examples/addressbook.proto 文件为例。 protoc 用法: 1Usage: ./protoc [OPTION] PROTO_FILES 详情请使用 1./protoc --help 开始将你的.protoc 文件编译成目标语言编解码文件: 12mkdir c java python./protoc --proto_path=./ --cpp_out=c/ --java_out=java/ --python_out=python/ addressbook.proto 官方的 protoc 工具仅支持C++/java/python三种语言，如果你使用其他语言，比如 c#，php，你可以使用其他第三方工具。命令简介: 1./protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto 其中: 123--proto_path:.proto 所在的路径--cpp_out:生成 C++代码的路径--java_out:生成 java 代码的路径--python_out:生成 python 代码的路径 Python如何使用protocol buffers安装 python 的 pb 库:在 protobuf 源码目录下可以找到一个目录python，没错，你需要进入此目录安装python的pb库。 12cd protobuf-2.5.0/python$PYTHONHOME/bin/python setup.py install --prefix=$PYTHONHOME 使用–prefix 选项指定你 python 的安装目录，然后静待安装完成。以下是安装时常见的错误: 安装提示 error: package directory ‘google/protobuf/compiler’ does not exist 解决办法： 执行mkdir google/protobuf/compiler 创建compiler目录即可。 TBD 安装完 python 的 pb 库后，你就可以在源码的 examples 目录中，使用 add_person.py 和 list_people.py 来测试如何使用 pb 序列化与反序列化了。序列化与反序列化的相关接口 分别为 SerializeToString()和 ParseFromString()。 更多 python 相关的 api 请看protocol-buffers/docs/reference/python/index。 其他语言如何使用protocol buffersTBD 语言指导消息定义在.proto 文件里面用 Protocol Buffers 消息类型进行定义，每一个 Protocol Buffers消息是信息的一条小的逻辑记录，里面包含一系列名称-值对。下面是一个简单的.proto 文件: 12345message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;&#125; 字段类型可以是基本类型，例如整形、浮点型，值类型可以是其他的 Protocol Buffers 的消息类型，这样你可以用分层的方式定义你的数据结构。 分配字段Tag(标记)每个字段必须有一个唯一的标记，这个标记在序列化时会作为字段的标识出现在序 列化后的二进制数据中。一旦该消息用于生产，字段的 tag 就不能修改了。标记的值小 于15时序列化编码为一个字节，大于15会用到两个以上的字节。 指定字段的规则消息的字段可以具有以下类型的属性: required: 消息中必须包含一个该字段的值 optional: 可选字段，消息中可以有0个或一个该字段的值 repeated: 重复字段，消息中可以有0个或多个该字段的值 选择字段规则的建议你可以在你的消息格式里面添加新的域，而不用考虑向后兼容性，老的二进制流在 解析的时候可以简单的忽略掉新增的域。因此如果你使用 Protocol Buffers 作为你数据 格式的通信协议时，你可以扩展你的协议，而不用担心破坏现有的代码。对于 required，尽可能的少用，若一个字段开始时指定为 required，则以后就不能 修改为 optional。建议将字段设置都设置为 optional 类型，这样字段的 required 规则可以放在业务代码中进行处理。 增加更多的消息类型在单个 .proto 文件里可以定义多种消息类型: 123456789message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;&#125;message SearchResponse &#123; ...&#125; 注释.proto 文件使用 C/C++的注释风格: 12345message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; // Which page number do we want? optional int32 result_per_page = 3; // Number of results to return per page.&#125; 数值类型下表列举了 pb 协议数据类型与 C++/Java/Python 语言的类型对应关系: .proto Type Notes C++ Type Java Type Python Type[2] double double double float float float float float int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int int int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 long int/long[3] uint32 Uses variable-length encoding. uint32 int[1] int/long[3] uint64 Uses variable-length encoding. uint64 long[1] int/long[3] sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long[3] fixed32 Always four bytes. More efficient than uint32 if values are often greater than 228. uint32 int[1] int fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 256. uint64 long[1] int/long[3] sfixed32 Always four bytes. int32 int int sfixed64 Always eight bytes. int64 long int/long[3] bool bool boolean boolean string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode[4] bytes May contain any arbitrary sequence of bytes. string ByteString str 你可以在protocol-buffers/docs/encoding找到这些类型在 pb 序列化时是如何被编码的。 [1] 在 Java, unsigned 32-bit and 64-bit integers 都是使用最高位表示符号位，而无符号位部分是一样的。 [2] 所有情况下，赋值操作会触发类型检查以保证可用性。 [3] 64-bit or unsigned 32-bit integers 会被解码为 long 类型，但如果在赋值时使用 int 类型的话，解码后可以是 int 类型。任何情况下，值必须与被赋值时一样。见[2]。 [4] Python strings 类型在解码后是 unicode 类型，但如果原始字符串是 ASCII 编码的话也可能是 str 类型。 可选字段规则与默认值一个消息字段可以使用 optional 规则来限定，表示该字段是可选类型，即该消息可以 包含该字段也可以不包含该字段。当一个消息被解析时，如果序列化数据没有包含 optional 字段，则该字段会使用默认值来代替。默认值可以显式指定如下: 1optional int32 result_per_page = 3 [default = 10]; 如果没有显式指定默认值，则使用数据类型的默认值来代替:比如，字符串类型的默认值是空字符串，布尔类型的默认值是 false，数字类型的默认值是0，枚举类 型的默认值是第一个被定义的枚举值。 枚举类型使用 enum 关键字定义枚举类型，比如你想定义一个叫 Corpus 的枚举类型: 123456789101112131415message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3 [default = 10]; enum Corpus &#123; UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; &#125; optional Corpus corpus = 4 [default = UNIVERSAL];&#125; 使用其他消息类型你可以使用其他的消息类型来定义你的消息字段，以构成各种复合类型，比如 SearchResponse 消息里定义了一个 Result 消息类型的字段: 123456789message SearchResponse &#123; repeated Result result = 1;&#125;message Result &#123; required string url = 1; optional string title = 2; repeated string snippets = 3;&#125; 另外，你还可以使用 import 语句导入其他.proto 文件定义的消息类型。 包含路径的 import: 1import &quot;myproject/other_protos.proto&quot;; 不包含路径的 import: 12import public &quot;new.proto&quot;;import &quot;other.proto&quot;; 当使用 public 域 import 时，编译器会去 -I/–proto_path 标志指定的路径去查找，如果没有指定此标志，它会去编译器目录索引。通常情况下，建议你使用 –proto_path 指 定为项目的根路径，并且使用全名（包含命名空间或包名）import。 命名风格良好的命名风格让你的.proto 文件更加易读。 消息以及字段名称使用 CamelCase 方式命名消息名称，使用下划线分隔的名字来命名消息的字段，例如: 123message SongServerRequest &#123; required string song_name = 1;&#125; 枚举类型使用 CamelCase 方式命名消息名称，例如 PhoneType 使用大写字母+下划线来命名枚举值，例如: 12345enum PhoneType &#123; TYPE_MOBILE = 0; TYPE_HOME = 1; TYPE_WORK = 2;&#125; 服务如果你的.proto 文件定义了 RPC 服务，你可以使用 CamelCase 的方式命名你的服务名与RPC 方法名: 123service FooService &#123; rpc GetSomething(FooRequest) returns (FooResponse);&#125; 编码原理本节主要介绍 protocol buffer 消息转换成二进制格式的原理。如果仅需要了解怎么使 用 protocol buffers，你可以无需理解这些原理，但了解这些能帮助你理解 protocol buffers 对编码后数据大小的影响。 一个简单的消息下面是一个简单的消息定义: 123message Test1 &#123; required int32 a = 1;&#125; 若你创建了一个 Test1的消息，然后 a 赋值为150，序列化后，你会发现消息被编码为 下面3个字节: 108 96 01 看起来非常小巧与数字化，但它代表什么意义?继续看下去，好戏还在后头…… 变长整型(varint)为了理解 protocol buffer 的编码原理，你首先需要理解 varint 的概念。Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小 的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。注意，采用 Varint 表示法，大的数字则需要更多个 byte 来表示。从统计的角度来说，一般不会所有消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。Varint 中的每个 byte 的最高位 most significant bit (msb) 有特殊的含义，如果 该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示:1010 1100 0000 0010，以下是它的解码过程: 首先按照字节分组: 11010 1100 0000 0010 去掉 msb 1010 1100 000 0010 将字节反向排列 1000 0010 010 1100 重新组合成字节 1000 001 0010 1100 → 100101100=300 消息结构一个 protocol buffer 消息是一系列的键-值对。序列化后的二进制消息仅使用字段数字为 key。当消息被编码后，键值对被组织成一个字节流。消息在解码后，解析器能够忽略不认识 的字段。按照这样的方式，旧程序能够忽略不认识的新增字段。最后，”key”实际上是由两个值组成的，其中一个是.proto 文件的字段数字标号，另外一个是 wire types，这样才 能提供足够的信息去找到接下来数据的长度。下面是可用的wire types: Type Meaning Used For 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimited string, bytes, embedded messages, packed repeated fields 3 Start group groups (deprecated) 4 End group groups (deprecated) 5 32-bit fixed32, sfixed32, float 每个消息流的 key 都是一个 varint 类型，它的值为(field_number &lt;&lt; 3) | wire_type 。换句话说，最后三位用于保存 wire type 。 比如 key 是08，去掉 msb 位后如下: 1000 1000 则field_number 和 wire type 分别为: 12field_number=0001wire_type=000 更多的值类型带符号整数在前面的例子中，所有的 protocol buffer 类型都是 wire type 0的 varints 类型。然 而，带符号整数 (sint32 and sint64)与标准的整型(int32 and int64)在编码时有很大的 区别。如果你使用 int32 或者 int64来表示一个负数，结果需要10个字节，因为它会被认为 是一个非常大的无符号整数。为此，对带符号整数使用 ZigZag 编码会更高效。ZigZag 编码用无符号数来表示有符号数字，正数和负数交错，这就是 zigzag 这个词 的含义了。使用 zigzag 编码时，与0距离越近，编码时使用的值越小，从统计意义层面来看， 这样编码更高效，因为数据通信中绝对值小的数据交互占的比例要高。下面是 ZigZag 的编 码表: Signed Original Encoded As 0 0 -1 1 1 2 -2 3 2147483647 4294967294 -2147483648 4294967295 换句话说，每个值 n 都使用以下方式编码: 12sint32:(n &lt;&lt; 1) ^ (n &gt;&gt; 31)sint34:(n &lt;&lt; 1) ^ (n &gt;&gt; 63) 注意到第二个位移部分(n &gt;&gt; 31)实际上是算术位移，所以若 n 是正数，算术位移后得到的数全部位都是0，若 n 是负数，算术位移后得到的数全部位都是1。 当 sint32或 sint64被解析时，它的值会被解码回原始的带符号数。 非 varint 数非 varint 的数据类型就非常简单了， double 和 fixed64是 wire type 1，它会告诉解 析器期望的是一个固定的64位数据块;类似的，float 和 fixed32是 wire type 5，它会告 诉解析器期望的是一个固定的32位数据块。无论何种情况，值都是以 little-endian 小端对 齐的字节顺序方式存储。 字符串wire type 2 (length-delimited) 意思是它的值先使用一个 varint 来表示编码后的 数据大小，而接下来就是相应长度的编码数据了。 123message Test2 &#123; required string b = 2;&#125; 设置 b 的值为”testing”，你会得到下面编码: 112 07 74 65 73 74 69 6e 67 分析 key，首先第一个字节12为: 10001 0010 msb 为0，表示 key 仅用一个字节表示，去掉 msb: 1001 0010 根据 key 的解码办法，得到: 12field_number = 0010 = 2wire_type = 010 = 2 分析第二个字节07，根据 varint 编码可知数据长度为7，然后紧跟后面的7个字节则为 “testing”。 嵌套消息下面 Test3是一个嵌套消息: 1234567message Test1 &#123; required int32 a = 1;&#125;message Test3 &#123; required Test1 c = 3;&#125; 如果将 Test1的 a 字段赋值为150，则得到下面的编码: 11a 03 08 96 01 还记得编码原理刚开始提到的“一个简单的消息”吗?后面3个字节是否似曾相识？而Test3是嵌套消息，它的 wire type = 2，请参照该类型的编码办法即可解码。 可选与重复元素Optional 可选字段optional 可选元素在消息编码时可以有0或者1个键值对。 Repeated 重复字段Repeated 字段序列化时，序列化的结果中包含0个或多个 key-value，每个 key-value 都包含字段的 tag。PB2.1.0版本中提供了另外一种 Repeated 字段，即带有[packed=true]属性的 Repeated 字段，这种字段又称为:packedrepeated field。packed repeated field 字段序列化时，有0个或多个元素，并且所有的 元素打包在一个 key-value 中，key-value 的类型采用 wire type 2 (length-delimited)，每个元素不需要提供各自的 tag。下面是一个例子: 123message Test4 &#123; repeated int32 d = 4 [packed=true];&#125; 序列化字节码: 1234522 // tag (field number 4, wire type 2)06 // payload size (6 bytes)03 // first element (varint 3)8E 02 // second element (varint 270)9E A7 05 // third element (varint 86942) 相关序列化与反序列化技术的性能比较本章节内容摘自thrift-protobuf-compare。作者提到，数值并非一切，仅供参考，实际上测试结果会受硬件，测试用例等影响。 总耗时(包括对象创建，序列化与反序列化): 序列化时间(每次序列化的时间，包括对象创建时间): 反序列化时间: 序列化大小: 对象创建时间: 从上面的数据来看，protocol buffers 在序列化与反序列化性能及序列化后的数据大 小方面都不有错的表现。 参考资料 https://developers.google.com/protocol-buffers/Protocol-buffers 的官方介绍，本教程的主要参考资料。 http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/Protocol Buffers 原理的中文介绍。 http://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking#Object_Creation_Time Protocol Buffers 与其他相关技术的性能对比。 http://www.cppblog.com/liquidx/archive/2009/06/23/88366.html http://blog.csdn.net/hguisu/article/details/20721109]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>PB</tag>
        <tag>Protocol Buffers</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The background of this blog]]></title>
    <url>%2F2017%2F07%2F23%2FThe-background-of-this-blog%2F</url>
    <content type="text"><![CDATA[欢迎浏览本博客。作为第一篇非技术类的文章，可能没什么干货分享，但总感觉应该写点什么。好吧，就谈谈开博背景！ 自由。本人喜欢自由的写作，在其他博客平台，总有各种各样的限制，比如审核。自己的博客，样式随便改。 简洁。喜欢MarkDown的简洁，也喜欢简洁的博客主题。 分享。无他，写博客就为了分享。当然，这也是大家相互学习的一种有效途径。 精彩。人生在世，不过短短几十年，我们不是什么伟人，但这可以记录我们的精彩。 战斗吧，兄弟！]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hello World</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
